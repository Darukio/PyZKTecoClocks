{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyZKTecoClocks","text":"<p>\u26a0\ufe0f Nota / Note: Esta p\u00e1gina est\u00e1 disponible solo en Espa\u00f1ol temporalmente. This page is currently available in Spanish only.</p>"},{"location":"#que-es-pyzktecoclocks","title":"\u00bfQu\u00e9 es PyZKTecoClocks?","text":"<p>Librer\u00eda y aplicaciones para gestionar relojes de asistencia ZKTeco desde Python:</p> <ul> <li>Programa Reloj de Asistencias: GUI de escritorio para reiniciar dispositivos, probar conexiones, sincronizar hora y descargar marcaciones.  </li> <li>Servicio Reloj de Asistencias: Demonio programable en segundo plano para automatizar tareas de asistencia.</li> </ul>"},{"location":"#instalacion-rapida","title":"Instalaci\u00f3n r\u00e1pida","text":"<p>1. Prerrequisitos</p> <pre><code>- Python 3.7+  \n- Windows 10 o superior\n</code></pre> <p>2. Clona e instala</p> <pre><code>git clone &lt;repo-url&gt; &amp;&amp; cd PyZKTecoClocks\npython install.py\n</code></pre> <p>3. Construir ejecutables</p> <p>Ejecuta en PowerShell (como administrador):</p> <p>3.1. Programa:</p> <pre><code>pyinstaller.exe --noconsole --clean --onefile \\\n--version-file version_info.txt \\\n--hidden-import=eventlet.hubs.epolls \\\n--hidden-import=eventlet.hubs.kqueue \\\n--hidden-import=eventlet.hubs.selects \\\n--hidden-import=dns \\\n--hidden-import=dns.dnssec \\\n--hidden-import=dns.e164 \\\n--hidden-import=dns.hash \\\n--hidden-import=dns.namedict \\\n--hidden-import=dns.tsigkeyring \\\n--hidden-import=dns.update \\\n--hidden-import=dns.version \\\n--hidden-import=dns.zone \\\n--hidden-import=dns.versioned \\\n-n \"Programa Reloj de Asistencias\" \\\n-i \"resources/fingerprint.ico\" \\\n--add-data \"json/errors.json;json/\" \\\n--add-data \"resources/window/*;resources/window\" \\\n--add-data \"resources/system_tray/*;resources/system_tray\" \\\n--add-data \"resources/fingerprint.ico;resources/\" \\\n--noupx \\\n--log-level=INFO \\\n--debug all \\\nmain.py\n</code></pre> <p>3.2. Ejecutable del Servicio:</p> <pre><code>pyinstaller --noconsole --clean --version-file version_info.txt --onefile --hidden-import=eventlet.hubs.epolls --hidden-import=eventlet.hubs.kqueue --hidden-import=eventlet.hubs.selects --hidden-import=dns --hidden-import=dns.dnssec --hidden-import=dns.e164 --hidden-import=dns.hash --hidden-import=dns.namedict --hidden-import=dns.tsigkeyring --hidden-import=dns.update --hidden-import=dns.version --hidden-import=dns.zone --hidden-import=dns.versioned --add-data \"json/errors.json;json/\" --noupx --log-level=INFO --debug all schedulerService.py\n</code></pre> <p>3.3. GUI del servicio:</p> <pre><code>pyinstaller.exe --noconsole --clean --version-file version_info.txt --onefile --hidden-import=eventlet.hubs.epolls --hidden-import=eventlet.hubs.kqueue --hidden-import=eventlet.hubs.selects --hidden-import=dns --hidden-import=dns.dnssec --hidden-import=dns.e164 --hidden-import=dns.hash --hidden-import=dns.namedict --hidden-import=dns.tsigkeyring --hidden-import=dns.update --hidden-import=dns.version --hidden-import=dns.zone --hidden-import=dns.versioned -n \"Servicio Reloj de Asistencias\" -i \"resources/24-7.png\" --add-data \"resources/system_tray/*;resources/system_tray\" --add-data \"resources/24-7.png;resources/\" --add-data \"json/errors.json;json/\" --noupx --log-level=INFO --uac-admin --debug all main.py\n</code></pre>"},{"location":"#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Configuraci\u00f3n flexible mediante <code>config.ini</code>, <code>schedule.txt</code> e <code>info_devices.txt</code>.  </li> <li>Logs detallados en <code>logs/</code> y backups en <code>%ProgramData%/</code>.  </li> <li>Interfaz de bandeja de sistema con men\u00fa contextual.</li> </ul>"},{"location":"#estructura-del-proyecto","title":"Estructura del proyecto","text":"<pre><code>.\n\u251c\u2500\u2500\u2500docs        # MkDocs (USAGE.md, gu\u00edas, referencias)\n\u251c\u2500\u2500\u2500json        # Persistencia de datos\n\u251c\u2500\u2500\u2500resources   # Iconos y assets UI\n\u2514\u2500\u2500\u2500src         # C\u00f3digo fuente (business_logic, common, ui)\n</code></pre>"},{"location":"#enlaces-utiles","title":"Enlaces \u00fatiles","text":"<ul> <li>Gu\u00eda de Uso completa </li> <li>Configuraci\u00f3n (<code>config.ini</code>) </li> <li>Estructura detallada de carpetas y logs</li> </ul>"},{"location":"USAGE/","title":"Gu\u00eda de Uso de PyZKTecoClocks","text":"<p>\u26a0\ufe0f Nota / Note: Esta p\u00e1gina est\u00e1 disponible solo en Espa\u00f1ol temporalmente. This page is currently available in Spanish only.</p>"},{"location":"USAGE/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ol> <li>Introducci\u00f3n</li> <li>Interfaz de usuario</li> <li>Programa Reloj de Asistencias</li> <li>Acciones principales<ul> <li>Lista de acciones</li> <li>Modificar dispositivos</li> <li>Reiniciar dispositivos</li> <li>Probar conexiones</li> <li>Actualizar hora</li> <li>Obtener marcaciones</li> </ul> </li> <li>Configuraci\u00f3n en acciones principales</li> <li>Acciones de configuraci\u00f3n del men\u00fa contextual</li> <li>Otras acciones</li> <li>Servicio Reloj de Asistencias</li> <li>Acciones principales del servicio</li> <li>Configuraci\u00f3n del servicio</li> <li>Comportamiento del servicio</li> <li>Carpetas generadas</li> <li>Archivos generados</li> <li>Por el usuario</li> <li>Por el programa y el servicio</li> <li>Logs</li> <li>Archivo de configuraci\u00f3n <code>config.ini</code></li> <li>Resumen de par\u00e1metros</li> <li>Attendance_status</li> <li>Cpu_config</li> <li>Device_config</li> <li>Program_config</li> <li>Network_config</li> </ol>"},{"location":"USAGE/#introduccion","title":"Introducci\u00f3n","text":"<p>Este documento describe c\u00f3mo utilizar las herramientas Programa Reloj de Asistencias y Servicio Reloj de Asistencias del proyecto PyZKTecoClocks. Aqu\u00ed encontrar\u00e1s:</p> <ul> <li>Descripci\u00f3n de las interfaces de usuario.</li> <li>Detalle de cada acci\u00f3n disponible.</li> <li>Explicaci\u00f3n de la configuraci\u00f3n y de los archivos generados.</li> <li>Estructura de las carpetas y logs.</li> </ul>"},{"location":"USAGE/#interfaz-de-usuario","title":"Interfaz de usuario","text":"<p>El proyecto cuenta con dos aplicaciones independientes, cada uno con su propia interfaz de bandeja. Al hacer clic derecho sobre el \u00edcono, se despliega un men\u00fa contextual con acciones propias del ejecutable.</p> <p>Ver apartados Programa Reloj de Asistencias y Servicio Reloj de Asistencias para m\u00e1s informaci\u00f3n.</p>"},{"location":"USAGE/#programa-reloj-de-asistencias","title":"Programa Reloj de Asistencias","text":"<p>Para usar el programa, ejecutar <code>Programa Reloj de Asistencias.exe</code>. Para ello, aseg\u00farese de tener en el directorio ra\u00edz donde se encuentran los ejecutables, los archivos <code>config.ini</code> (ver Archivo de configuraci\u00f3n) y <code>info_devices.txt</code> (ver Archivos generados por el usuario).</p>"},{"location":"USAGE/#acciones-principales","title":"Acciones principales","text":"<p>El men\u00fa contextual del programa ofrece cinco acciones principales que abren ventanas con tablas interactivas y controles de ejecuci\u00f3n.</p>"},{"location":"USAGE/#lista-de-acciones","title":"Lista de acciones","text":"Acci\u00f3n Descripci\u00f3n breve Modificar dispositivos Edita <code>info_devices.txt</code> desde una tabla interactiva. Reiniciar dispositivos Env\u00eda comando de reinicio y muestra progreso con barra y alertas. Probar conexiones Verifica conexi\u00f3n, marcaciones, serie, plataforma y firmware. Actualizar hora Sincroniza la hora de los dispositivos seleccionados. Obtener marcaciones Descarga registros y sincroniza hora, con gesti\u00f3n de errores. <p>Cada acci\u00f3n incluye Tiempo de Espera y Reintentos (ver Configuraci\u00f3n en acciones principales) y utiliza variables de <code>config.ini</code> (ver Archivo de configuraci\u00f3n). Adem\u00e1s, genera archivos de log mensuales en la carpeta <code>logs/</code> (ver Carpetas generadas).</p>"},{"location":"USAGE/#modificar-dispositivos","title":"Modificar dispositivos","text":"<p>Abre una ventana en la que permite modificar el archivo <code>info_devices.txt</code> a trav\u00e9s de una tabla que contiene los dispositivos configurados para las acciones de:</p> <ul> <li>Reiniciar dispositivos</li> <li>Probar conexiones</li> <li>Actualizar hora</li> <li>Obtener marcaciones</li> </ul> <p>La tabla es interactiva: al hacer doble clic sobre cualquier campo, se habilita la edici\u00f3n in situ, pero no se guardan los cambios en tiempo real en el archivo.</p> <p>Botones disponibles:</p> <ul> <li>Cargar: recarga desde <code>info_devices.txt</code> todos los dispositivos y actualiza la tabla.</li> <li>Modificar: guarda en <code>info_devices.txt</code> los cambios realizados en la tabla.</li> <li>Agregar: abre un formulario para incluir un nuevo dispositivo; solicita:<ul> <li>Distrito  </li> <li>Modelo  </li> <li>Punto de marcaci\u00f3n  </li> <li>IP  </li> <li>Tipo de comunicaci\u00f3n (TCP o UDP)</li> </ul> </li> <li>Activar todo: marca la casilla \"Activo\" para todos los dispositivos listados, de modo que aparezcan y est\u00e9n disponibles en las dem\u00e1s ventanas de acciones.</li> <li>Desactivar todo: desmarca la casilla \"Activo\" para todos los dispositivos listados, de modo que queden ocultos y no se incluyan en las dem\u00e1s acciones.</li> </ul>"},{"location":"USAGE/#reiniciar-dispositivos","title":"Reiniciar dispositivos","text":"<p>Abre una ventana con:</p> <ul> <li> <p>Inputs:</p> <ul> <li>Tiempo de Espera  </li> <li>Reintentos</li> </ul> <p>(Ver Configuraci\u00f3n en acciones principales).</p> </li> <li> <p>Tabla interactiva de dispositivos activos (selecci\u00f3n mediante clic izquierdo).</p> </li> <li>Botones disponibles:<ul> <li>Reiniciar dispositivos: env\u00eda el comando de reinicio a cada dispositivo seleccionado; se muestra:<ul> <li>Barra de progreso verde indicando avance.  </li> <li>Conteo \u201cdispositivos finalizados / total activos\u201d.</li> <li>Al finalizar, ventana emergente con listado de dispositivos cuya conexi\u00f3n fall\u00f3.</li> </ul> </li> <li>Seleccionar todo: marca todos los dispositivos para reinicio.  </li> <li>Deseleccionar todo: desmarca todos.</li> </ul> </li> </ul> <p>Esta acci\u00f3n utiliza las variables del <code>config.ini</code>:</p> <ul> <li><code>threads_pool_max_size</code> </li> <li><code>retry_connection</code> </li> <li><code>timeout</code></li> </ul> <p>(Ver Archivo de configuraci\u00f3n).</p>"},{"location":"USAGE/#probar-conexiones","title":"Probar conexiones","text":"<p>Abre una ventana con:</p> <ul> <li> <p>Inputs:</p> <ul> <li>Tiempo de Espera  </li> <li>Reintentos</li> </ul> <p>(Ver Configuraci\u00f3n en acciones principales).</p> </li> <li> <p>Tabla interactiva de dispositivos activos (selecci\u00f3n mediante clic izquierdo).</p> </li> <li>Botones disponibles:<ul> <li>Probar conexiones: env\u00eda comandos a cada dispositivo seleccionado; despliega:<ul> <li>Barra de progreso verde y conteo \u201cfinalizados / total\u201d.</li> <li>Al completar, la tabla a\u00f1ade las columnas:<ul> <li>Estado de Conexi\u00f3n: \"Conectado\" o \"Error\".  </li> <li>Cant. de Marcaciones: n\u00famero de registros (\"No aplica\" si 0).  </li> <li>N\u00famero de Serie </li> <li>Plataforma </li> <li>Firmware </li> </ul> </li> <li>Coloreado de celdas:<ul> <li>Verde si el valor fue obtenido correctamente.  </li> <li>Gris con leyenda \"No aplica\" si el campo no corresponde.  </li> <li>Rojo si hubo fallo de conexi\u00f3n o de obtenci\u00f3n.</li> </ul> </li> </ul> </li> <li>Seleccionar todo / Deseleccionar todo.</li> </ul> </li> </ul> <p>Esta acci\u00f3n utiliza las variables del <code>config.ini</code>:</p> <ul> <li><code>threads_pool_max_size</code> </li> <li><code>retry_connection</code> </li> <li><code>size_ping_test_connection</code> </li> <li><code>timeout</code></li> </ul> <p>(Ver Archivo de configuraci\u00f3n).</p>"},{"location":"USAGE/#actualizar-hora","title":"Actualizar hora","text":"<p>Abre una ventana con:</p> <ul> <li> <p>Inputs:</p> <ul> <li>Tiempo de Espera  </li> <li>Reintentos</li> </ul> <p>(Ver Configuraci\u00f3n en acciones principales).</p> </li> <li> <p>Tabla interactiva de dispositivos activos (selecci\u00f3n mediante clic izquierdo).</p> </li> <li> <p>Botones disponibles:</p> <ul> <li>Actualizar hora: env\u00eda comando a cada dispositivo seleccionado; muestra barra de progreso.</li> <li> <p>Seleccionar todo / Deseleccionar todo.</p> </li> <li> <p>Al finalizar, la tabla a\u00f1ade:</p> <ul> <li>Estado de Conexi\u00f3n: \"Conectado\" (verde) o \"Error\" (rojo).</li> <li>Estado de Pila: </li> <li>\"Pila funcionando\" (verde)  </li> <li>\"Pila fallando\" (rojo)  </li> <li>\"No aplica\" (gris) si hubo error de conexi\u00f3n.</li> </ul> </li> </ul> </li> </ul> <p>Esta acci\u00f3n utiliza las variables del <code>config.ini</code>:</p> <ul> <li><code>threads_pool_max_size</code> </li> <li><code>retry_connection</code> </li> <li><code>timeout</code></li> </ul> <p>(Ver Archivo de configuraci\u00f3n).</p>"},{"location":"USAGE/#obtener-marcaciones","title":"Obtener marcaciones","text":"<p>Abre una ventana con:</p> <ul> <li> <p>Inputs:</p> <ul> <li>Tiempo de Espera  </li> <li>Reintentos</li> </ul> <p>(Ver Configuraci\u00f3n en acciones principales).</p> </li> <li> <p>Tabla interactiva de dispositivos activos (selecci\u00f3n mediante clic izquierdo).</p> </li> <li>Botones disponibles:<ul> <li>Obtener marcaciones: env\u00eda comandos para descargar marcaciones, sincronizar la hora, actualizar el modelo en el nombre de las carpetas ubicadas en <code>devices/{distrito}/</code>; muestra barra de progreso con conteo.</li> <li>Seleccionar todo / Deseleccionar todo.</li> <li>Reintentar todos / Reintentar fallidos (aparecen si hubo fallos).</li> </ul> </li> </ul> <p>Al terminar, se agrega:</p> <ul> <li>Cant. de Marcaciones: n\u00famero de marcaciones descargadas (verde con cantidad) o \"Conexi\u00f3n fallida\" (rojo).</li> </ul> <p>Gesti\u00f3n de errores de formato:</p> <ul> <li>Dispositivos con registros fuera de rango (m\u00e1s de 3 meses antiguos o fechas futuras al d\u00eda de hoy) mostrar\u00e1n hiperv\u00ednculos a sus archivos.</li> <li>Si \"Eliminar marcaciones\" est\u00e1 activo, permite forzar eliminaci\u00f3n en pr\u00f3xima ejecuci\u00f3n; luego se deshabilita.</li> <li>Si no, solo listar\u00e1 enlaces a archivos afectados.</li> </ul> <p>Archivos de salida diarios: <code>devices/{distrito}/{modelo}-{punto_de_marcacion}/</code> y <code>%ProgramData%/.../Backup/devices/{distrito}/{modelo}-{punto_de_marcacion}/</code> (ver Carpetas generadas).</p>"},{"location":"USAGE/#configuracion-en-acciones-principales","title":"Configuraci\u00f3n en acciones principales","text":"<ul> <li>Tiempo de Espera: modifica <code>timeout</code> (segundos) en <code>config.ini</code>.</li> <li>Reintentos: modifica <code>retry_connection</code> (intentos) en <code>config.ini</code>.</li> </ul>"},{"location":"USAGE/#acciones-de-configuracion-del-menu-contextual","title":"Acciones de configuraci\u00f3n del men\u00fa contextual","text":"<ul> <li>Eliminar marcaciones: edita <code>clear_attendance</code> en <code>config.ini</code>.</li> <li>Iniciar autom\u00e1ticamente: registra programa en inicio del sistema.</li> </ul>"},{"location":"USAGE/#otras-acciones","title":"Otras acciones","text":"<ul> <li>Salir: cierra el programa.</li> </ul>"},{"location":"USAGE/#servicio-reloj-de-asistencias","title":"Servicio Reloj de Asistencias","text":"<p>El servicio se compone de 2 ejecutables: <code>schedulerService.exe</code> y <code>Servicio Reloj de Asistencias.exe</code>.</p> <ul> <li><code>schedulerService.exe</code> es el servicio autom\u00e1tico per se.</li> <li><code>Servicio Reloj de Asistencias.exe</code> es el gestor del servicio. Con \u00e9l, se pueden hacer las acciones tabuladas en la siguiente secci\u00f3n.</li> </ul> <p>Para usar el servicio, ejecutar <code>Servicio Reloj de Asistencias.exe</code>. Para ello, aseg\u00farese de tener en el directorio ra\u00edz donde se encuentran los ejecutables, los archivos <code>config.ini</code> (ver Archivo de configuraci\u00f3n), <code>info_devices.txt</code> y <code>schedule.txt</code> (ver Archivos generados por el usuario).</p>"},{"location":"USAGE/#acciones-principales-del-servicio","title":"Acciones principales del servicio","text":"Acci\u00f3n Descripci\u00f3n Iniciar servicio Arranca el servicio manualmente. Detener servicio Detiene la ejecuci\u00f3n del servicio. Reiniciar servicio Detiene y vuelve a iniciar el servicio. Reinstalar servicio Reinstala el servicio en el sistema. Desinstalar servicio Elimina el servicio del sistema."},{"location":"USAGE/#configuracion-del-servicio","title":"Configuraci\u00f3n del servicio","text":"<ul> <li>Eliminar marcaciones: edita <code>clear_attendance_service</code> en <code>config.ini</code>.</li> <li>Iniciar autom\u00e1ticamente: registra servicio en inicio del sistema.</li> </ul>"},{"location":"USAGE/#comportamiento-del-servicio","title":"Comportamiento del servicio","text":"<ul> <li>Arranca autom\u00e1ticamente al ejecutar el ejecutable.</li> <li>Permanece activo tras cerrar la app, siguiendo <code>schedule.txt</code>.</li> <li>Usa dispositivos activos en <code>info_devices.txt</code>.</li> <li>No elimina marcaciones err\u00f3neas; el programa las procesa en la pr\u00f3xima ejecuci\u00f3n de \u201cObtener marcaciones\u201d.</li> </ul>"},{"location":"USAGE/#carpetas-generadas","title":"Carpetas generadas","text":"Ruta Descripci\u00f3n <code>devices/{distrito}/{modelo}-{punto_de_marcacion}/</code> Marcaciones organizadas por distrito y modelo / punto de marcaci\u00f3n. <code>logs/{a\u00f1o-mes}/</code> Logs mensuales de programa y servicio. <code>%ProgramData%/.../Backup/devices/{distrito}/{modelo}</code> Copia de seguridad de archivos de asistencia."},{"location":"USAGE/#archivos-generados","title":"Archivos generados","text":""},{"location":"USAGE/#por-el-usuario","title":"Por el usuario","text":"<ul> <li>schedule.txt: define horarios de tareas (no modificar t\u00edtulos).</li> </ul> <p><code># Hours for gestionar_marcaciones_dispositivos     ...   # Hours for actualizar_hora_dispositivos     ...</code></p> <ul> <li>info_devices.txt: lista de dispositivos:</li> </ul> <p><code>DISTRITO - MODELO - PUNTO - IP - ID - TCP/UDP - Activado (True/False)</code></p>"},{"location":"USAGE/#por-el-programa-y-el-servicio","title":"Por el programa y el servicio","text":"<ul> <li><code>{name_attendances_file}.txt</code>: archivo global de marcaciones.</li> <li><code>ip_date_file.cro</code>: registros por dispositivo y fecha en <code>devices/{distrito}/{modelo}-{punto_de_marcacion}/</code>.</li> </ul>"},{"location":"USAGE/#logs","title":"Logs","text":"<ul> <li>programa_reloj_de_asistencias_{VERSION}_debug.log: mensajes de depuraci\u00f3n e info.</li> <li>programa_reloj_de_asistencias_{VERSION}_error.log: advertencias y errores.</li> <li>console_log.txt: logs de consola.</li> <li>servicio_reloj_de_asistencias_{VERSION}_debug.txt y _error.txt: logs del servicio.</li> <li>icono_reloj_de_asistencias_{VERSION}_{tipo}.txt: logs del icono del servicio.</li> </ul>"},{"location":"USAGE/#archivo-de-configuracion-configini","title":"Archivo de configuraci\u00f3n <code>config.ini</code>","text":""},{"location":"USAGE/#resumen-de-parametros","title":"Resumen de par\u00e1metros","text":"Secci\u00f3n Par\u00e1metro Tipo Descripci\u00f3n Attendance_status IDs de tipo de marcaci\u00f3n Entero Relaciona ID con tipo de marcaci\u00f3n (face, fingerprint, card). Cpu_config threads_pool_max_size Entero M\u00e1ximo de conexiones paralelas en acciones de red. Device_config clear_attendance Booleano Elimina marcaciones en ejecuci\u00f3n manual. clear_attendance_service Booleano Elimina marcaciones en servicio programado. disable_device Booleano Bloqueo del dispositivo al acceder (no recomendado). Program_config name_attendances_file Cadena Nombre del archivo global de marcaciones. Network_config retry_connection Entero Cantidad de reintentos en operaciones de red. size_ping_test_connection Entero Paquetes enviados en test de conexi\u00f3n. timeout Entero Segundos antes de considerar ca\u00edda de conexi\u00f3n."},{"location":"USAGE/#attendance_status","title":"Attendance_status","text":"<p>Asocia IDs con tipos de marcaci\u00f3n.</p> <p>Ejemplo en <code>config.ini</code>:</p> <pre><code>[Attendance_status]\nstatus_face = 2\nstatus_fingerprint = 1\nstatus_card = 3\n</code></pre>"},{"location":"USAGE/#cpu_config","title":"Cpu_config","text":"<ul> <li><code>threads_pool_max_size</code>: conexiones paralelas.</li> </ul> <p>Ejemplo en <code>config.ini</code>:</p> <pre><code>[Cpu_config]\nthreads_pool_max_size = 50\n</code></pre>"},{"location":"USAGE/#device_config","title":"Device_config","text":"<ul> <li><code>clear_attendance</code>: elimina marcaciones manuales.</li> <li><code>clear_attendance_service</code>: elimina marcaciones en el servicio.</li> <li><code>disable_device</code>: bloquea dispositivo al acceder (no recomendado).</li> </ul> <p>Ejemplo en <code>config.ini</code>:</p> <pre><code>[Device_config]\nclear_attendance = False\nforce_clear_attendance = False\nclear_attendance_service = False\ndisable_device = False\n</code></pre>"},{"location":"USAGE/#program_config","title":"Program_config","text":"<ul> <li><code>name_attendances_file</code>: nombre del archivo global de marcaciones.</li> </ul> <p>Ejemplo en <code>config.ini</code>:</p> <pre><code>[Program_config]\nname_attendances_file = attendances_file\n</code></pre>"},{"location":"USAGE/#network_config","title":"Network_config","text":"<ul> <li><code>retry_connection</code>: reintentos en operaciones de red.</li> <li><code>size_ping_test_connection</code>: paquetes en test de conexi\u00f3n.</li> <li><code>timeout</code>: segundos de espera.</li> </ul> <p>Ejemplo en <code>config.ini</code>:</p> <pre><code>[Network_config]\nretry_connection = 3\nsize_ping_test_connection = 5\ntimeout = 15\n</code></pre> <p>Fin de la documentaci\u00f3n.</p>"},{"location":"api/","title":"Referencia de la API","text":"<p>\u26a0\ufe0f Nota / Note: Esta p\u00e1gina est\u00e1 disponible solo en Ingl\u00e9s temporalmente. This page is currently available in English only.</p> <p>Proyecto compatible con Eventlet y GEvent.</p>"},{"location":"api/#src.business_logic","title":"<code>business_logic</code>","text":""},{"location":"api/#src.business_logic.program_manager","title":"<code>program_manager</code>","text":""},{"location":"api/#src.business_logic.program_manager.AttendancesManager","title":"<code>AttendancesManager</code>","text":"<p>               Bases: <code>AttendancesManagerBase</code></p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>class AttendancesManager(AttendancesManagerBase):\n    def __init__(self):\n        \"\"\"\n        Initializes the ProgramManager instance.\n\n        This constructor sets up the initial state of the ProgramManager by\n        creating a new instance of SharedState and passing it to the parent\n        class initializer.\n\n        Attributes:\n            state (SharedState): The shared state object used to manage\n            program-wide data and operations.\n        \"\"\"\n        self.state = SharedState()\n        super().__init__(self.state)\n\n    def manage_devices_attendances(self, selected_ips: list[str], emit_progress: Callable = None):\n        \"\"\"\n        Manages the attendance records for the specified devices.\n        This method processes attendance data for the devices with the given IPs.\n        It also handles configuration settings related to clearing attendance data\n        and updates the configuration file if necessary.\n\n        Args:\n            selected_ips (list[str]): A list of IP addresses of the devices to manage.\n            emit_progress (Callable, optional): A callable function to emit progress updates. Defaults to None.\n\n        Returns:\n            (int): The count of attendances processed.\n\n        Side Effects:\n            - Reads configuration settings from 'config.ini'.\n            - Resets the internal state before processing.\n            - Updates the 'force_clear_attendance' setting in 'config.ini' if it was set to True.\n        \"\"\"\n        self.emit_progress: Callable = emit_progress\n        config.read(os.path.join(find_root_directory(), 'config.ini'))\n        self.clear_attendance: bool = config.getboolean('Device_config', 'clear_attendance')\n        self.force_clear_attendance: bool = config.getboolean('Device_config', 'force_clear_attendance')\n        logging.debug(f'force_clear_attendance: {self.force_clear_attendance}')\n        self.state.reset()\n        attendances_count = super().manage_devices_attendances(selected_ips)\n        if self.force_clear_attendance:\n            self.force_clear_attendance = False\n            config['Device_config']['force_clear_attendance'] = 'False'\n\n            with open('config.ini', 'w') as configfile:\n                config.write(configfile)\n        return attendances_count\n\n    def manage_attendances_of_one_device(self, device: Device):\n        \"\"\"\n        Manages the attendance data for a single device.\n        This method handles the connection to a device, retrieves attendance data, processes it,\n        and updates the device's state and attendance records. It also manages error handling\n        and ensures proper cleanup of resources.\n\n        Args:\n            device (Device): The device object representing the attendance device to be managed.\n\n        Workflow:\n            1. Establishes a connection to the device using `ConnectionManager`.\n            2. Retrieves attendance data from the device.\n            3. Formats the attendance data and handles any errors during formatting.\n            4. Clears attendance data on the device based on the `clear_attendance` flag.\n            5. Updates the device's model name if possible.\n            6. Processes individual and global attendance records.\n            7. Synchronizes the device's time and handles time-related errors.\n            8. Updates the attendance count for the device in a shared dictionary.\n            9. Ensures proper disconnection from the device and updates progress tracking.\n\n        Exceptions:\n            - Handles `NetworkError` and `ObtainAttendancesError` during connection and data retrieval.\n            - Raises `ConnectionFailedError` if the connection to the device fails.\n            - Catches and re-raises other exceptions as `BaseError` with a specific error code.\n            - Handles time synchronization errors such as `OutdatedTimeError` and updates the battery status.\n\n        Logging:\n            - Logs debug information for connection initiation, attendance processing, and cleanup.\n            - Logs errors and warnings for failed connections and other issues.\n\n        Returns:\n            None\n        \"\"\"\n        logging.debug(f\"Iniciando {device.ip}\")\n        try:\n            try:\n                conn_manager = ConnectionManager(device.ip, 4370, device.communication)\n                #import time\n                #start_time = time.time()\n                conn_manager.connect_with_retry()\n                #end_time = time.time()\n                #logging.debug(f'{device.ip} - Tiempo de conexi\u00f3n total: {(end_time - start_time):2f}')\n                attendances: list[Attendance] = conn_manager.get_attendances()\n                #logging.info(f'{device.ip} - PREFORMATEO - Longitud marcaciones: {len(attendances)} - Marcaciones: {attendances}')\n                attendances, attendances_with_error = self.format_attendances(attendances, device.id)\n                if len(attendances_with_error) &gt; 0:\n                    if not self.force_clear_attendance:\n                        self.clear_attendance = False\n                        logging.debug(f'No se eliminaran las marcaciones correspondientes al dispositivo {device.ip}')\n                #logging.info(f'{device.ip} - POSTFORMATEO - Longitud marcaciones: {len(attendances)} - Marcaciones: {attendances}')\n                logging.debug(f'clear_attendance: {self.clear_attendance}')\n                conn_manager.clear_attendances(self.clear_attendance)\n            except (NetworkError, ObtainAttendancesError) as e:\n                with self.lock:\n                    self.attendances_count_devices[device.ip] = {\n                        \"connection failed\": True\n                    }\n                raise ConnectionFailedError(device.model_name, device.point, device.ip)\n            except Exception as e:\n                raise BaseError(3000, str(e)) from e\n\n            try:\n                device.model_name = conn_manager.update_device_name()\n            except Exception as e:\n                pass\n\n            self.manage_individual_attendances(device, attendances)\n            self.manage_global_attendances(attendances)\n\n            try:\n                conn_manager.update_time()\n            except NetworkError as e:\n                NetworkError(f'{device.model_name}, {device.point}, {device.ip}')\n            except OutdatedTimeError as e:\n                HourManager().update_battery_status(device.ip)\n                BatteryFailingError(device.model_name, device.point, device.ip)\n\n            with self.lock:\n                self.attendances_count_devices[device.ip] = {\n                    \"attendance count\": str(len(attendances))\n                }\n        except Exception as e:\n            pass\n        finally:\n            if conn_manager.is_connected():\n                conn_manager.disconnect()\n            ProgressTracker(self.state, self.emit_progress).update(device)\n            logging.debug(f\"Finalizando {device.ip}\")\n        return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.AttendancesManager.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ProgramManager instance.</p> <p>This constructor sets up the initial state of the ProgramManager by creating a new instance of SharedState and passing it to the parent class initializer.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>SharedState</code> <p>The shared state object used to manage</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the ProgramManager instance.\n\n    This constructor sets up the initial state of the ProgramManager by\n    creating a new instance of SharedState and passing it to the parent\n    class initializer.\n\n    Attributes:\n        state (SharedState): The shared state object used to manage\n        program-wide data and operations.\n    \"\"\"\n    self.state = SharedState()\n    super().__init__(self.state)\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.AttendancesManager.manage_attendances_of_one_device","title":"<code>manage_attendances_of_one_device(device)</code>","text":"<p>Manages the attendance data for a single device. This method handles the connection to a device, retrieves attendance data, processes it, and updates the device's state and attendance records. It also manages error handling and ensures proper cleanup of resources.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device object representing the attendance device to be managed.</p> required Workflow <ol> <li>Establishes a connection to the device using <code>ConnectionManager</code>.</li> <li>Retrieves attendance data from the device.</li> <li>Formats the attendance data and handles any errors during formatting.</li> <li>Clears attendance data on the device based on the <code>clear_attendance</code> flag.</li> <li>Updates the device's model name if possible.</li> <li>Processes individual and global attendance records.</li> <li>Synchronizes the device's time and handles time-related errors.</li> <li>Updates the attendance count for the device in a shared dictionary.</li> <li>Ensures proper disconnection from the device and updates progress tracking.</li> </ol> Logging <ul> <li>Logs debug information for connection initiation, attendance processing, and cleanup.</li> <li>Logs errors and warnings for failed connections and other issues.</li> </ul> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def manage_attendances_of_one_device(self, device: Device):\n    \"\"\"\n    Manages the attendance data for a single device.\n    This method handles the connection to a device, retrieves attendance data, processes it,\n    and updates the device's state and attendance records. It also manages error handling\n    and ensures proper cleanup of resources.\n\n    Args:\n        device (Device): The device object representing the attendance device to be managed.\n\n    Workflow:\n        1. Establishes a connection to the device using `ConnectionManager`.\n        2. Retrieves attendance data from the device.\n        3. Formats the attendance data and handles any errors during formatting.\n        4. Clears attendance data on the device based on the `clear_attendance` flag.\n        5. Updates the device's model name if possible.\n        6. Processes individual and global attendance records.\n        7. Synchronizes the device's time and handles time-related errors.\n        8. Updates the attendance count for the device in a shared dictionary.\n        9. Ensures proper disconnection from the device and updates progress tracking.\n\n    Exceptions:\n        - Handles `NetworkError` and `ObtainAttendancesError` during connection and data retrieval.\n        - Raises `ConnectionFailedError` if the connection to the device fails.\n        - Catches and re-raises other exceptions as `BaseError` with a specific error code.\n        - Handles time synchronization errors such as `OutdatedTimeError` and updates the battery status.\n\n    Logging:\n        - Logs debug information for connection initiation, attendance processing, and cleanup.\n        - Logs errors and warnings for failed connections and other issues.\n\n    Returns:\n        None\n    \"\"\"\n    logging.debug(f\"Iniciando {device.ip}\")\n    try:\n        try:\n            conn_manager = ConnectionManager(device.ip, 4370, device.communication)\n            #import time\n            #start_time = time.time()\n            conn_manager.connect_with_retry()\n            #end_time = time.time()\n            #logging.debug(f'{device.ip} - Tiempo de conexi\u00f3n total: {(end_time - start_time):2f}')\n            attendances: list[Attendance] = conn_manager.get_attendances()\n            #logging.info(f'{device.ip} - PREFORMATEO - Longitud marcaciones: {len(attendances)} - Marcaciones: {attendances}')\n            attendances, attendances_with_error = self.format_attendances(attendances, device.id)\n            if len(attendances_with_error) &gt; 0:\n                if not self.force_clear_attendance:\n                    self.clear_attendance = False\n                    logging.debug(f'No se eliminaran las marcaciones correspondientes al dispositivo {device.ip}')\n            #logging.info(f'{device.ip} - POSTFORMATEO - Longitud marcaciones: {len(attendances)} - Marcaciones: {attendances}')\n            logging.debug(f'clear_attendance: {self.clear_attendance}')\n            conn_manager.clear_attendances(self.clear_attendance)\n        except (NetworkError, ObtainAttendancesError) as e:\n            with self.lock:\n                self.attendances_count_devices[device.ip] = {\n                    \"connection failed\": True\n                }\n            raise ConnectionFailedError(device.model_name, device.point, device.ip)\n        except Exception as e:\n            raise BaseError(3000, str(e)) from e\n\n        try:\n            device.model_name = conn_manager.update_device_name()\n        except Exception as e:\n            pass\n\n        self.manage_individual_attendances(device, attendances)\n        self.manage_global_attendances(attendances)\n\n        try:\n            conn_manager.update_time()\n        except NetworkError as e:\n            NetworkError(f'{device.model_name}, {device.point}, {device.ip}')\n        except OutdatedTimeError as e:\n            HourManager().update_battery_status(device.ip)\n            BatteryFailingError(device.model_name, device.point, device.ip)\n\n        with self.lock:\n            self.attendances_count_devices[device.ip] = {\n                \"attendance count\": str(len(attendances))\n            }\n    except Exception as e:\n        pass\n    finally:\n        if conn_manager.is_connected():\n            conn_manager.disconnect()\n        ProgressTracker(self.state, self.emit_progress).update(device)\n        logging.debug(f\"Finalizando {device.ip}\")\n    return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.AttendancesManager.manage_devices_attendances","title":"<code>manage_devices_attendances(selected_ips, emit_progress=None)</code>","text":"<p>Manages the attendance records for the specified devices. This method processes attendance data for the devices with the given IPs. It also handles configuration settings related to clearing attendance data and updates the configuration file if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>selected_ips</code> <code>list[str]</code> <p>A list of IP addresses of the devices to manage.</p> required <code>emit_progress</code> <code>Callable</code> <p>A callable function to emit progress updates. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The count of attendances processed.</p> Side Effects <ul> <li>Reads configuration settings from 'config.ini'.</li> <li>Resets the internal state before processing.</li> <li>Updates the 'force_clear_attendance' setting in 'config.ini' if it was set to True.</li> </ul> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def manage_devices_attendances(self, selected_ips: list[str], emit_progress: Callable = None):\n    \"\"\"\n    Manages the attendance records for the specified devices.\n    This method processes attendance data for the devices with the given IPs.\n    It also handles configuration settings related to clearing attendance data\n    and updates the configuration file if necessary.\n\n    Args:\n        selected_ips (list[str]): A list of IP addresses of the devices to manage.\n        emit_progress (Callable, optional): A callable function to emit progress updates. Defaults to None.\n\n    Returns:\n        (int): The count of attendances processed.\n\n    Side Effects:\n        - Reads configuration settings from 'config.ini'.\n        - Resets the internal state before processing.\n        - Updates the 'force_clear_attendance' setting in 'config.ini' if it was set to True.\n    \"\"\"\n    self.emit_progress: Callable = emit_progress\n    config.read(os.path.join(find_root_directory(), 'config.ini'))\n    self.clear_attendance: bool = config.getboolean('Device_config', 'clear_attendance')\n    self.force_clear_attendance: bool = config.getboolean('Device_config', 'force_clear_attendance')\n    logging.debug(f'force_clear_attendance: {self.force_clear_attendance}')\n    self.state.reset()\n    attendances_count = super().manage_devices_attendances(selected_ips)\n    if self.force_clear_attendance:\n        self.force_clear_attendance = False\n        config['Device_config']['force_clear_attendance'] = 'False'\n\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n    return attendances_count\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ConnectionsInfo","title":"<code>ConnectionsInfo</code>","text":"<p>               Bases: <code>OperationManager</code></p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>class ConnectionsInfo(OperationManager):\n    def __init__(self):\n        \"\"\"\n        Initializes the ProgramManager instance.\n\n        This constructor sets up the shared state and initializes a dictionary\n        to store connection information. It also calls the superclass initializer\n        with the shared state.\n\n        Attributes:\n            state (SharedState): An instance of SharedState to manage shared resources.\n            connections_info (dict[str, ConnectionInfo]): A dictionary mapping connection\n                identifiers to their respective ConnectionInfo objects.\n        \"\"\"\n        self.state = SharedState()\n        self.connections_info: dict[str, ConnectionInfo] = {}\n        super().__init__(self.state)\n\n    def obtain_connections_info(self, selected_ips: list[str], emit_progress: Callable = None):\n        \"\"\"\n        Obtains connection information for a list of selected IPs and manages the threading process \n        to retrieve this information from devices.\n\n        Args:\n            selected_ips (list[str]): A list of IP addresses to connect to and retrieve information from.\n            emit_progress (Callable, optional): A callable function to emit progress updates during \n                the operation. Defaults to None.\n\n        Returns:\n            (dict): A dictionary containing connection information for the devices if any connections \n                    were successfully established. Returns an empty dictionary if no connections were made.\n        \"\"\"\n        self.connections_info.clear()\n        self.emit_progress: Callable = emit_progress\n        self.state.reset()\n\n        super().manage_threads_to_devices(selected_ips=selected_ips, function=self.obtain_connection_info)\n\n        if len(self.connections_info) &gt; 0:\n            return self.connections_info\n\n    def obtain_connection_info(self, device: Device):\n        \"\"\"\n        Establishes a connection to a device, retrieves its connection information, \n        and updates the connection status.\n\n        Args:\n            device (Device): The device object containing information such as IP, \n                             communication type, and model name.\n\n        Raises:\n            ConnectionFailedError: If the connection to the device fails due to a \n                                   network error.\n            BaseError: If any other unexpected exception occurs during the process.\n\n        Workflow:\n            1. Initializes a connection manager for the device using its IP and \n               communication type.\n            2. Attempts to connect to the device with retries.\n            3. Pings the device to verify connectivity.\n            4. If the ping is successful, retrieves device information and updates \n               the connection info.\n            5. If the ping fails or a network error occurs, marks the connection \n               as failed and raises a ConnectionFailedError.\n            6. Updates the shared connection information dictionary with the \n               device's connection status.\n            7. Ensures the connection is properly disconnected in the `finally` block.\n            8. Updates the progress tracker and logs the completion of the process.\n\n        Note:\n            This method uses a lock to ensure thread-safe updates to the shared \n            `connections_info` dictionary.\n        \"\"\"\n        try:\n            try:\n                logging.debug(f\"Iniciando {device.ip}\")\n                conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n                connection_info: ConnectionInfo = ConnectionInfo()\n                conn_manager.connect_with_retry()\n                test_ping_connection: bool = conn_manager.ping_device()\n                if test_ping_connection:\n                    device_info: DeviceInfo = conn_manager.obtain_device_info()\n                    connection_info.update({\n                        \"connection_failed\": False,\n                        \"device_info\": device_info\n                    })\n                else:\n                    connection_info.update({\n                        \"connection_failed\": True,\n                    })\n                with self.lock:\n                    self.connections_info[device.ip] = connection_info\n            except NetworkError as e:\n                connection_info.update({\n                    \"connection_failed\": True\n                })\n                with self.lock:\n                    self.connections_info[device.ip] = connection_info\n                raise ConnectionFailedError(device.model_name, device.point, device.ip)\n        except ConnectionFailedError:\n            pass\n        except Exception as e:\n            BaseError(3000, str(e))\n        finally:\n            if conn_manager.is_connected():\n                conn_manager.disconnect()\n            ProgressTracker(self.state, self.emit_progress).update(device)\n            logging.debug(f\"Finalizando {device.ip}\")\n        return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ConnectionsInfo.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ProgramManager instance.</p> <p>This constructor sets up the shared state and initializes a dictionary to store connection information. It also calls the superclass initializer with the shared state.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>SharedState</code> <p>An instance of SharedState to manage shared resources.</p> <code>connections_info</code> <code>dict[str, ConnectionInfo]</code> <p>A dictionary mapping connection identifiers to their respective ConnectionInfo objects.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the ProgramManager instance.\n\n    This constructor sets up the shared state and initializes a dictionary\n    to store connection information. It also calls the superclass initializer\n    with the shared state.\n\n    Attributes:\n        state (SharedState): An instance of SharedState to manage shared resources.\n        connections_info (dict[str, ConnectionInfo]): A dictionary mapping connection\n            identifiers to their respective ConnectionInfo objects.\n    \"\"\"\n    self.state = SharedState()\n    self.connections_info: dict[str, ConnectionInfo] = {}\n    super().__init__(self.state)\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ConnectionsInfo.obtain_connection_info","title":"<code>obtain_connection_info(device)</code>","text":"<p>Establishes a connection to a device, retrieves its connection information,  and updates the connection status.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device object containing information such as IP,               communication type, and model name.</p> required <p>Raises:</p> Type Description <code>ConnectionFailedError</code> <p>If the connection to the device fails due to a                     network error.</p> <code>BaseError</code> <p>If any other unexpected exception occurs during the process.</p> Workflow <ol> <li>Initializes a connection manager for the device using its IP and     communication type.</li> <li>Attempts to connect to the device with retries.</li> <li>Pings the device to verify connectivity.</li> <li>If the ping is successful, retrieves device information and updates     the connection info.</li> <li>If the ping fails or a network error occurs, marks the connection     as failed and raises a ConnectionFailedError.</li> <li>Updates the shared connection information dictionary with the     device's connection status.</li> <li>Ensures the connection is properly disconnected in the <code>finally</code> block.</li> <li>Updates the progress tracker and logs the completion of the process.</li> </ol> Note <p>This method uses a lock to ensure thread-safe updates to the shared  <code>connections_info</code> dictionary.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def obtain_connection_info(self, device: Device):\n    \"\"\"\n    Establishes a connection to a device, retrieves its connection information, \n    and updates the connection status.\n\n    Args:\n        device (Device): The device object containing information such as IP, \n                         communication type, and model name.\n\n    Raises:\n        ConnectionFailedError: If the connection to the device fails due to a \n                               network error.\n        BaseError: If any other unexpected exception occurs during the process.\n\n    Workflow:\n        1. Initializes a connection manager for the device using its IP and \n           communication type.\n        2. Attempts to connect to the device with retries.\n        3. Pings the device to verify connectivity.\n        4. If the ping is successful, retrieves device information and updates \n           the connection info.\n        5. If the ping fails or a network error occurs, marks the connection \n           as failed and raises a ConnectionFailedError.\n        6. Updates the shared connection information dictionary with the \n           device's connection status.\n        7. Ensures the connection is properly disconnected in the `finally` block.\n        8. Updates the progress tracker and logs the completion of the process.\n\n    Note:\n        This method uses a lock to ensure thread-safe updates to the shared \n        `connections_info` dictionary.\n    \"\"\"\n    try:\n        try:\n            logging.debug(f\"Iniciando {device.ip}\")\n            conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n            connection_info: ConnectionInfo = ConnectionInfo()\n            conn_manager.connect_with_retry()\n            test_ping_connection: bool = conn_manager.ping_device()\n            if test_ping_connection:\n                device_info: DeviceInfo = conn_manager.obtain_device_info()\n                connection_info.update({\n                    \"connection_failed\": False,\n                    \"device_info\": device_info\n                })\n            else:\n                connection_info.update({\n                    \"connection_failed\": True,\n                })\n            with self.lock:\n                self.connections_info[device.ip] = connection_info\n        except NetworkError as e:\n            connection_info.update({\n                \"connection_failed\": True\n            })\n            with self.lock:\n                self.connections_info[device.ip] = connection_info\n            raise ConnectionFailedError(device.model_name, device.point, device.ip)\n    except ConnectionFailedError:\n        pass\n    except Exception as e:\n        BaseError(3000, str(e))\n    finally:\n        if conn_manager.is_connected():\n            conn_manager.disconnect()\n        ProgressTracker(self.state, self.emit_progress).update(device)\n        logging.debug(f\"Finalizando {device.ip}\")\n    return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ConnectionsInfo.obtain_connections_info","title":"<code>obtain_connections_info(selected_ips, emit_progress=None)</code>","text":"<p>Obtains connection information for a list of selected IPs and manages the threading process  to retrieve this information from devices.</p> <p>Parameters:</p> Name Type Description Default <code>selected_ips</code> <code>list[str]</code> <p>A list of IP addresses to connect to and retrieve information from.</p> required <code>emit_progress</code> <code>Callable</code> <p>A callable function to emit progress updates during  the operation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing connection information for the devices if any connections      were successfully established. Returns an empty dictionary if no connections were made.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def obtain_connections_info(self, selected_ips: list[str], emit_progress: Callable = None):\n    \"\"\"\n    Obtains connection information for a list of selected IPs and manages the threading process \n    to retrieve this information from devices.\n\n    Args:\n        selected_ips (list[str]): A list of IP addresses to connect to and retrieve information from.\n        emit_progress (Callable, optional): A callable function to emit progress updates during \n            the operation. Defaults to None.\n\n    Returns:\n        (dict): A dictionary containing connection information for the devices if any connections \n                were successfully established. Returns an empty dictionary if no connections were made.\n    \"\"\"\n    self.connections_info.clear()\n    self.emit_progress: Callable = emit_progress\n    self.state.reset()\n\n    super().manage_threads_to_devices(selected_ips=selected_ips, function=self.obtain_connection_info)\n\n    if len(self.connections_info) &gt; 0:\n        return self.connections_info\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.HourManager","title":"<code>HourManager</code>","text":"<p>               Bases: <code>HourManagerBase</code></p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>class HourManager(HourManagerBase):\n    def __init__(self):\n        \"\"\"\n        Initializes the ProgramManager instance.\n\n        This constructor sets up the initial state of the ProgramManager by\n        creating a new instance of SharedState and passing it to the parent\n        class initializer.\n\n        Attributes:\n            state (SharedState): The shared state object used to manage\n            program-wide state and data.\n        \"\"\"\n        self.state = SharedState()\n        super().__init__(self.state)\n\n    def manage_hour_devices(self, selected_ips: list[str], emit_progress: Callable = None):\n        \"\"\"\n        Synchronizes the time on a list of devices identified by their IP addresses.\n\n        Args:\n            selected_ips (list[str]): A list of IP addresses of the devices to update.\n            emit_progress (Callable, optional): A callback function to emit progress updates. Defaults to None.\n\n        Returns:\n            (Any): The result of the `update_devices_time` method from the superclass.\n        \"\"\"\n        self.emit_progress: Callable = emit_progress\n        self.state.reset()\n        return super().update_devices_time(selected_ips)\n\n    def update_device_time_of_one_device(self, device: Device):\n        \"\"\"\n        Updates the device time for a single device.\n\n        This method attempts to connect to the specified device, update its time, \n        and handle any errors that may occur during the process. It also updates \n        the device's error status and progress tracking.\n\n        Args:\n            device (Device): The device object containing information such as \n                             IP address, communication type, model name, and point.\n\n        Raises:\n            ConnectionFailedError: If the connection to the device fails.\n            BatteryFailingError: If the device's battery is failing and its time \n                                 cannot be updated.\n            BaseError: For any other unexpected errors, with error code 3000.\n\n        Notes:\n            - Uses a lock to ensure thread-safe updates to the `devices_errors` dictionary.\n            - Updates the battery status if an outdated time error occurs.\n            - Ensures the connection is properly closed in the `finally` block.\n            - Tracks progress using the `ProgressTracker` class.\n        \"\"\"\n        logging.debug(f\"Iniciando {device.ip}\")\n        try:\n            try:\n                conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n                conn_manager.connect_with_retry()\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"connection failed\": False }\n                conn_manager.update_time()\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"battery failing\": False }\n            except NetworkError as e:\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"connection failed\": True }\n                raise ConnectionFailedError(device.model_name, device.point, device.ip)\n            except OutdatedTimeError as e:\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"battery failing\": True }\n                HourManager().update_battery_status(device.ip)\n                raise BatteryFailingError(device.model_name, device.point, device.ip)\n        except ConnectionFailedError as e:\n            pass\n        except BatteryFailingError as e:\n            pass\n        except Exception as e:\n            BaseError(3000, str(e))\n        finally:\n            if conn_manager.is_connected():\n                conn_manager.disconnect()\n            ProgressTracker(self.state, self.emit_progress).update(device)\n            logging.debug(f\"Finalizando {device.ip}\")\n        return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.HourManager.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ProgramManager instance.</p> <p>This constructor sets up the initial state of the ProgramManager by creating a new instance of SharedState and passing it to the parent class initializer.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>SharedState</code> <p>The shared state object used to manage</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the ProgramManager instance.\n\n    This constructor sets up the initial state of the ProgramManager by\n    creating a new instance of SharedState and passing it to the parent\n    class initializer.\n\n    Attributes:\n        state (SharedState): The shared state object used to manage\n        program-wide state and data.\n    \"\"\"\n    self.state = SharedState()\n    super().__init__(self.state)\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.HourManager.manage_hour_devices","title":"<code>manage_hour_devices(selected_ips, emit_progress=None)</code>","text":"<p>Synchronizes the time on a list of devices identified by their IP addresses.</p> <p>Parameters:</p> Name Type Description Default <code>selected_ips</code> <code>list[str]</code> <p>A list of IP addresses of the devices to update.</p> required <code>emit_progress</code> <code>Callable</code> <p>A callback function to emit progress updates. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the <code>update_devices_time</code> method from the superclass.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def manage_hour_devices(self, selected_ips: list[str], emit_progress: Callable = None):\n    \"\"\"\n    Synchronizes the time on a list of devices identified by their IP addresses.\n\n    Args:\n        selected_ips (list[str]): A list of IP addresses of the devices to update.\n        emit_progress (Callable, optional): A callback function to emit progress updates. Defaults to None.\n\n    Returns:\n        (Any): The result of the `update_devices_time` method from the superclass.\n    \"\"\"\n    self.emit_progress: Callable = emit_progress\n    self.state.reset()\n    return super().update_devices_time(selected_ips)\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.HourManager.update_device_time_of_one_device","title":"<code>update_device_time_of_one_device(device)</code>","text":"<p>Updates the device time for a single device.</p> <p>This method attempts to connect to the specified device, update its time,  and handle any errors that may occur during the process. It also updates  the device's error status and progress tracking.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device object containing information such as               IP address, communication type, model name, and point.</p> required <p>Raises:</p> Type Description <code>ConnectionFailedError</code> <p>If the connection to the device fails.</p> <code>BatteryFailingError</code> <p>If the device's battery is failing and its time                   cannot be updated.</p> <code>BaseError</code> <p>For any other unexpected errors, with error code 3000.</p> Notes <ul> <li>Uses a lock to ensure thread-safe updates to the <code>devices_errors</code> dictionary.</li> <li>Updates the battery status if an outdated time error occurs.</li> <li>Ensures the connection is properly closed in the <code>finally</code> block.</li> <li>Tracks progress using the <code>ProgressTracker</code> class.</li> </ul> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def update_device_time_of_one_device(self, device: Device):\n    \"\"\"\n    Updates the device time for a single device.\n\n    This method attempts to connect to the specified device, update its time, \n    and handle any errors that may occur during the process. It also updates \n    the device's error status and progress tracking.\n\n    Args:\n        device (Device): The device object containing information such as \n                         IP address, communication type, model name, and point.\n\n    Raises:\n        ConnectionFailedError: If the connection to the device fails.\n        BatteryFailingError: If the device's battery is failing and its time \n                             cannot be updated.\n        BaseError: For any other unexpected errors, with error code 3000.\n\n    Notes:\n        - Uses a lock to ensure thread-safe updates to the `devices_errors` dictionary.\n        - Updates the battery status if an outdated time error occurs.\n        - Ensures the connection is properly closed in the `finally` block.\n        - Tracks progress using the `ProgressTracker` class.\n    \"\"\"\n    logging.debug(f\"Iniciando {device.ip}\")\n    try:\n        try:\n            conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n            conn_manager.connect_with_retry()\n            with self.lock:\n                self.devices_errors[device.ip] = { \"connection failed\": False }\n            conn_manager.update_time()\n            with self.lock:\n                self.devices_errors[device.ip] = { \"battery failing\": False }\n        except NetworkError as e:\n            with self.lock:\n                self.devices_errors[device.ip] = { \"connection failed\": True }\n            raise ConnectionFailedError(device.model_name, device.point, device.ip)\n        except OutdatedTimeError as e:\n            with self.lock:\n                self.devices_errors[device.ip] = { \"battery failing\": True }\n            HourManager().update_battery_status(device.ip)\n            raise BatteryFailingError(device.model_name, device.point, device.ip)\n    except ConnectionFailedError as e:\n        pass\n    except BatteryFailingError as e:\n        pass\n    except Exception as e:\n        BaseError(3000, str(e))\n    finally:\n        if conn_manager.is_connected():\n            conn_manager.disconnect()\n        ProgressTracker(self.state, self.emit_progress).update(device)\n        logging.debug(f\"Finalizando {device.ip}\")\n    return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ProgressTracker","title":"<code>ProgressTracker</code>","text":"Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>class ProgressTracker:\n    def __init__(self, state: SharedState, emit_progress: Callable):\n        \"\"\"\n        Initializes the ProgramManager instance.\n\n        Args:\n            state (SharedState): The shared state object used to manage and share data across components.\n            emit_progress (Callable): A callable function used to emit progress updates.\n        \"\"\"\n        self.state: SharedState = state\n        self.emit_progress: Callable = emit_progress\n\n    def update(self, device: Device):\n        \"\"\"\n        Updates the progress of processing a device and emits progress information if applicable.\n\n        Args:\n            device (Device): The device object being processed.\n\n        Behavior:\n            - Increments the count of processed devices in the current state.\n            - Calculates the progress percentage based on the total devices.\n            - Emits progress information including:\n                - Percent progress.\n                - IP address of the device being processed.\n                - Number of processed devices.\n                - Total number of devices.\n            - Logs the progress details for debugging purposes.\n\n        Exceptions:\n            - Catches any exception that occurs during the update process and raises a `BaseError`\n              with an error code of 3000 and a descriptive message.\n        \"\"\"\n        try:\n            if self.state:\n                processed_devices: int = self.state.increment_processed_devices()\n                if self.emit_progress:\n                    progress: int = self.state.calculate_progress()\n                    self.emit_progress(\n                        percent_progress=progress,\n                        device_progress=device.ip,\n                        processed_devices=processed_devices,\n                        total_devices=self.state.get_total_devices()\n                    )\n                    logging.debug(f\"Processed: {processed_devices}/{self.state.get_total_devices()}, Progress: {progress}%\")\n        except Exception as e:\n            BaseError(3000, f'Error actualizando el progreso: {str(e)}')\n        return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ProgressTracker.__init__","title":"<code>__init__(state, emit_progress)</code>","text":"<p>Initializes the ProgramManager instance.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SharedState</code> <p>The shared state object used to manage and share data across components.</p> required <code>emit_progress</code> <code>Callable</code> <p>A callable function used to emit progress updates.</p> required Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def __init__(self, state: SharedState, emit_progress: Callable):\n    \"\"\"\n    Initializes the ProgramManager instance.\n\n    Args:\n        state (SharedState): The shared state object used to manage and share data across components.\n        emit_progress (Callable): A callable function used to emit progress updates.\n    \"\"\"\n    self.state: SharedState = state\n    self.emit_progress: Callable = emit_progress\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.ProgressTracker.update","title":"<code>update(device)</code>","text":"<p>Updates the progress of processing a device and emits progress information if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device object being processed.</p> required Behavior <ul> <li>Increments the count of processed devices in the current state.</li> <li>Calculates the progress percentage based on the total devices.</li> <li>Emits progress information including:<ul> <li>Percent progress.</li> <li>IP address of the device being processed.</li> <li>Number of processed devices.</li> <li>Total number of devices.</li> </ul> </li> <li>Logs the progress details for debugging purposes.</li> </ul> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def update(self, device: Device):\n    \"\"\"\n    Updates the progress of processing a device and emits progress information if applicable.\n\n    Args:\n        device (Device): The device object being processed.\n\n    Behavior:\n        - Increments the count of processed devices in the current state.\n        - Calculates the progress percentage based on the total devices.\n        - Emits progress information including:\n            - Percent progress.\n            - IP address of the device being processed.\n            - Number of processed devices.\n            - Total number of devices.\n        - Logs the progress details for debugging purposes.\n\n    Exceptions:\n        - Catches any exception that occurs during the update process and raises a `BaseError`\n          with an error code of 3000 and a descriptive message.\n    \"\"\"\n    try:\n        if self.state:\n            processed_devices: int = self.state.increment_processed_devices()\n            if self.emit_progress:\n                progress: int = self.state.calculate_progress()\n                self.emit_progress(\n                    percent_progress=progress,\n                    device_progress=device.ip,\n                    processed_devices=processed_devices,\n                    total_devices=self.state.get_total_devices()\n                )\n                logging.debug(f\"Processed: {processed_devices}/{self.state.get_total_devices()}, Progress: {progress}%\")\n    except Exception as e:\n        BaseError(3000, f'Error actualizando el progreso: {str(e)}')\n    return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.RestartManager","title":"<code>RestartManager</code>","text":"<p>               Bases: <code>OperationManager</code></p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>class RestartManager(OperationManager):\n    def __init__(self):\n        \"\"\"\n        Initializes the ProgramManager instance.\n\n        This constructor sets up the shared state and initializes a dictionary\n        to track device errors. It also calls the superclass initializer with\n        the shared state.\n\n        Attributes:\n            state (SharedState): An instance of SharedState to manage shared data.\n            devices_errors (dict[str, dict[str, bool]]): A dictionary to store\n                error states for devices, where the keys are device identifiers\n                and the values are dictionaries mapping error types to their\n                boolean statuses.\n        \"\"\"\n        self.state = SharedState()\n        self.devices_errors: dict[str, dict[str, bool]] = {}\n        super().__init__(self.state)\n\n    def restart_devices(self, selected_ips: list[str], emit_progress: Callable = None):\n        \"\"\"\n        Restarts the devices specified by their IP addresses.\n        This method clears any existing device errors, resets the state, and manages\n        threads to restart the specified devices. If any errors occur during the \n        restart process, they are collected and returned.\n\n        Args:\n            selected_ips (list[str]): A list of IP addresses of the devices to restart.\n            emit_progress (Callable, optional): A callable function to emit progress updates. \n                Defaults to None.\n\n        Returns:\n            (dict): A dictionary containing errors encountered during the restart process, \n                    if any. If no errors occur, an empty dictionary is returned.\n        \"\"\"\n        self.devices_errors.clear()\n        self.emit_progress: Callable = emit_progress\n        self.state.reset()\n        super().manage_threads_to_devices(selected_ips=selected_ips, function=self.restart_device)\n\n        if len(self.devices_errors) &gt; 0:\n            return self.devices_errors\n\n    def restart_device(self, device: Device):\n        \"\"\"\n        Restart the specified device by establishing a connection, sending a restart command, \n        and handling any potential errors during the process.\n\n        Args:\n            device (Device): The device object containing details such as IP address, \n                             communication type, and model information.\n\n        Raises:\n            ConnectionFailedError: If the connection to the device fails.\n            BaseError: For any other unexpected errors during the restart process.\n\n        Notes:\n            - Uses a connection manager to handle the device connection and restart operation.\n            - Updates the device error state in a thread-safe manner using a lock.\n            - Ensures the connection is properly closed in the `finally` block.\n            - Tracks progress using the `ProgressTracker` class.\n        \"\"\"\n        try:\n            try:\n                conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n                conn_manager.connect_with_retry()\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"connection failed\": False }\n                conn_manager.restart_device()\n            except NetworkError as e:\n                with self.lock:\n                    self.devices_errors[device.ip] = { \"connection failed\": True }\n                raise ConnectionFailedError(device.model_name, device.point, device.ip)\n        except ConnectionFailedError as e:\n            pass\n        except Exception as e:\n            BaseError(3000, str(e))\n        finally:\n            if conn_manager.is_connected():\n                conn_manager.disconnect()\n            ProgressTracker(self.state, self.emit_progress).update(device)\n        return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.RestartManager.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ProgramManager instance.</p> <p>This constructor sets up the shared state and initializes a dictionary to track device errors. It also calls the superclass initializer with the shared state.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>SharedState</code> <p>An instance of SharedState to manage shared data.</p> <code>devices_errors</code> <code>dict[str, dict[str, bool]]</code> <p>A dictionary to store error states for devices, where the keys are device identifiers and the values are dictionaries mapping error types to their boolean statuses.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the ProgramManager instance.\n\n    This constructor sets up the shared state and initializes a dictionary\n    to track device errors. It also calls the superclass initializer with\n    the shared state.\n\n    Attributes:\n        state (SharedState): An instance of SharedState to manage shared data.\n        devices_errors (dict[str, dict[str, bool]]): A dictionary to store\n            error states for devices, where the keys are device identifiers\n            and the values are dictionaries mapping error types to their\n            boolean statuses.\n    \"\"\"\n    self.state = SharedState()\n    self.devices_errors: dict[str, dict[str, bool]] = {}\n    super().__init__(self.state)\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.RestartManager.restart_device","title":"<code>restart_device(device)</code>","text":"<p>Restart the specified device by establishing a connection, sending a restart command,  and handling any potential errors during the process.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device object containing details such as IP address,               communication type, and model information.</p> required <p>Raises:</p> Type Description <code>ConnectionFailedError</code> <p>If the connection to the device fails.</p> <code>BaseError</code> <p>For any other unexpected errors during the restart process.</p> Notes <ul> <li>Uses a connection manager to handle the device connection and restart operation.</li> <li>Updates the device error state in a thread-safe manner using a lock.</li> <li>Ensures the connection is properly closed in the <code>finally</code> block.</li> <li>Tracks progress using the <code>ProgressTracker</code> class.</li> </ul> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def restart_device(self, device: Device):\n    \"\"\"\n    Restart the specified device by establishing a connection, sending a restart command, \n    and handling any potential errors during the process.\n\n    Args:\n        device (Device): The device object containing details such as IP address, \n                         communication type, and model information.\n\n    Raises:\n        ConnectionFailedError: If the connection to the device fails.\n        BaseError: For any other unexpected errors during the restart process.\n\n    Notes:\n        - Uses a connection manager to handle the device connection and restart operation.\n        - Updates the device error state in a thread-safe manner using a lock.\n        - Ensures the connection is properly closed in the `finally` block.\n        - Tracks progress using the `ProgressTracker` class.\n    \"\"\"\n    try:\n        try:\n            conn_manager: ConnectionManager = ConnectionManager(device.ip, 4370, device.communication)\n            conn_manager.connect_with_retry()\n            with self.lock:\n                self.devices_errors[device.ip] = { \"connection failed\": False }\n            conn_manager.restart_device()\n        except NetworkError as e:\n            with self.lock:\n                self.devices_errors[device.ip] = { \"connection failed\": True }\n            raise ConnectionFailedError(device.model_name, device.point, device.ip)\n    except ConnectionFailedError as e:\n        pass\n    except Exception as e:\n        BaseError(3000, str(e))\n    finally:\n        if conn_manager.is_connected():\n            conn_manager.disconnect()\n        ProgressTracker(self.state, self.emit_progress).update(device)\n    return\n</code></pre>"},{"location":"api/#src.business_logic.program_manager.RestartManager.restart_devices","title":"<code>restart_devices(selected_ips, emit_progress=None)</code>","text":"<p>Restarts the devices specified by their IP addresses. This method clears any existing device errors, resets the state, and manages threads to restart the specified devices. If any errors occur during the  restart process, they are collected and returned.</p> <p>Parameters:</p> Name Type Description Default <code>selected_ips</code> <code>list[str]</code> <p>A list of IP addresses of the devices to restart.</p> required <code>emit_progress</code> <code>Callable</code> <p>A callable function to emit progress updates.  Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing errors encountered during the restart process,      if any. If no errors occur, an empty dictionary is returned.</p> Source code in <code>src\\business_logic\\program_manager.py</code> <pre><code>def restart_devices(self, selected_ips: list[str], emit_progress: Callable = None):\n    \"\"\"\n    Restarts the devices specified by their IP addresses.\n    This method clears any existing device errors, resets the state, and manages\n    threads to restart the specified devices. If any errors occur during the \n    restart process, they are collected and returned.\n\n    Args:\n        selected_ips (list[str]): A list of IP addresses of the devices to restart.\n        emit_progress (Callable, optional): A callable function to emit progress updates. \n            Defaults to None.\n\n    Returns:\n        (dict): A dictionary containing errors encountered during the restart process, \n                if any. If no errors occur, an empty dictionary is returned.\n    \"\"\"\n    self.devices_errors.clear()\n    self.emit_progress: Callable = emit_progress\n    self.state.reset()\n    super().manage_threads_to_devices(selected_ips=selected_ips, function=self.restart_device)\n\n    if len(self.devices_errors) &gt; 0:\n        return self.devices_errors\n</code></pre>"},{"location":"api/#src.ui","title":"<code>ui</code>","text":""},{"location":"api/#src.ui.base_dialog","title":"<code>base_dialog</code>","text":""},{"location":"api/#src.ui.base_dialog.BaseDialog","title":"<code>BaseDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>src\\ui\\base_dialog.py</code> <pre><code>class BaseDialog(QDialog):\n    def __init__(self, parent=None, window_title=\"\"):\n        \"\"\"\n        Initializes the base dialog window with the specified parent and window title.\n\n        Args:\n            parent (QWidget, optional): The parent widget for the dialog. Defaults to None.\n            window_title (str, optional): The title of the dialog window. Defaults to an empty string.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501\n                       and the exception message.\n        \"\"\"\n        try:\n            super().__init__(parent)\n            self.setWindowTitle(window_title)\n\n            # Set window icon\n            self.file_path_resources = os.path.join(find_marker_directory(\"resources\"), \"resources\")\n            self.file_path_icon = os.path.join(self.file_path_resources, \"fingerprint.ico\")\n            self.setWindowIcon(QIcon(self.file_path_icon))\n\n            # Allow minimizing the window\n            self.setWindowFlag(Qt.WindowMinimizeButtonHint, True)\n            # Allow maximizing the window\n            self.setWindowFlag(Qt.WindowMaximizeButtonHint, True)\n\n            self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        pass\n\n    def adjust_size_to_table(self):\n        \"\"\"\n        Adjusts the size of the dialog window to fit the content of the table widget.\n        This method resizes the columns of the table widget to fit their contents and calculates\n        the required width and height of the table based on its content. It ensures that the\n        dialog window does not exceed the available screen height, applying a margin if necessary.\n        Finally, it resizes the dialog window to accommodate the adjusted table dimensions.\n\n        Notes:\n            - An extra width adjustment is added to account for margins and the button bar.\n            - The height is capped to fit within the available screen height minus a margin.\n        \"\"\"\n        # Adjust columns based on the content\n        self.table_widget.resizeColumnsToContents()\n\n        # Get the content size of the table (width and height)\n        table_width = self.table_widget.horizontalHeader().length()\n        table_height = self.table_widget.verticalHeader().length() + self.table_widget.rowCount() * self.table_widget.rowHeight(0)\n\n        max_height = self.screen().availableGeometry().height()\n        if table_height &gt; max_height:\n            table_height = max_height-50\n\n        # Adjust the main window size\n        self.resize(table_width + 120, table_height)  # Extra adjustment for margins and button bar\n\n    def center_window(self):\n        \"\"\"\n        Centers the window on the current screen.\n\n        This method calculates the available geometry of the current screen\n        and moves the window to the center of the screen.\n\n        Returns:\n            None\n        \"\"\"\n        screen = self.screen()  # Get the current screen\n        screen_rect = screen.availableGeometry()  # Get screen available geometry\n        self.move(screen_rect.center() - self.rect().center())  # Move to center\n</code></pre>"},{"location":"api/#src.ui.base_dialog.BaseDialog.__init__","title":"<code>__init__(parent=None, window_title='')</code>","text":"<p>Initializes the base dialog window with the specified parent and window title.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog. Defaults to None.</p> <code>None</code> <code>window_title</code> <code>str</code> <p>The title of the dialog window. Defaults to an empty string.</p> <code>''</code> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with code 3501        and the exception message.</p> Source code in <code>src\\ui\\base_dialog.py</code> <pre><code>def __init__(self, parent=None, window_title=\"\"):\n    \"\"\"\n    Initializes the base dialog window with the specified parent and window title.\n\n    Args:\n        parent (QWidget, optional): The parent widget for the dialog. Defaults to None.\n        window_title (str, optional): The title of the dialog window. Defaults to an empty string.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501\n                   and the exception message.\n    \"\"\"\n    try:\n        super().__init__(parent)\n        self.setWindowTitle(window_title)\n\n        # Set window icon\n        self.file_path_resources = os.path.join(find_marker_directory(\"resources\"), \"resources\")\n        self.file_path_icon = os.path.join(self.file_path_resources, \"fingerprint.ico\")\n        self.setWindowIcon(QIcon(self.file_path_icon))\n\n        # Allow minimizing the window\n        self.setWindowFlag(Qt.WindowMinimizeButtonHint, True)\n        # Allow maximizing the window\n        self.setWindowFlag(Qt.WindowMaximizeButtonHint, True)\n\n        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.base_dialog.BaseDialog.adjust_size_to_table","title":"<code>adjust_size_to_table()</code>","text":"<p>Adjusts the size of the dialog window to fit the content of the table widget. This method resizes the columns of the table widget to fit their contents and calculates the required width and height of the table based on its content. It ensures that the dialog window does not exceed the available screen height, applying a margin if necessary. Finally, it resizes the dialog window to accommodate the adjusted table dimensions.</p> Notes <ul> <li>An extra width adjustment is added to account for margins and the button bar.</li> <li>The height is capped to fit within the available screen height minus a margin.</li> </ul> Source code in <code>src\\ui\\base_dialog.py</code> <pre><code>def adjust_size_to_table(self):\n    \"\"\"\n    Adjusts the size of the dialog window to fit the content of the table widget.\n    This method resizes the columns of the table widget to fit their contents and calculates\n    the required width and height of the table based on its content. It ensures that the\n    dialog window does not exceed the available screen height, applying a margin if necessary.\n    Finally, it resizes the dialog window to accommodate the adjusted table dimensions.\n\n    Notes:\n        - An extra width adjustment is added to account for margins and the button bar.\n        - The height is capped to fit within the available screen height minus a margin.\n    \"\"\"\n    # Adjust columns based on the content\n    self.table_widget.resizeColumnsToContents()\n\n    # Get the content size of the table (width and height)\n    table_width = self.table_widget.horizontalHeader().length()\n    table_height = self.table_widget.verticalHeader().length() + self.table_widget.rowCount() * self.table_widget.rowHeight(0)\n\n    max_height = self.screen().availableGeometry().height()\n    if table_height &gt; max_height:\n        table_height = max_height-50\n\n    # Adjust the main window size\n    self.resize(table_width + 120, table_height)  # Extra adjustment for margins and button bar\n</code></pre>"},{"location":"api/#src.ui.base_dialog.BaseDialog.center_window","title":"<code>center_window()</code>","text":"<p>Centers the window on the current screen.</p> <p>This method calculates the available geometry of the current screen and moves the window to the center of the screen.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src\\ui\\base_dialog.py</code> <pre><code>def center_window(self):\n    \"\"\"\n    Centers the window on the current screen.\n\n    This method calculates the available geometry of the current screen\n    and moves the window to the center of the screen.\n\n    Returns:\n        None\n    \"\"\"\n    screen = self.screen()  # Get the current screen\n    screen_rect = screen.availableGeometry()  # Get screen available geometry\n    self.move(screen_rect.center() - self.rect().center())  # Move to center\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog","title":"<code>base_select_devices_dialog</code>","text":""},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog","title":"<code>SelectDevicesDialog</code>","text":"<p>               Bases: <code>BaseDialog</code></p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>class SelectDevicesDialog(BaseDialog):\n    def __init__(self, parent=None, op_function=None, window_title=\"\"):\n        \"\"\"\n        Initializes the BaseSelectDevicesDialog class.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n            op_function (callable, optional): A callable operation function to be executed. Defaults to None.\n            window_title (str, optional): The title of the dialog window. Defaults to an empty string.\n\n        Attributes:\n            op_function (callable): Stores the operation function passed as an argument.\n            file_path (str): The file path to the \"info_devices.txt\" file, located in the current working directory.\n            data (list): A list to store device-related data.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the error message.\n        \"\"\"\n        try:\n            super().__init__(parent, window_title=window_title)\n            self.op_function = op_function\n            # File path containing device information\n            self.file_path = os.path.join(os.getcwd(), \"info_devices.txt\")\n            self.data = []\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self, header_labels):\n        \"\"\"\n        Initializes the user interface for the device selection dialog.\n\n        Args:\n            header_labels (list): A list of strings representing the column headers for the table.\n\n        UI Components:\n            - QVBoxLayout: Main layout for the dialog.\n            - QTableWidget: Table widget to display devices with configurable columns and sorting enabled.\n            - QPushButton: Buttons for updating data, selecting all rows, and deselecting all rows.\n            - QLabel: Label to display a message when data is being updated.\n            - QProgressBar: Progress bar to indicate the progress of data updates.\n            - ComboBoxDelegate: Delegate for the communication column to provide a combo box UI.\n\n        Features:\n            - Multi-selection enabled for the table with full row selection.\n            - Buttons to select all rows, deselect all rows, and perform operations on selected devices.\n            - Progress bar and label for visual feedback during data updates.\n            - Automatic loading of initial device data into the table.\n\n        Raises:\n            BaseError: If an exception occurs during the initialization process, it raises a BaseError with code 3501.\n        \"\"\"\n        try:\n            layout = QVBoxLayout(self)\n\n            from PyQt5.QtWidgets import QHBoxLayout\n\n            self.inputs_widget = QWidget()\n            self.inputs_layout = QHBoxLayout(self.inputs_widget)\n\n            self.label_timeout = QLabel(\"Tiempo de Espera:\", self)\n            self.spin_timeout = QSpinBox(self)\n            self.spin_timeout.setMinimum(0)\n            self.spin_timeout.setMaximum(999)\n            config.read(os.path.join(find_root_directory(), 'config.ini'))\n            self.timeout = config.getint('Network_config', 'timeout')\n            if self.timeout:\n                self.spin_timeout.setValue(self.timeout)\n            else:\n                self.spin_timeout.setValue(15)\n            self.spin_timeout.valueChanged.connect(self.on_change_timeout)\n\n            self.label_retries = QLabel(\"Reintentos:\", self)\n            self.spin_retries = QSpinBox(self)\n            self.spin_retries.setMinimum(0)\n            self.spin_retries.setMaximum(10)\n            self.retries = config.getint('Network_config', 'retry_connection')\n            if self.retries:\n                self.spin_retries.setValue(self.retries)\n            else:\n                self.spin_retries.setValue(3)\n            self.spin_retries.valueChanged.connect(self.on_change_retries)\n\n            self.inputs_layout.addWidget(self.label_timeout)\n            self.inputs_layout.addWidget(self.spin_timeout)\n            self.inputs_layout.addWidget(self.label_retries)\n            self.inputs_layout.addWidget(self.spin_retries)\n\n            layout.addWidget(self.inputs_widget)\n\n            # Table for show devices\n            self.table_widget = QTableWidget()\n            self.table_widget.setColumnCount(len(header_labels))\n            self.table_widget.setHorizontalHeaderLabels(header_labels)\n            self.table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n            self.table_widget.horizontalHeader().setStretchLastSection(True)\n            self.table_widget.setSortingEnabled(True)\n\n            # Enable full row selection with multi-selection (each click toggles selection)\n            self.table_widget.setSelectionBehavior(QTableWidget.SelectRows)\n            self.table_widget.setSelectionMode(QTableWidget.MultiSelection)\n            layout.addWidget(self.table_widget)\n\n            self.button_layout = QHBoxLayout()\n\n            # Button for update data (operate for selected devices)\n            self.btn_update = QPushButton(\"Actualizar datos\")\n            self.btn_update.clicked.connect(self.operation_with_selected_ips)\n            self.button_layout.addWidget(self.btn_update)\n\n            self.btn_activate_all = QPushButton(\"Seleccionar todo\", self)\n            self.btn_activate_all.clicked.connect(self.select_all_rows)\n            self.button_layout.addWidget(self.btn_activate_all)\n\n            self.btn_deactivate_all = QPushButton(\"Deseleccionar todo\", self)\n            self.btn_deactivate_all.clicked.connect(self.deselect_all_rows)\n            self.button_layout.addWidget(self.btn_deactivate_all)\n\n            layout.addLayout(self.button_layout)\n\n            self.label_updating = QLabel(\"Actualizando datos...\", self)\n            self.label_updating.setAlignment(Qt.AlignCenter)\n            self.label_updating.setVisible(False)\n            layout.addWidget(self.label_updating)\n\n            # Progress bar\n            self.progress_bar = QProgressBar(self)\n            self.progress_bar.setMinimum(0)\n            self.progress_bar.setMaximum(100)\n            self.progress_bar.setValue(0)\n            self.progress_bar.setVisible(False)\n            layout.addWidget(self.progress_bar)\n\n            self.setLayout(layout)\n\n            # Set delegate for communication column (UI only)\n            combo_box_delegate = ComboBoxDelegate(self.table_widget)\n            self.table_widget.setItemDelegateForColumn(5, combo_box_delegate)\n\n            # Load initial device data\n            self.load_data()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def on_change_timeout(self, value):\n        if value != self.timeout:\n            self.timeout = value\n            config.set('Network_config', 'timeout', str(self.spin_timeout.value()))\n            with open(os.path.join(find_root_directory(), 'config.ini'), 'w') as configfile:\n                config.write(configfile)\n\n    def on_change_retries(self, value):\n        if value != self.retries:\n            self.retries = value\n            config.set('Network_config', 'retry_connection', str(self.spin_retries.value()))\n            with open(os.path.join(find_root_directory(), 'config.ini'), 'w') as configfile:\n                config.write(configfile)\n\n    def load_data(self):\n        \"\"\"\n        Loads data from a file specified by `self.file_path` and filters it based on \n        specific criteria. The method reads each line of the file, splits it into \n        parts, and checks if the last part (active status) indicates a truthy value \n        (e.g., 'true', '1', 'yes', 'verdadero', 'si'). If the criteria are met, \n        selected fields are extracted and appended to `self.data`.\n\n        After processing the file, the data is loaded into a table using \n        `self.load_data_into_table()`.\n\n        Raises:\n            BaseError: If an exception occurs during file reading or processing, \n                       it raises a `BaseError` with code 3001 and the exception message.\n        \"\"\"\n        try:\n            self.data = []\n            with open(self.file_path, \"r\") as file:\n                for line in file:\n                    parts = line.strip().split(\" - \")\n                    if len(parts) == 8 and parts[7].lower() in ['true', '1', 'yes', 'verdadero', 'si']:\n                        # Unpack only the required fields for display\n                        district, model, point, ip, id_val, communication, battery, active = parts\n                        self.data.append((district, model, point, ip, id_val, communication))\n            self.load_data_into_table()\n        except Exception as e:\n            raise BaseError(3001, str(e))\n\n    def load_data_into_table(self):\n        \"\"\"\n        Populates the table widget with data from the `self.data` attribute.\n\n        This method clears any existing rows in the table widget and inserts new rows\n        based on the records in `self.data`. Each cell is populated with non-editable\n        items, and the background color of the cells is set to light gray. After\n        populating the table, the method adjusts the table's size to fit its content.\n\n        Steps:\n\n        1. Clears all rows in the table widget.\n        2. Iterates through the records in `self.data` and inserts rows into the table.\n        3. Creates non-editable table items for each cell and sets their background color.\n        4. Adjusts the table size to fit the content.\n\n        Note:\n            - The `self.data` attribute is expected to be an iterable of records, where\n              each record is an iterable of values corresponding to table columns.\n            - The table widget is assumed to be an instance of QTableWidget.\n\n        \"\"\"\n        self.table_widget.setRowCount(0)\n        for row_index, record in enumerate(self.data):\n            self.table_widget.insertRow(row_index)\n            # Create non-editable items for each column\n            for col_index, value in enumerate(record):\n                item = QTableWidgetItem(str(value))\n                item.setFlags(item.flags() &amp; ~Qt.ItemIsEditable)\n                item.setBackground(QColor(Qt.lightGray))\n                self.table_widget.setItem(row_index, col_index, item)\n        self.adjust_size_to_table()\n\n    def operation_with_selected_ips(self):\n        \"\"\"\n        Handles operations with the selected IP addresses from the table widget.\n        This method retrieves the selected rows from the table widget, extracts the IP addresses\n        from a specific column, and performs an operation on the selected IPs using a separate thread.\n        It also updates the UI to reflect the ongoing operation and handles progress updates.\n\n        Raises:\n            Exception: If no devices are selected, a message box is displayed, and an exception is raised.\n            BaseError: If any other exception occurs during the execution of the method.\n\n        Attributes:\n            selected_ips (list[str]): A list to store the IP addresses of the selected devices.\n\n        UI Updates:\n            - Hides the table widget.\n            - Sorts the table widget by the IP column in descending order.\n            - Updates labels and buttons to indicate the operation is in progress.\n            - Displays a progress bar to show the operation's progress.\n\n        Threads:\n            - Creates and starts an `OperationThread` to perform the operation on the selected IPs.\n            - Connects thread signals to appropriate methods for progress updates, termination, and cleanup.\n        \"\"\"\n        try:        \n            self.selected_ips: list[str] = []\n            # Retrieve selected rows via the selection model\n            for index in self.table_widget.selectionModel().selectedRows():\n                row = index.row()\n                ip = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n                self.selected_ips.append(ip)\n\n            if not self.selected_ips:\n                QMessageBox.information(self, \"Sin selecci\u00f3n\", \"No se seleccionaron dispositivos\")\n                raise Exception(\"No se seleccionaron dispositivos\")\n            else:\n                self.inputs_widget.setVisible(False)\n                self.table_widget.setVisible(False)\n                self.table_widget.sortByColumn(3, Qt.DescendingOrder)\n                self.label_updating.setText(\"Actualizando datos...\")\n                self.btn_update.setVisible(False)\n                self.btn_activate_all.setVisible(False)\n                self.btn_deactivate_all.setVisible(False)\n                self.label_updating.setVisible(True)\n                self.progress_bar.setVisible(True)\n                self.progress_bar.setValue(0)\n                #logging.debug(f\"Dispositivos seleccionados: {self.selected_ips}\")\n                self.op_thread = OperationThread(self.op_function, self.selected_ips)\n                self.op_thread.progress_updated.connect(self.update_progress)\n                self.op_thread.op_terminate.connect(self.op_terminate)\n                self.op_thread.finished.connect(self.cleanup_thread)\n                self.op_thread.start()\n        except Exception as e:\n            raise BaseError(3000, str(e))\n\n    def cleanup_thread(self):\n        \"\"\"\n        Cleans up the operation thread by scheduling its deletion.\n\n        This method ensures that the `op_thread` object is properly deleted\n        using the `deleteLater()` method, which schedules the object for\n        deletion once it is safe to do so, typically after all pending events\n        have been processed.\n        \"\"\"\n        self.op_thread.deleteLater()\n\n    def op_terminate(self, devices=None):\n        \"\"\"\n        Resets the UI components to their default visible states after an operation.\n\n        Args:\n            devices (optional): A parameter for devices, currently unused in the method.\n        \"\"\"\n        self.inputs_widget.setVisible(True)\n        self.btn_update.setVisible(True)\n        self.btn_activate_all.setVisible(True)\n        self.btn_deactivate_all.setVisible(True)\n        self.table_widget.setVisible(True)\n        self.label_updating.setVisible(False)\n        self.progress_bar.setVisible(False)\n\n    def column_exists(self, column_name):\n        \"\"\"\n        Checks if a column with the specified name exists in the table widget.\n\n        Args:\n            column_name (str): The name of the column to check for existence.\n\n        Returns:\n            (bool): True if the column exists, False otherwise.\n        \"\"\"\n        headers = [self.table_widget.horizontalHeaderItem(i).text() for i in range(self.table_widget.columnCount())]\n        return column_name in headers\n\n    def get_column_number(self, column_name):\n        \"\"\"\n        Retrieves the index of a column in the table widget based on the column's name.\n\n        Args:\n            column_name (str): The name of the column to search for.\n\n        Returns:\n            (int): The index of the column if found, otherwise -1.\n        \"\"\"\n        for i in range(self.table_widget.columnCount()):\n            if self.table_widget.horizontalHeaderItem(i).text() == column_name:\n                return i\n        return -1\n\n    def update_progress(self, percent_progress, device_progress, processed_devices, total_devices):\n        \"\"\"\n        Updates the progress bar and status label with the current progress of device processing.\n\n        Args:\n            percent_progress (int): The overall progress percentage to be displayed on the progress bar.\n            device_progress (str): A message indicating the status of the last connection attempt.\n            processed_devices (int): The number of devices that have been processed so far.\n            total_devices (int): The total number of devices to be processed.\n\n        Returns:\n            None\n        \"\"\"\n        if percent_progress and device_progress:\n            self.progress_bar.setValue(percent_progress)\n            self.label_updating.setText(f\"\u00daltimo intento de conexi\u00f3n: {device_progress}\\n{processed_devices}/{total_devices} dispositivos\")\n\n    def select_all_rows(self):\n        \"\"\"\n        Selects all rows in the table widget that are not already selected.\n        This method retrieves the list of currently selected rows in the table widget\n        and iterates through all rows in the table. If a row is not already selected,\n        it selects the row.\n\n        Note:\n            - The method assumes that `self.table_widget` is a valid QTableWidget or\n              similar widget with `selectionModel`, `selectedRows`, `rowCount`, and\n              `selectRow` methods.\n        \"\"\"\n        selected_rows = [index.row() for index in self.table_widget.selectionModel().selectedRows()]\n\n        row_count = self.table_widget.rowCount()\n        for row in range(row_count):\n            if row not in selected_rows:\n                self.table_widget.selectRow(row)\n\n    def deselect_all_rows(self):\n        \"\"\"\n        Deselects all rows in the table widget.\n\n        This method clears the current selection in the table widget,\n        ensuring that no rows remain selected.\n        \"\"\"\n        self.table_widget.clearSelection()\n\n    def ensure_column_exists(self, column_name):\n        \"\"\"\n        Ensures that a column with the specified name exists in the table widget. \n        If the column does not exist, it creates a new column with the given name.\n        If the column already exists, it retrieves its index.\n\n        Args:\n            column_name (str): The name of the column to ensure exists.\n\n        Returns:\n            (int): The index of the column in the table widget.\n        \"\"\"\n        if not self.column_exists(column_name):\n            # Add a new column to the table\n            actual_column = self.table_widget.columnCount()\n            self.table_widget.setColumnCount(actual_column + 1)\n            self.table_widget.setHorizontalHeaderItem(actual_column, QTableWidgetItem(column_name))\n        else:\n            # Get the column number\n            actual_column = self.get_column_number(column_name)\n        return actual_column\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.__init__","title":"<code>__init__(parent=None, op_function=None, window_title='')</code>","text":"<p>Initializes the BaseSelectDevicesDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <code>op_function</code> <code>callable</code> <p>A callable operation function to be executed. Defaults to None.</p> <code>None</code> <code>window_title</code> <code>str</code> <p>The title of the dialog window. Defaults to an empty string.</p> <code>''</code> <p>Attributes:</p> Name Type Description <code>op_function</code> <code>callable</code> <p>Stores the operation function passed as an argument.</p> <code>file_path</code> <code>str</code> <p>The file path to the \"info_devices.txt\" file, located in the current working directory.</p> <code>data</code> <code>list</code> <p>A list to store device-related data.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with code 3501 and the error message.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def __init__(self, parent=None, op_function=None, window_title=\"\"):\n    \"\"\"\n    Initializes the BaseSelectDevicesDialog class.\n\n    Args:\n        parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n        op_function (callable, optional): A callable operation function to be executed. Defaults to None.\n        window_title (str, optional): The title of the dialog window. Defaults to an empty string.\n\n    Attributes:\n        op_function (callable): Stores the operation function passed as an argument.\n        file_path (str): The file path to the \"info_devices.txt\" file, located in the current working directory.\n        data (list): A list to store device-related data.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the error message.\n    \"\"\"\n    try:\n        super().__init__(parent, window_title=window_title)\n        self.op_function = op_function\n        # File path containing device information\n        self.file_path = os.path.join(os.getcwd(), \"info_devices.txt\")\n        self.data = []\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.cleanup_thread","title":"<code>cleanup_thread()</code>","text":"<p>Cleans up the operation thread by scheduling its deletion.</p> <p>This method ensures that the <code>op_thread</code> object is properly deleted using the <code>deleteLater()</code> method, which schedules the object for deletion once it is safe to do so, typically after all pending events have been processed.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def cleanup_thread(self):\n    \"\"\"\n    Cleans up the operation thread by scheduling its deletion.\n\n    This method ensures that the `op_thread` object is properly deleted\n    using the `deleteLater()` method, which schedules the object for\n    deletion once it is safe to do so, typically after all pending events\n    have been processed.\n    \"\"\"\n    self.op_thread.deleteLater()\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.column_exists","title":"<code>column_exists(column_name)</code>","text":"<p>Checks if a column with the specified name exists in the table widget.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the column to check for existence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the column exists, False otherwise.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def column_exists(self, column_name):\n    \"\"\"\n    Checks if a column with the specified name exists in the table widget.\n\n    Args:\n        column_name (str): The name of the column to check for existence.\n\n    Returns:\n        (bool): True if the column exists, False otherwise.\n    \"\"\"\n    headers = [self.table_widget.horizontalHeaderItem(i).text() for i in range(self.table_widget.columnCount())]\n    return column_name in headers\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.deselect_all_rows","title":"<code>deselect_all_rows()</code>","text":"<p>Deselects all rows in the table widget.</p> <p>This method clears the current selection in the table widget, ensuring that no rows remain selected.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def deselect_all_rows(self):\n    \"\"\"\n    Deselects all rows in the table widget.\n\n    This method clears the current selection in the table widget,\n    ensuring that no rows remain selected.\n    \"\"\"\n    self.table_widget.clearSelection()\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.ensure_column_exists","title":"<code>ensure_column_exists(column_name)</code>","text":"<p>Ensures that a column with the specified name exists in the table widget.  If the column does not exist, it creates a new column with the given name. If the column already exists, it retrieves its index.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the column to ensure exists.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the column in the table widget.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def ensure_column_exists(self, column_name):\n    \"\"\"\n    Ensures that a column with the specified name exists in the table widget. \n    If the column does not exist, it creates a new column with the given name.\n    If the column already exists, it retrieves its index.\n\n    Args:\n        column_name (str): The name of the column to ensure exists.\n\n    Returns:\n        (int): The index of the column in the table widget.\n    \"\"\"\n    if not self.column_exists(column_name):\n        # Add a new column to the table\n        actual_column = self.table_widget.columnCount()\n        self.table_widget.setColumnCount(actual_column + 1)\n        self.table_widget.setHorizontalHeaderItem(actual_column, QTableWidgetItem(column_name))\n    else:\n        # Get the column number\n        actual_column = self.get_column_number(column_name)\n    return actual_column\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.get_column_number","title":"<code>get_column_number(column_name)</code>","text":"<p>Retrieves the index of a column in the table widget based on the column's name.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the column to search for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the column if found, otherwise -1.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def get_column_number(self, column_name):\n    \"\"\"\n    Retrieves the index of a column in the table widget based on the column's name.\n\n    Args:\n        column_name (str): The name of the column to search for.\n\n    Returns:\n        (int): The index of the column if found, otherwise -1.\n    \"\"\"\n    for i in range(self.table_widget.columnCount()):\n        if self.table_widget.horizontalHeaderItem(i).text() == column_name:\n            return i\n    return -1\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.init_ui","title":"<code>init_ui(header_labels)</code>","text":"<p>Initializes the user interface for the device selection dialog.</p> <p>Parameters:</p> Name Type Description Default <code>header_labels</code> <code>list</code> <p>A list of strings representing the column headers for the table.</p> required UI Components <ul> <li>QVBoxLayout: Main layout for the dialog.</li> <li>QTableWidget: Table widget to display devices with configurable columns and sorting enabled.</li> <li>QPushButton: Buttons for updating data, selecting all rows, and deselecting all rows.</li> <li>QLabel: Label to display a message when data is being updated.</li> <li>QProgressBar: Progress bar to indicate the progress of data updates.</li> <li>ComboBoxDelegate: Delegate for the communication column to provide a combo box UI.</li> </ul> Features <ul> <li>Multi-selection enabled for the table with full row selection.</li> <li>Buttons to select all rows, deselect all rows, and perform operations on selected devices.</li> <li>Progress bar and label for visual feedback during data updates.</li> <li>Automatic loading of initial device data into the table.</li> </ul> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the initialization process, it raises a BaseError with code 3501.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def init_ui(self, header_labels):\n    \"\"\"\n    Initializes the user interface for the device selection dialog.\n\n    Args:\n        header_labels (list): A list of strings representing the column headers for the table.\n\n    UI Components:\n        - QVBoxLayout: Main layout for the dialog.\n        - QTableWidget: Table widget to display devices with configurable columns and sorting enabled.\n        - QPushButton: Buttons for updating data, selecting all rows, and deselecting all rows.\n        - QLabel: Label to display a message when data is being updated.\n        - QProgressBar: Progress bar to indicate the progress of data updates.\n        - ComboBoxDelegate: Delegate for the communication column to provide a combo box UI.\n\n    Features:\n        - Multi-selection enabled for the table with full row selection.\n        - Buttons to select all rows, deselect all rows, and perform operations on selected devices.\n        - Progress bar and label for visual feedback during data updates.\n        - Automatic loading of initial device data into the table.\n\n    Raises:\n        BaseError: If an exception occurs during the initialization process, it raises a BaseError with code 3501.\n    \"\"\"\n    try:\n        layout = QVBoxLayout(self)\n\n        from PyQt5.QtWidgets import QHBoxLayout\n\n        self.inputs_widget = QWidget()\n        self.inputs_layout = QHBoxLayout(self.inputs_widget)\n\n        self.label_timeout = QLabel(\"Tiempo de Espera:\", self)\n        self.spin_timeout = QSpinBox(self)\n        self.spin_timeout.setMinimum(0)\n        self.spin_timeout.setMaximum(999)\n        config.read(os.path.join(find_root_directory(), 'config.ini'))\n        self.timeout = config.getint('Network_config', 'timeout')\n        if self.timeout:\n            self.spin_timeout.setValue(self.timeout)\n        else:\n            self.spin_timeout.setValue(15)\n        self.spin_timeout.valueChanged.connect(self.on_change_timeout)\n\n        self.label_retries = QLabel(\"Reintentos:\", self)\n        self.spin_retries = QSpinBox(self)\n        self.spin_retries.setMinimum(0)\n        self.spin_retries.setMaximum(10)\n        self.retries = config.getint('Network_config', 'retry_connection')\n        if self.retries:\n            self.spin_retries.setValue(self.retries)\n        else:\n            self.spin_retries.setValue(3)\n        self.spin_retries.valueChanged.connect(self.on_change_retries)\n\n        self.inputs_layout.addWidget(self.label_timeout)\n        self.inputs_layout.addWidget(self.spin_timeout)\n        self.inputs_layout.addWidget(self.label_retries)\n        self.inputs_layout.addWidget(self.spin_retries)\n\n        layout.addWidget(self.inputs_widget)\n\n        # Table for show devices\n        self.table_widget = QTableWidget()\n        self.table_widget.setColumnCount(len(header_labels))\n        self.table_widget.setHorizontalHeaderLabels(header_labels)\n        self.table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n        self.table_widget.horizontalHeader().setStretchLastSection(True)\n        self.table_widget.setSortingEnabled(True)\n\n        # Enable full row selection with multi-selection (each click toggles selection)\n        self.table_widget.setSelectionBehavior(QTableWidget.SelectRows)\n        self.table_widget.setSelectionMode(QTableWidget.MultiSelection)\n        layout.addWidget(self.table_widget)\n\n        self.button_layout = QHBoxLayout()\n\n        # Button for update data (operate for selected devices)\n        self.btn_update = QPushButton(\"Actualizar datos\")\n        self.btn_update.clicked.connect(self.operation_with_selected_ips)\n        self.button_layout.addWidget(self.btn_update)\n\n        self.btn_activate_all = QPushButton(\"Seleccionar todo\", self)\n        self.btn_activate_all.clicked.connect(self.select_all_rows)\n        self.button_layout.addWidget(self.btn_activate_all)\n\n        self.btn_deactivate_all = QPushButton(\"Deseleccionar todo\", self)\n        self.btn_deactivate_all.clicked.connect(self.deselect_all_rows)\n        self.button_layout.addWidget(self.btn_deactivate_all)\n\n        layout.addLayout(self.button_layout)\n\n        self.label_updating = QLabel(\"Actualizando datos...\", self)\n        self.label_updating.setAlignment(Qt.AlignCenter)\n        self.label_updating.setVisible(False)\n        layout.addWidget(self.label_updating)\n\n        # Progress bar\n        self.progress_bar = QProgressBar(self)\n        self.progress_bar.setMinimum(0)\n        self.progress_bar.setMaximum(100)\n        self.progress_bar.setValue(0)\n        self.progress_bar.setVisible(False)\n        layout.addWidget(self.progress_bar)\n\n        self.setLayout(layout)\n\n        # Set delegate for communication column (UI only)\n        combo_box_delegate = ComboBoxDelegate(self.table_widget)\n        self.table_widget.setItemDelegateForColumn(5, combo_box_delegate)\n\n        # Load initial device data\n        self.load_data()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.load_data","title":"<code>load_data()</code>","text":"<p>Loads data from a file specified by <code>self.file_path</code> and filters it based on  specific criteria. The method reads each line of the file, splits it into  parts, and checks if the last part (active status) indicates a truthy value  (e.g., 'true', '1', 'yes', 'verdadero', 'si'). If the criteria are met,  selected fields are extracted and appended to <code>self.data</code>.</p> <p>After processing the file, the data is loaded into a table using  <code>self.load_data_into_table()</code>.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during file reading or processing,         it raises a <code>BaseError</code> with code 3001 and the exception message.</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def load_data(self):\n    \"\"\"\n    Loads data from a file specified by `self.file_path` and filters it based on \n    specific criteria. The method reads each line of the file, splits it into \n    parts, and checks if the last part (active status) indicates a truthy value \n    (e.g., 'true', '1', 'yes', 'verdadero', 'si'). If the criteria are met, \n    selected fields are extracted and appended to `self.data`.\n\n    After processing the file, the data is loaded into a table using \n    `self.load_data_into_table()`.\n\n    Raises:\n        BaseError: If an exception occurs during file reading or processing, \n                   it raises a `BaseError` with code 3001 and the exception message.\n    \"\"\"\n    try:\n        self.data = []\n        with open(self.file_path, \"r\") as file:\n            for line in file:\n                parts = line.strip().split(\" - \")\n                if len(parts) == 8 and parts[7].lower() in ['true', '1', 'yes', 'verdadero', 'si']:\n                    # Unpack only the required fields for display\n                    district, model, point, ip, id_val, communication, battery, active = parts\n                    self.data.append((district, model, point, ip, id_val, communication))\n        self.load_data_into_table()\n    except Exception as e:\n        raise BaseError(3001, str(e))\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.load_data_into_table","title":"<code>load_data_into_table()</code>","text":"<p>Populates the table widget with data from the <code>self.data</code> attribute.</p> <p>This method clears any existing rows in the table widget and inserts new rows based on the records in <code>self.data</code>. Each cell is populated with non-editable items, and the background color of the cells is set to light gray. After populating the table, the method adjusts the table's size to fit its content.</p> <p>Steps:</p> <ol> <li>Clears all rows in the table widget.</li> <li>Iterates through the records in <code>self.data</code> and inserts rows into the table.</li> <li>Creates non-editable table items for each cell and sets their background color.</li> <li>Adjusts the table size to fit the content.</li> </ol> Note <ul> <li>The <code>self.data</code> attribute is expected to be an iterable of records, where   each record is an iterable of values corresponding to table columns.</li> <li>The table widget is assumed to be an instance of QTableWidget.</li> </ul> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def load_data_into_table(self):\n    \"\"\"\n    Populates the table widget with data from the `self.data` attribute.\n\n    This method clears any existing rows in the table widget and inserts new rows\n    based on the records in `self.data`. Each cell is populated with non-editable\n    items, and the background color of the cells is set to light gray. After\n    populating the table, the method adjusts the table's size to fit its content.\n\n    Steps:\n\n    1. Clears all rows in the table widget.\n    2. Iterates through the records in `self.data` and inserts rows into the table.\n    3. Creates non-editable table items for each cell and sets their background color.\n    4. Adjusts the table size to fit the content.\n\n    Note:\n        - The `self.data` attribute is expected to be an iterable of records, where\n          each record is an iterable of values corresponding to table columns.\n        - The table widget is assumed to be an instance of QTableWidget.\n\n    \"\"\"\n    self.table_widget.setRowCount(0)\n    for row_index, record in enumerate(self.data):\n        self.table_widget.insertRow(row_index)\n        # Create non-editable items for each column\n        for col_index, value in enumerate(record):\n            item = QTableWidgetItem(str(value))\n            item.setFlags(item.flags() &amp; ~Qt.ItemIsEditable)\n            item.setBackground(QColor(Qt.lightGray))\n            self.table_widget.setItem(row_index, col_index, item)\n    self.adjust_size_to_table()\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.op_terminate","title":"<code>op_terminate(devices=None)</code>","text":"<p>Resets the UI components to their default visible states after an operation.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>optional</code> <p>A parameter for devices, currently unused in the method.</p> <code>None</code> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def op_terminate(self, devices=None):\n    \"\"\"\n    Resets the UI components to their default visible states after an operation.\n\n    Args:\n        devices (optional): A parameter for devices, currently unused in the method.\n    \"\"\"\n    self.inputs_widget.setVisible(True)\n    self.btn_update.setVisible(True)\n    self.btn_activate_all.setVisible(True)\n    self.btn_deactivate_all.setVisible(True)\n    self.table_widget.setVisible(True)\n    self.label_updating.setVisible(False)\n    self.progress_bar.setVisible(False)\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.operation_with_selected_ips","title":"<code>operation_with_selected_ips()</code>","text":"<p>Handles operations with the selected IP addresses from the table widget. This method retrieves the selected rows from the table widget, extracts the IP addresses from a specific column, and performs an operation on the selected IPs using a separate thread. It also updates the UI to reflect the ongoing operation and handles progress updates.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no devices are selected, a message box is displayed, and an exception is raised.</p> <code>BaseError</code> <p>If any other exception occurs during the execution of the method.</p> <p>Attributes:</p> Name Type Description <code>selected_ips</code> <code>list[str]</code> <p>A list to store the IP addresses of the selected devices.</p> UI Updates <ul> <li>Hides the table widget.</li> <li>Sorts the table widget by the IP column in descending order.</li> <li>Updates labels and buttons to indicate the operation is in progress.</li> <li>Displays a progress bar to show the operation's progress.</li> </ul> Threads <ul> <li>Creates and starts an <code>OperationThread</code> to perform the operation on the selected IPs.</li> <li>Connects thread signals to appropriate methods for progress updates, termination, and cleanup.</li> </ul> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def operation_with_selected_ips(self):\n    \"\"\"\n    Handles operations with the selected IP addresses from the table widget.\n    This method retrieves the selected rows from the table widget, extracts the IP addresses\n    from a specific column, and performs an operation on the selected IPs using a separate thread.\n    It also updates the UI to reflect the ongoing operation and handles progress updates.\n\n    Raises:\n        Exception: If no devices are selected, a message box is displayed, and an exception is raised.\n        BaseError: If any other exception occurs during the execution of the method.\n\n    Attributes:\n        selected_ips (list[str]): A list to store the IP addresses of the selected devices.\n\n    UI Updates:\n        - Hides the table widget.\n        - Sorts the table widget by the IP column in descending order.\n        - Updates labels and buttons to indicate the operation is in progress.\n        - Displays a progress bar to show the operation's progress.\n\n    Threads:\n        - Creates and starts an `OperationThread` to perform the operation on the selected IPs.\n        - Connects thread signals to appropriate methods for progress updates, termination, and cleanup.\n    \"\"\"\n    try:        \n        self.selected_ips: list[str] = []\n        # Retrieve selected rows via the selection model\n        for index in self.table_widget.selectionModel().selectedRows():\n            row = index.row()\n            ip = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n            self.selected_ips.append(ip)\n\n        if not self.selected_ips:\n            QMessageBox.information(self, \"Sin selecci\u00f3n\", \"No se seleccionaron dispositivos\")\n            raise Exception(\"No se seleccionaron dispositivos\")\n        else:\n            self.inputs_widget.setVisible(False)\n            self.table_widget.setVisible(False)\n            self.table_widget.sortByColumn(3, Qt.DescendingOrder)\n            self.label_updating.setText(\"Actualizando datos...\")\n            self.btn_update.setVisible(False)\n            self.btn_activate_all.setVisible(False)\n            self.btn_deactivate_all.setVisible(False)\n            self.label_updating.setVisible(True)\n            self.progress_bar.setVisible(True)\n            self.progress_bar.setValue(0)\n            #logging.debug(f\"Dispositivos seleccionados: {self.selected_ips}\")\n            self.op_thread = OperationThread(self.op_function, self.selected_ips)\n            self.op_thread.progress_updated.connect(self.update_progress)\n            self.op_thread.op_terminate.connect(self.op_terminate)\n            self.op_thread.finished.connect(self.cleanup_thread)\n            self.op_thread.start()\n    except Exception as e:\n        raise BaseError(3000, str(e))\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.select_all_rows","title":"<code>select_all_rows()</code>","text":"<p>Selects all rows in the table widget that are not already selected. This method retrieves the list of currently selected rows in the table widget and iterates through all rows in the table. If a row is not already selected, it selects the row.</p> Note <ul> <li>The method assumes that <code>self.table_widget</code> is a valid QTableWidget or   similar widget with <code>selectionModel</code>, <code>selectedRows</code>, <code>rowCount</code>, and   <code>selectRow</code> methods.</li> </ul> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def select_all_rows(self):\n    \"\"\"\n    Selects all rows in the table widget that are not already selected.\n    This method retrieves the list of currently selected rows in the table widget\n    and iterates through all rows in the table. If a row is not already selected,\n    it selects the row.\n\n    Note:\n        - The method assumes that `self.table_widget` is a valid QTableWidget or\n          similar widget with `selectionModel`, `selectedRows`, `rowCount`, and\n          `selectRow` methods.\n    \"\"\"\n    selected_rows = [index.row() for index in self.table_widget.selectionModel().selectedRows()]\n\n    row_count = self.table_widget.rowCount()\n    for row in range(row_count):\n        if row not in selected_rows:\n            self.table_widget.selectRow(row)\n</code></pre>"},{"location":"api/#src.ui.base_select_devices_dialog.SelectDevicesDialog.update_progress","title":"<code>update_progress(percent_progress, device_progress, processed_devices, total_devices)</code>","text":"<p>Updates the progress bar and status label with the current progress of device processing.</p> <p>Parameters:</p> Name Type Description Default <code>percent_progress</code> <code>int</code> <p>The overall progress percentage to be displayed on the progress bar.</p> required <code>device_progress</code> <code>str</code> <p>A message indicating the status of the last connection attempt.</p> required <code>processed_devices</code> <code>int</code> <p>The number of devices that have been processed so far.</p> required <code>total_devices</code> <code>int</code> <p>The total number of devices to be processed.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>src\\ui\\base_select_devices_dialog.py</code> <pre><code>def update_progress(self, percent_progress, device_progress, processed_devices, total_devices):\n    \"\"\"\n    Updates the progress bar and status label with the current progress of device processing.\n\n    Args:\n        percent_progress (int): The overall progress percentage to be displayed on the progress bar.\n        device_progress (str): A message indicating the status of the last connection attempt.\n        processed_devices (int): The number of devices that have been processed so far.\n        total_devices (int): The total number of devices to be processed.\n\n    Returns:\n        None\n    \"\"\"\n    if percent_progress and device_progress:\n        self.progress_bar.setValue(percent_progress)\n        self.label_updating.setText(f\"\u00daltimo intento de conexi\u00f3n: {device_progress}\\n{processed_devices}/{total_devices} dispositivos\")\n</code></pre>"},{"location":"api/#src.ui.icon_manager","title":"<code>icon_manager</code>","text":""},{"location":"api/#src.ui.icon_manager.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>class MainWindow(QMainWindow):\n    def __init__(self):\n        \"\"\"\n        Initializes the IconManager class.\n        This constructor sets up the initial state of the application, including\n        the system tray icon, configuration settings, and application startup behavior.\n        It also handles potential duplicate instances of the application.\n\n        Attributes:\n            is_running (bool): Indicates if the application is currently running.\n            checked_clear_attendance (bool): State of the \"clear attendance\" checkbox,\n                retrieved from the configuration file.\n            checked_automatic_init (bool): Indicates if the application is set to start\n                automatically on system startup.\n            tray_icon (QSystemTrayIcon): The system tray icon for the application.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a\n                BaseError with an error code, message, and severity level.\n        \"\"\"\n        try:\n            super().__init__()\n            self.is_running = False  # Variable to indicate if the application is running\n            self.checked_clear_attendance = eval(config['Device_config']['clear_attendance'])  # State of the clear attendance checkbox\n            self.checked_automatic_init = is_startup_entry_exists(\"Programa Reloj de Asistencias\")\n\n            self.tray_icon: QSystemTrayIcon = None  # Variable to store the QSystemTrayIcon\n            self.__init_ui()  # Initialize the user interface\n\n            # Set the initial tray icon to loading.png\n            file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"loading.png\")  # Icon file path\n            # logging.debug(file_path)\n            self.tray_icon.setIcon(QIcon(file_path))\n\n            \"\"\" if not is_user_admin():\n                run_as_admin()\n            \"\"\"\n\n            #if verify_duplicated_instance(sys.argv[0]):\n            #    exit_duplicated_instance()\n\n            # Change the tray icon to program-icon.png after all initializations\n            file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"program-icon.png\")  # Icon file path\n            # logging.debug(file_path)\n            self.tray_icon.setIcon(QIcon(file_path))\n        except Exception as e:\n            raise BaseError(3501, str(e), \"critical\")\n\n    def __init_ui(self):\n        \"\"\"\n        Initializes the user interface components for the application.\n\n        This method is responsible for setting up and configuring the system tray icon\n        by invoking the necessary helper methods. It ensures that the system tray icon\n        is properly created and ready for use.\n        \"\"\"\n        # Create and configure the system tray icon\n        self.__create_tray_icon()  # Create the system tray icon        \n\n    def __create_tray_icon(self):\n        \"\"\"\n        Creates and configures the system tray icon for the application.\n        This method initializes a QSystemTrayIcon with a tooltip and a custom context menu\n        containing various actions for interacting with the application. The context menu\n        includes options for modifying devices, restarting devices, testing connections,\n        updating device time, fetching attendances, and toggling specific settings. It also\n        provides options to view logs and exit the application.\n        The tray icon displays a notification message upon initialization and is shown in\n        the system tray.\n\n        Raises:\n            BaseError: If an exception occurs during the creation or configuration of the\n                       system tray icon, it raises a BaseError with an error code and message.\n        \"\"\"\n        try:\n            file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"loading.png\")  # Icon file path\n            # logging.debug(file_path)\n            self.tray_icon = QSystemTrayIcon(QIcon(file_path), self)  # Create QSystemTrayIcon with the icon and associated main window\n            self.tray_icon.showMessage(\"Notificaci\u00f3n\", 'Iniciando la aplicaci\u00f3n', QSystemTrayIcon.Information)\n            self.tray_icon.setToolTip(\"Programa Reloj de Asistencias\")  # Tooltip text\n\n            # Create a custom context menu\n            menu = QMenu()\n            menu.addAction(self.__create_action(\"Modificar dispositivos...\", lambda: self.__opt_modify_devices()))  # Action to modify devices\n            menu.addAction(self.__create_action(\"Reiniciar dispositivos...\", lambda: self.__opt_restart_devices()))  # Action to restart devices    \n            menu.addAction(self.__create_action(\"Probar conexiones...\", lambda: self.__opt_test_connections()))  # Action to test connections\n            menu.addAction(self.__create_action(\"Actualizar hora...\", lambda: self.__opt_update_devices_time()))  # Action to update device time\n            menu.addAction(self.__create_action(\"Obtener marcaciones...\", lambda: self.__opt_fetch_devices_attendances()))  # Action to fetch device attendances\n            menu.addSeparator()  # Context menu separator\n            # Checkbox as QAction with checkable state\n            clear_attendance_action = QAction(\"Eliminar marcaciones\", menu)\n            clear_attendance_action.setCheckable(True)  # Make the QAction checkable\n            clear_attendance_action.setChecked(self.checked_clear_attendance)  # Set initial checkbox state\n            clear_attendance_action.triggered.connect(self.__opt_toggle_checkbox_clear_attendance)  # Connect action to toggle checkbox state\n            menu.addAction(clear_attendance_action)  # Add action to the menu\n            # logging.debug(f'checked_automatic_init: {self.checked_automatic_init}')\n            # Action to toggle the checkbox state\n            automatic_init_action = QAction('Iniciar autom\u00e1ticamente', menu)\n            automatic_init_action.setCheckable(True)\n            automatic_init_action.setChecked(self.checked_automatic_init)\n            automatic_init_action.triggered.connect(self.__opt_toggle_checkbox_automatic_init)\n            menu.addAction(automatic_init_action)\n            menu.addSeparator()  # Context menu separator\n            menu.addAction(self.__create_action(\"Ver errores...\", lambda: self.__opt_show_logs()))  # Action to show logs\n            menu.addAction(self.__create_action(\"Salir\", lambda: self.__opt_exit_icon()))  # Action to exit the application\n            self.tray_icon.setContextMenu(menu)  # Assign context menu to the icon\n\n            self.tray_icon.show()  # Show the system tray icon\n        except Exception as e:\n            raise BaseError(3500, str(e), \"critical\")\n\n    def __create_action(self, text, function):\n        \"\"\"\n        Creates a QAction with the specified text and associates it with a function.\n\n        Args:\n            text (str): The display text for the action.\n            function (callable): The function to be executed when the action is triggered.\n\n        Returns:\n            (QAction): The created action with the specified text and connected function.\n        \"\"\"\n        action = QAction(text, self)  # Create QAction with the text and associated main window\n        action.triggered.connect(function)  # Connect the action to the provided function\n        return action  # Return the created action\n\n    def start_timer(self):\n        \"\"\"\n        Starts a timer by returning the current time in seconds.\n\n        Returns:\n            (float): The current time in seconds since the epoch.\n        \"\"\"\n        return time.time()  # Return the current time in seconds\n\n    def stop_timer(self, start_time):\n        \"\"\"\n        Stops the timer and calculates the elapsed time since the provided start time.\n\n        Args:\n            start_time (float): The starting time in seconds since the epoch.\n\n        Returns:\n            None\n\n        Logs:\n            Logs the elapsed time in seconds to the application log.\n\n        Side Effects:\n            Displays a system tray notification with the elapsed time.\n        \"\"\"\n        end_time = self.start_timer()  # Get the end time\n        elapsed_time = end_time - start_time  # Calculate the elapsed time\n        logging.info(f'La tarea finalizo en {elapsed_time:.2f} segundos')\n        self.tray_icon.showMessage(\"Notificacion\", f'La tarea finalizo en {elapsed_time:.2f} segundos', QSystemTrayIcon.Information)  # Show notification with the elapsed time\n\n    def __show_message_information(self, title, text):\n        \"\"\"\n        Displays an informational message dialog with a specified title and text.\n        This method creates a QMessageBox instance to show an informational message\n        to the user. It sets the title, text, and icon of the dialog box. Additionally,\n        it customizes the window icon using a specified `.ico` file. After the dialog\n        box is closed, it ensures that the tray icon's context menu is made visible again.\n\n        Args:\n            title (str): The title of the message dialog box.\n            text (str): The informational text to display in the dialog box.\n\n        Side Effects:\n            - Displays a QMessageBox with the specified title and text.\n            - Sets the window icon of the QMessageBox using a custom `.ico` file.\n            - Ensures the tray icon's context menu is visible after the dialog box is closed.\n        \"\"\"\n        msg_box = QMessageBox()  # Create QMessageBox instance\n        msg_box.setWindowTitle(title)  # Set the dialog box title\n        msg_box.setText(text)  # Set the message text\n        msg_box.setIcon(QMessageBox.Information)  # Set the dialog box icon (information)\n        file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"fingerprint.ico\")\n        msg_box.setWindowIcon(QIcon(file_path))\n        msg_box.exec_()  # Show the dialog box\n\n        # Once the QMessageBox is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n\n    @pyqtSlot()\n    def __opt_modify_devices(self):\n        \"\"\"\n        Handles the modification of devices through a dialog interface.\n\n        This method creates and displays a `ModifyDevicesDialog` for modifying device settings.\n        Once the dialog is closed, it ensures that the tray icon's context menu is visible again.\n        Any exceptions encountered during the process are logged using the `BaseError` class.\n\n        Raises:\n            BaseError: If an exception occurs during the execution of the method, it is wrapped\n                       and logged with an error code of 3500.\n        \"\"\"\n        try:\n            device_dialog = ModifyDevicesDialog()\n            device_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_show_logs(self):\n        \"\"\"\n        Displays the logs dialog and ensures the system tray context menu is visible after the dialog is closed.\n\n        This method attempts to create and display a `LogsDialog` instance. Once the dialog is closed, \n        it ensures that the system tray icon's context menu is made visible again. If an exception occurs \n        during this process, it is handled by logging the error using the `BaseError` class.\n\n        Raises:\n            Exception: If an error occurs while creating or displaying the `LogsDialog`.\n        \"\"\"\n        try:\n            error_log_dialog = LogsDialog()\n            error_log_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_restart_devices(self):\n        \"\"\"\n        Handles the restart devices operation by displaying a dialog to the user.\n\n        This method creates and executes a `RestartDevicesDialog` to allow the user\n        to restart devices. Once the dialog is closed, it ensures that the tray icon's\n        context menu is made visible again. If an exception occurs during the process,\n        it logs the error using the `BaseError` class.\n\n        Raises:\n            Exception: If an error occurs during the execution of the dialog or\n                       while handling the tray icon's context menu.\n        \"\"\"\n        try:\n            restart_devices_dialog = RestartDevicesDialog()\n            restart_devices_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_test_connections(self):\n        \"\"\"\n        Handles the testing of device connections by opening a dialog to ping devices.\n\n        This method creates and displays a `PingDevicesDialog` to check the status of devices.\n        Once the dialog is closed, it ensures that the tray icon's context menu is visible again.\n        If an exception occurs during the process, it logs the error using the `BaseError` class.\n\n        Raises:\n            Exception: If an error occurs during the execution of the method.\n        \"\"\"\n        try:\n            device_status_dialog = PingDevicesDialog()  # Get device status\n            device_status_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_update_devices_time(self):\n        \"\"\"\n        Handles the process of updating the time on devices.\n\n        This method creates and displays a dialog for updating the time on devices.\n        Once the dialog is closed, it ensures that the context menu of the tray icon\n        is made visible again if it exists. Any exceptions raised during the process\n        are caught and logged using the BaseError class.\n\n        Exceptions:\n            Exception: Catches any exception that occurs during the execution and\n                       logs it with an error code and message.\n        \"\"\"\n        try:\n            update_time_device_dialog = UpdateTimeDeviceDialog()\n            update_time_device_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_fetch_devices_attendances(self):\n        \"\"\"\n        Handles the process of fetching attendance data from devices.\n\n        This method creates and displays a dialog for obtaining attendance data\n        from devices. Once the dialog is closed, it ensures that the tray icon's\n        context menu is made visible again. Any exceptions encountered during the\n        process are captured and logged using the BaseError class.\n\n        Raises:\n            BaseError: If an exception occurs during the execution of the method.\n        \"\"\"\n        try:\n            device_attendances_dialog = ObtainAttendancesDevicesDialog()\n            #device_attendances_dialog.op_terminated.connect(self.stop_timer)\n            device_attendances_dialog.exec_()\n            # Once the QDialog is closed, show the context menu again\n            if self.tray_icon:\n                self.tray_icon.contextMenu().setVisible(True)\n        except Exception as e:\n            BaseError(3500, str(e))\n\n    @pyqtSlot()\n    def __opt_toggle_checkbox_clear_attendance(self):\n        \"\"\"\n        Toggles the state of the 'clear attendance' checkbox and updates the configuration file accordingly.\n\n        This method inverts the current state of the `checked_clear_attendance` attribute, updates the \n        corresponding value in the configuration file under the 'Device_config' section, and writes the \n        changes back to the file. If an error occurs during the file write operation, it raises a \n        `BaseError` with an appropriate error code and message.\n\n        Raises:\n            BaseError: If an exception occurs while writing to the configuration file.\n        \"\"\"\n        self.checked_clear_attendance = not self.checked_clear_attendance  # Invert the current checkbox state\n        # logging.debug(f\"Status checkbox: {self.checked_clear_attendance}\")  # Debug log: current checkbox state\n        # Modify the value of the desired field in the configuration file\n        config['Device_config']['clear_attendance'] = str(self.checked_clear_attendance)\n        # Write the changes back to the configuration file\n        try:\n            with open('config.ini', 'w') as config_file:\n                config.write(config_file)\n        except Exception as e:\n            BaseError(3001, str(e))\n\n    @pyqtSlot()\n    def __opt_toggle_checkbox_automatic_init(self):\n        \"\"\"\n        Toggles the state of the \"automatic initialization\" checkbox and updates the system's startup configuration\n        accordingly. This method is intended to be used in a frozen Python application (e.g., packaged with PyInstaller).\n        When the checkbox is toggled:\n\n        - If enabled, the application is added to the system's startup programs.\n        - If disabled, the application is removed from the system's startup programs.\n\n        Exceptions are caught and logged using the `BaseError` class.\n\n        Raises:\n            BaseError: If an exception occurs during the process, it is wrapped and raised with an error code (3000).\n\n        Notes:\n            - The `add_to_startup` and `remove_from_startup` functions are assumed to handle the actual system-level\n              operations for managing startup programs.\n            - This method only functions correctly in a frozen Python environment (e.g., when `sys.frozen` is True).\n        \"\"\"\n        import sys\n        try:\n            if getattr(sys, 'frozen', False):\n                self.checked_automatic_init = not self.checked_automatic_init  # Invert the current checkbox state\n                # logging.debug(f\"Status checkbox: {self.checked_automatic_init}\")  # Debug log: current checkbox state\n\n                if self.checked_automatic_init:\n                    # logging.debug('add_to_startup')\n                    add_to_startup(\"Programa Reloj de Asistencias\")\n                else:\n                    # logging.debug('remove_from_startup')\n                    remove_from_startup(\"Programa Reloj de Asistencias\")\n        except Exception as e:\n            BaseError(3000, str(e))\n\n    @pyqtSlot()\n    def __opt_exit_icon(self):\n        \"\"\"\n        Handles the exit operation for the application.\n\n        This method hides the system tray icon, if it exists, and then quits the application.\n\n        Returns:\n            None\n        \"\"\"\n        if self.tray_icon:\n            self.tray_icon.hide()  # Hide the system tray icon\n            QApplication.quit()  # Exit the application\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__create_action","title":"<code>__create_action(text, function)</code>","text":"<p>Creates a QAction with the specified text and associates it with a function.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The display text for the action.</p> required <code>function</code> <code>callable</code> <p>The function to be executed when the action is triggered.</p> required <p>Returns:</p> Type Description <code>QAction</code> <p>The created action with the specified text and connected function.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def __create_action(self, text, function):\n    \"\"\"\n    Creates a QAction with the specified text and associates it with a function.\n\n    Args:\n        text (str): The display text for the action.\n        function (callable): The function to be executed when the action is triggered.\n\n    Returns:\n        (QAction): The created action with the specified text and connected function.\n    \"\"\"\n    action = QAction(text, self)  # Create QAction with the text and associated main window\n    action.triggered.connect(function)  # Connect the action to the provided function\n    return action  # Return the created action\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__create_tray_icon","title":"<code>__create_tray_icon()</code>","text":"<p>Creates and configures the system tray icon for the application. This method initializes a QSystemTrayIcon with a tooltip and a custom context menu containing various actions for interacting with the application. The context menu includes options for modifying devices, restarting devices, testing connections, updating device time, fetching attendances, and toggling specific settings. It also provides options to view logs and exit the application. The tray icon displays a notification message upon initialization and is shown in the system tray.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the creation or configuration of the        system tray icon, it raises a BaseError with an error code and message.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def __create_tray_icon(self):\n    \"\"\"\n    Creates and configures the system tray icon for the application.\n    This method initializes a QSystemTrayIcon with a tooltip and a custom context menu\n    containing various actions for interacting with the application. The context menu\n    includes options for modifying devices, restarting devices, testing connections,\n    updating device time, fetching attendances, and toggling specific settings. It also\n    provides options to view logs and exit the application.\n    The tray icon displays a notification message upon initialization and is shown in\n    the system tray.\n\n    Raises:\n        BaseError: If an exception occurs during the creation or configuration of the\n                   system tray icon, it raises a BaseError with an error code and message.\n    \"\"\"\n    try:\n        file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"loading.png\")  # Icon file path\n        # logging.debug(file_path)\n        self.tray_icon = QSystemTrayIcon(QIcon(file_path), self)  # Create QSystemTrayIcon with the icon and associated main window\n        self.tray_icon.showMessage(\"Notificaci\u00f3n\", 'Iniciando la aplicaci\u00f3n', QSystemTrayIcon.Information)\n        self.tray_icon.setToolTip(\"Programa Reloj de Asistencias\")  # Tooltip text\n\n        # Create a custom context menu\n        menu = QMenu()\n        menu.addAction(self.__create_action(\"Modificar dispositivos...\", lambda: self.__opt_modify_devices()))  # Action to modify devices\n        menu.addAction(self.__create_action(\"Reiniciar dispositivos...\", lambda: self.__opt_restart_devices()))  # Action to restart devices    \n        menu.addAction(self.__create_action(\"Probar conexiones...\", lambda: self.__opt_test_connections()))  # Action to test connections\n        menu.addAction(self.__create_action(\"Actualizar hora...\", lambda: self.__opt_update_devices_time()))  # Action to update device time\n        menu.addAction(self.__create_action(\"Obtener marcaciones...\", lambda: self.__opt_fetch_devices_attendances()))  # Action to fetch device attendances\n        menu.addSeparator()  # Context menu separator\n        # Checkbox as QAction with checkable state\n        clear_attendance_action = QAction(\"Eliminar marcaciones\", menu)\n        clear_attendance_action.setCheckable(True)  # Make the QAction checkable\n        clear_attendance_action.setChecked(self.checked_clear_attendance)  # Set initial checkbox state\n        clear_attendance_action.triggered.connect(self.__opt_toggle_checkbox_clear_attendance)  # Connect action to toggle checkbox state\n        menu.addAction(clear_attendance_action)  # Add action to the menu\n        # logging.debug(f'checked_automatic_init: {self.checked_automatic_init}')\n        # Action to toggle the checkbox state\n        automatic_init_action = QAction('Iniciar autom\u00e1ticamente', menu)\n        automatic_init_action.setCheckable(True)\n        automatic_init_action.setChecked(self.checked_automatic_init)\n        automatic_init_action.triggered.connect(self.__opt_toggle_checkbox_automatic_init)\n        menu.addAction(automatic_init_action)\n        menu.addSeparator()  # Context menu separator\n        menu.addAction(self.__create_action(\"Ver errores...\", lambda: self.__opt_show_logs()))  # Action to show logs\n        menu.addAction(self.__create_action(\"Salir\", lambda: self.__opt_exit_icon()))  # Action to exit the application\n        self.tray_icon.setContextMenu(menu)  # Assign context menu to the icon\n\n        self.tray_icon.show()  # Show the system tray icon\n    except Exception as e:\n        raise BaseError(3500, str(e), \"critical\")\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the IconManager class. This constructor sets up the initial state of the application, including the system tray icon, configuration settings, and application startup behavior. It also handles potential duplicate instances of the application.</p> <p>Attributes:</p> Name Type Description <code>is_running</code> <code>bool</code> <p>Indicates if the application is currently running.</p> <code>checked_clear_attendance</code> <code>bool</code> <p>State of the \"clear attendance\" checkbox, retrieved from the configuration file.</p> <code>checked_automatic_init</code> <code>bool</code> <p>Indicates if the application is set to start automatically on system startup.</p> <code>tray_icon</code> <code>QSystemTrayIcon</code> <p>The system tray icon for the application.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with an error code, message, and severity level.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the IconManager class.\n    This constructor sets up the initial state of the application, including\n    the system tray icon, configuration settings, and application startup behavior.\n    It also handles potential duplicate instances of the application.\n\n    Attributes:\n        is_running (bool): Indicates if the application is currently running.\n        checked_clear_attendance (bool): State of the \"clear attendance\" checkbox,\n            retrieved from the configuration file.\n        checked_automatic_init (bool): Indicates if the application is set to start\n            automatically on system startup.\n        tray_icon (QSystemTrayIcon): The system tray icon for the application.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a\n            BaseError with an error code, message, and severity level.\n    \"\"\"\n    try:\n        super().__init__()\n        self.is_running = False  # Variable to indicate if the application is running\n        self.checked_clear_attendance = eval(config['Device_config']['clear_attendance'])  # State of the clear attendance checkbox\n        self.checked_automatic_init = is_startup_entry_exists(\"Programa Reloj de Asistencias\")\n\n        self.tray_icon: QSystemTrayIcon = None  # Variable to store the QSystemTrayIcon\n        self.__init_ui()  # Initialize the user interface\n\n        # Set the initial tray icon to loading.png\n        file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"loading.png\")  # Icon file path\n        # logging.debug(file_path)\n        self.tray_icon.setIcon(QIcon(file_path))\n\n        \"\"\" if not is_user_admin():\n            run_as_admin()\n        \"\"\"\n\n        #if verify_duplicated_instance(sys.argv[0]):\n        #    exit_duplicated_instance()\n\n        # Change the tray icon to program-icon.png after all initializations\n        file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"system_tray\", \"program-icon.png\")  # Icon file path\n        # logging.debug(file_path)\n        self.tray_icon.setIcon(QIcon(file_path))\n    except Exception as e:\n        raise BaseError(3501, str(e), \"critical\")\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__init_ui","title":"<code>__init_ui()</code>","text":"<p>Initializes the user interface components for the application.</p> <p>This method is responsible for setting up and configuring the system tray icon by invoking the necessary helper methods. It ensures that the system tray icon is properly created and ready for use.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def __init_ui(self):\n    \"\"\"\n    Initializes the user interface components for the application.\n\n    This method is responsible for setting up and configuring the system tray icon\n    by invoking the necessary helper methods. It ensures that the system tray icon\n    is properly created and ready for use.\n    \"\"\"\n    # Create and configure the system tray icon\n    self.__create_tray_icon()  # Create the system tray icon        \n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_exit_icon","title":"<code>__opt_exit_icon()</code>","text":"<p>Handles the exit operation for the application.</p> <p>This method hides the system tray icon, if it exists, and then quits the application.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_exit_icon(self):\n    \"\"\"\n    Handles the exit operation for the application.\n\n    This method hides the system tray icon, if it exists, and then quits the application.\n\n    Returns:\n        None\n    \"\"\"\n    if self.tray_icon:\n        self.tray_icon.hide()  # Hide the system tray icon\n        QApplication.quit()  # Exit the application\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_fetch_devices_attendances","title":"<code>__opt_fetch_devices_attendances()</code>","text":"<p>Handles the process of fetching attendance data from devices.</p> <p>This method creates and displays a dialog for obtaining attendance data from devices. Once the dialog is closed, it ensures that the tray icon's context menu is made visible again. Any exceptions encountered during the process are captured and logged using the BaseError class.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the execution of the method.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_fetch_devices_attendances(self):\n    \"\"\"\n    Handles the process of fetching attendance data from devices.\n\n    This method creates and displays a dialog for obtaining attendance data\n    from devices. Once the dialog is closed, it ensures that the tray icon's\n    context menu is made visible again. Any exceptions encountered during the\n    process are captured and logged using the BaseError class.\n\n    Raises:\n        BaseError: If an exception occurs during the execution of the method.\n    \"\"\"\n    try:\n        device_attendances_dialog = ObtainAttendancesDevicesDialog()\n        #device_attendances_dialog.op_terminated.connect(self.stop_timer)\n        device_attendances_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_modify_devices","title":"<code>__opt_modify_devices()</code>","text":"<p>Handles the modification of devices through a dialog interface.</p> <p>This method creates and displays a <code>ModifyDevicesDialog</code> for modifying device settings. Once the dialog is closed, it ensures that the tray icon's context menu is visible again. Any exceptions encountered during the process are logged using the <code>BaseError</code> class.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the execution of the method, it is wrapped        and logged with an error code of 3500.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_modify_devices(self):\n    \"\"\"\n    Handles the modification of devices through a dialog interface.\n\n    This method creates and displays a `ModifyDevicesDialog` for modifying device settings.\n    Once the dialog is closed, it ensures that the tray icon's context menu is visible again.\n    Any exceptions encountered during the process are logged using the `BaseError` class.\n\n    Raises:\n        BaseError: If an exception occurs during the execution of the method, it is wrapped\n                   and logged with an error code of 3500.\n    \"\"\"\n    try:\n        device_dialog = ModifyDevicesDialog()\n        device_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_restart_devices","title":"<code>__opt_restart_devices()</code>","text":"<p>Handles the restart devices operation by displaying a dialog to the user.</p> <p>This method creates and executes a <code>RestartDevicesDialog</code> to allow the user to restart devices. Once the dialog is closed, it ensures that the tray icon's context menu is made visible again. If an exception occurs during the process, it logs the error using the <code>BaseError</code> class.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during the execution of the dialog or        while handling the tray icon's context menu.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_restart_devices(self):\n    \"\"\"\n    Handles the restart devices operation by displaying a dialog to the user.\n\n    This method creates and executes a `RestartDevicesDialog` to allow the user\n    to restart devices. Once the dialog is closed, it ensures that the tray icon's\n    context menu is made visible again. If an exception occurs during the process,\n    it logs the error using the `BaseError` class.\n\n    Raises:\n        Exception: If an error occurs during the execution of the dialog or\n                   while handling the tray icon's context menu.\n    \"\"\"\n    try:\n        restart_devices_dialog = RestartDevicesDialog()\n        restart_devices_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_show_logs","title":"<code>__opt_show_logs()</code>","text":"<p>Displays the logs dialog and ensures the system tray context menu is visible after the dialog is closed.</p> <p>This method attempts to create and display a <code>LogsDialog</code> instance. Once the dialog is closed,  it ensures that the system tray icon's context menu is made visible again. If an exception occurs  during this process, it is handled by logging the error using the <code>BaseError</code> class.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs while creating or displaying the <code>LogsDialog</code>.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_show_logs(self):\n    \"\"\"\n    Displays the logs dialog and ensures the system tray context menu is visible after the dialog is closed.\n\n    This method attempts to create and display a `LogsDialog` instance. Once the dialog is closed, \n    it ensures that the system tray icon's context menu is made visible again. If an exception occurs \n    during this process, it is handled by logging the error using the `BaseError` class.\n\n    Raises:\n        Exception: If an error occurs while creating or displaying the `LogsDialog`.\n    \"\"\"\n    try:\n        error_log_dialog = LogsDialog()\n        error_log_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_test_connections","title":"<code>__opt_test_connections()</code>","text":"<p>Handles the testing of device connections by opening a dialog to ping devices.</p> <p>This method creates and displays a <code>PingDevicesDialog</code> to check the status of devices. Once the dialog is closed, it ensures that the tray icon's context menu is visible again. If an exception occurs during the process, it logs the error using the <code>BaseError</code> class.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during the execution of the method.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_test_connections(self):\n    \"\"\"\n    Handles the testing of device connections by opening a dialog to ping devices.\n\n    This method creates and displays a `PingDevicesDialog` to check the status of devices.\n    Once the dialog is closed, it ensures that the tray icon's context menu is visible again.\n    If an exception occurs during the process, it logs the error using the `BaseError` class.\n\n    Raises:\n        Exception: If an error occurs during the execution of the method.\n    \"\"\"\n    try:\n        device_status_dialog = PingDevicesDialog()  # Get device status\n        device_status_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_toggle_checkbox_automatic_init","title":"<code>__opt_toggle_checkbox_automatic_init()</code>","text":"<p>Toggles the state of the \"automatic initialization\" checkbox and updates the system's startup configuration accordingly. This method is intended to be used in a frozen Python application (e.g., packaged with PyInstaller). When the checkbox is toggled:</p> <ul> <li>If enabled, the application is added to the system's startup programs.</li> <li>If disabled, the application is removed from the system's startup programs.</li> </ul> <p>Exceptions are caught and logged using the <code>BaseError</code> class.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the process, it is wrapped and raised with an error code (3000).</p> Notes <ul> <li>The <code>add_to_startup</code> and <code>remove_from_startup</code> functions are assumed to handle the actual system-level   operations for managing startup programs.</li> <li>This method only functions correctly in a frozen Python environment (e.g., when <code>sys.frozen</code> is True).</li> </ul> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_toggle_checkbox_automatic_init(self):\n    \"\"\"\n    Toggles the state of the \"automatic initialization\" checkbox and updates the system's startup configuration\n    accordingly. This method is intended to be used in a frozen Python application (e.g., packaged with PyInstaller).\n    When the checkbox is toggled:\n\n    - If enabled, the application is added to the system's startup programs.\n    - If disabled, the application is removed from the system's startup programs.\n\n    Exceptions are caught and logged using the `BaseError` class.\n\n    Raises:\n        BaseError: If an exception occurs during the process, it is wrapped and raised with an error code (3000).\n\n    Notes:\n        - The `add_to_startup` and `remove_from_startup` functions are assumed to handle the actual system-level\n          operations for managing startup programs.\n        - This method only functions correctly in a frozen Python environment (e.g., when `sys.frozen` is True).\n    \"\"\"\n    import sys\n    try:\n        if getattr(sys, 'frozen', False):\n            self.checked_automatic_init = not self.checked_automatic_init  # Invert the current checkbox state\n            # logging.debug(f\"Status checkbox: {self.checked_automatic_init}\")  # Debug log: current checkbox state\n\n            if self.checked_automatic_init:\n                # logging.debug('add_to_startup')\n                add_to_startup(\"Programa Reloj de Asistencias\")\n            else:\n                # logging.debug('remove_from_startup')\n                remove_from_startup(\"Programa Reloj de Asistencias\")\n    except Exception as e:\n        BaseError(3000, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_toggle_checkbox_clear_attendance","title":"<code>__opt_toggle_checkbox_clear_attendance()</code>","text":"<p>Toggles the state of the 'clear attendance' checkbox and updates the configuration file accordingly.</p> <p>This method inverts the current state of the <code>checked_clear_attendance</code> attribute, updates the  corresponding value in the configuration file under the 'Device_config' section, and writes the  changes back to the file. If an error occurs during the file write operation, it raises a  <code>BaseError</code> with an appropriate error code and message.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs while writing to the configuration file.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_toggle_checkbox_clear_attendance(self):\n    \"\"\"\n    Toggles the state of the 'clear attendance' checkbox and updates the configuration file accordingly.\n\n    This method inverts the current state of the `checked_clear_attendance` attribute, updates the \n    corresponding value in the configuration file under the 'Device_config' section, and writes the \n    changes back to the file. If an error occurs during the file write operation, it raises a \n    `BaseError` with an appropriate error code and message.\n\n    Raises:\n        BaseError: If an exception occurs while writing to the configuration file.\n    \"\"\"\n    self.checked_clear_attendance = not self.checked_clear_attendance  # Invert the current checkbox state\n    # logging.debug(f\"Status checkbox: {self.checked_clear_attendance}\")  # Debug log: current checkbox state\n    # Modify the value of the desired field in the configuration file\n    config['Device_config']['clear_attendance'] = str(self.checked_clear_attendance)\n    # Write the changes back to the configuration file\n    try:\n        with open('config.ini', 'w') as config_file:\n            config.write(config_file)\n    except Exception as e:\n        BaseError(3001, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__opt_update_devices_time","title":"<code>__opt_update_devices_time()</code>","text":"<p>Handles the process of updating the time on devices.</p> <p>This method creates and displays a dialog for updating the time on devices. Once the dialog is closed, it ensures that the context menu of the tray icon is made visible again if it exists. Any exceptions raised during the process are caught and logged using the BaseError class.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Catches any exception that occurs during the execution and        logs it with an error code and message.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>@pyqtSlot()\ndef __opt_update_devices_time(self):\n    \"\"\"\n    Handles the process of updating the time on devices.\n\n    This method creates and displays a dialog for updating the time on devices.\n    Once the dialog is closed, it ensures that the context menu of the tray icon\n    is made visible again if it exists. Any exceptions raised during the process\n    are caught and logged using the BaseError class.\n\n    Exceptions:\n        Exception: Catches any exception that occurs during the execution and\n                   logs it with an error code and message.\n    \"\"\"\n    try:\n        update_time_device_dialog = UpdateTimeDeviceDialog()\n        update_time_device_dialog.exec_()\n        # Once the QDialog is closed, show the context menu again\n        if self.tray_icon:\n            self.tray_icon.contextMenu().setVisible(True)\n    except Exception as e:\n        BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.__show_message_information","title":"<code>__show_message_information(title, text)</code>","text":"<p>Displays an informational message dialog with a specified title and text. This method creates a QMessageBox instance to show an informational message to the user. It sets the title, text, and icon of the dialog box. Additionally, it customizes the window icon using a specified <code>.ico</code> file. After the dialog box is closed, it ensures that the tray icon's context menu is made visible again.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the message dialog box.</p> required <code>text</code> <code>str</code> <p>The informational text to display in the dialog box.</p> required Side Effects <ul> <li>Displays a QMessageBox with the specified title and text.</li> <li>Sets the window icon of the QMessageBox using a custom <code>.ico</code> file.</li> <li>Ensures the tray icon's context menu is visible after the dialog box is closed.</li> </ul> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def __show_message_information(self, title, text):\n    \"\"\"\n    Displays an informational message dialog with a specified title and text.\n    This method creates a QMessageBox instance to show an informational message\n    to the user. It sets the title, text, and icon of the dialog box. Additionally,\n    it customizes the window icon using a specified `.ico` file. After the dialog\n    box is closed, it ensures that the tray icon's context menu is made visible again.\n\n    Args:\n        title (str): The title of the message dialog box.\n        text (str): The informational text to display in the dialog box.\n\n    Side Effects:\n        - Displays a QMessageBox with the specified title and text.\n        - Sets the window icon of the QMessageBox using a custom `.ico` file.\n        - Ensures the tray icon's context menu is visible after the dialog box is closed.\n    \"\"\"\n    msg_box = QMessageBox()  # Create QMessageBox instance\n    msg_box.setWindowTitle(title)  # Set the dialog box title\n    msg_box.setText(text)  # Set the message text\n    msg_box.setIcon(QMessageBox.Information)  # Set the dialog box icon (information)\n    file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"fingerprint.ico\")\n    msg_box.setWindowIcon(QIcon(file_path))\n    msg_box.exec_()  # Show the dialog box\n\n    # Once the QMessageBox is closed, show the context menu again\n    if self.tray_icon:\n        self.tray_icon.contextMenu().setVisible(True)\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.start_timer","title":"<code>start_timer()</code>","text":"<p>Starts a timer by returning the current time in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current time in seconds since the epoch.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def start_timer(self):\n    \"\"\"\n    Starts a timer by returning the current time in seconds.\n\n    Returns:\n        (float): The current time in seconds since the epoch.\n    \"\"\"\n    return time.time()  # Return the current time in seconds\n</code></pre>"},{"location":"api/#src.ui.icon_manager.MainWindow.stop_timer","title":"<code>stop_timer(start_time)</code>","text":"<p>Stops the timer and calculates the elapsed time since the provided start time.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>float</code> <p>The starting time in seconds since the epoch.</p> required <p>Returns:</p> Type Description <p>None</p> Logs <p>Logs the elapsed time in seconds to the application log.</p> Side Effects <p>Displays a system tray notification with the elapsed time.</p> Source code in <code>src\\ui\\icon_manager.py</code> <pre><code>def stop_timer(self, start_time):\n    \"\"\"\n    Stops the timer and calculates the elapsed time since the provided start time.\n\n    Args:\n        start_time (float): The starting time in seconds since the epoch.\n\n    Returns:\n        None\n\n    Logs:\n        Logs the elapsed time in seconds to the application log.\n\n    Side Effects:\n        Displays a system tray notification with the elapsed time.\n    \"\"\"\n    end_time = self.start_timer()  # Get the end time\n    elapsed_time = end_time - start_time  # Calculate the elapsed time\n    logging.info(f'La tarea finalizo en {elapsed_time:.2f} segundos')\n    self.tray_icon.showMessage(\"Notificacion\", f'La tarea finalizo en {elapsed_time:.2f} segundos', QSystemTrayIcon.Information)  # Show notification with the elapsed time\n</code></pre>"},{"location":"api/#src.ui.logs_dialog","title":"<code>logs_dialog</code>","text":""},{"location":"api/#src.ui.logs_dialog.LogsDialog","title":"<code>LogsDialog</code>","text":"<p>               Bases: <code>BaseDialog</code></p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>class LogsDialog(BaseDialog):\n    def __init__(self):\n        \"\"\"\n        Initializes the LogsDialog class.\n\n        This constructor sets up the LogsDialog instance by calling the parent\n        class initializer with a specific window title, initializing the user\n        interface, and handling any exceptions that may occur during the process.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it is wrapped\n                       in a BaseError with code 3501 and the exception message.\n        \"\"\"\n        try:\n            super().__init__(window_title=\"VISOR DE LOGS\")\n            self.init_ui()\n            super().init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the logs dialog.\n        This method sets up the UI components, including date selection widgets, \n        text search filter, error and source selection lists, and a text display \n        area for logs. It also configures the layout and connects signals to \n        dynamically filter logs based on user input.\n\n        UI Components:\n            - Date Selection Widgets:\n                * `start_date_edit`: QDateEdit for selecting the start date.\n                * `end_date_edit`: QDateEdit for selecting the end date.\n            - Text Search Filter:\n                * `text_search_edit`: QLineEdit for searching text in logs.\n            - Error Selection List:\n                * `error_list`: QListWidget for selecting error codes to filter logs.\n            - Source Selection List:\n                * `source_list`: QListWidget for selecting log sources to filter logs.\n            - Toggle Filter Button:\n                * `toggle_filter_button`: QPushButton to toggle the visibility of \n                  error and source filter lists.\n            - Labels:\n                * `select_errors_label`: QLabel for error filter instructions.\n                * `select_sources_label`: QLabel for source filter instructions.\n            - Logs Display:\n                * `text_edit`: QTextEdit for displaying filtered logs.\n\n        Layout:\n            - `filter_layout`: Horizontal layout for date selection, text search, \n              and toggle filter button.\n            - `error_list_layout`: Vertical layout for error filter label and list.\n            - `source_list_layout`: Vertical layout for source filter label and list.\n            - `filter_lists_layout`: Horizontal layout combining error and source \n              filter layouts.\n            - `layout`: Main vertical layout combining all components.\n\n        Behavior:\n            - Connects signals to dynamically filter logs when:\n                * Dates are changed.\n                * Text is entered in the search field.\n                * Error or source selections are modified.\n            - Loads logs at startup.\n\n        Raises:\n            BaseError: If an exception occurs during UI initialization.\n        \"\"\"\n        try:\n            # Date selection widgets\n            self.start_date_edit = QDateEdit(self)\n            self.start_date_edit.setCalendarPopup(True)\n            self.start_date_edit.setDate(QDate.currentDate().addMonths(-1))\n            self.start_date_edit.editingFinished.connect(self.load_logs)  # Dynamic filtering on date change\n\n            self.end_date_edit = QDateEdit(self)\n            self.end_date_edit.setCalendarPopup(True)\n            self.end_date_edit.setDate(QDate.currentDate())\n            self.end_date_edit.editingFinished.connect(self.load_logs)  # Dynamic filtering on date change\n\n            # Text search filter\n            self.text_search_edit = QLineEdit(self)\n            self.text_search_edit.setPlaceholderText(\"Buscar texto en los logs...\")\n            self.text_search_edit.textChanged.connect(self.load_logs)  # Dynamic filtering on text change\n\n            # Error selection list (initially hidden)\n            self.error_list = QListWidget(self)\n            self.error_list.setSelectionMode(QListWidget.MultiSelection)\n            self.error_list.setVisible(False)  # Initially hide the error list\n            self.error_list.itemSelectionChanged.connect(self.load_logs)  # Dynamic filtering on selection change\n\n            for code, description in ERROR_CODES_DICT.items():\n                item = QListWidgetItem(f\"[{code}] {description}\")\n                item.setData(1, code)  # Store only the error code as data\n                self.error_list.addItem(item)\n\n            # Source selection list\n            self.source_list = QListWidget(self)\n            self.source_list.setSelectionMode(QListWidget.MultiSelection)\n            self.source_list.setVisible(False)  # Initially hide the source list\n            self.source_list.itemSelectionChanged.connect(self.load_logs)  # Dynamic filtering on selection change\n\n            sources = [\"programa\", \"icono\", \"servicio\"]\n            for source in sources:\n                item = QListWidgetItem(source)\n                item.setData(1, source)  # Store the source as data\n                self.source_list.addItem(item)\n\n            # Button to toggle the filter lists visibility with an SVG icon\n            self.toggle_filter_button = QPushButton(self)\n            self.file_path_filter = os.path.join(self.file_path_resources, \"window\", \"filter-right.svg\")\n            self.toggle_filter_button.setIcon(QIcon(self.file_path_filter))  # Set SVG icon\n            self.toggle_filter_button.clicked.connect(self.toggle_filter_visibility)\n\n            self.select_errors_label = QLabel(\"Selecciona los errores a filtrar (vac\u00edo = todos):\")\n            self.select_errors_label.setVisible(False)\n\n            self.select_sources_label = QLabel(\"Selecciona las fuentes a filtrar (vac\u00edo = todas):\")\n            self.select_sources_label.setVisible(False)\n\n            # Layout for filters\n            filter_layout = QHBoxLayout()\n            filter_layout.addWidget(QLabel(\"Desde:\"))\n            filter_layout.addWidget(self.start_date_edit)\n            filter_layout.addWidget(QLabel(\"Hasta:\"))\n            filter_layout.addWidget(self.end_date_edit)\n            filter_layout.addWidget(QLabel(\"Buscar:\"))\n            filter_layout.addWidget(self.text_search_edit)\n            filter_layout.addWidget(self.toggle_filter_button)  # Button to toggle the filter lists\n\n            # Layout for error list\n            error_list_layout = QVBoxLayout()\n            error_list_layout.addWidget(self.select_errors_label)\n            error_list_layout.addWidget(self.error_list)\n            error_list_layout.setStretch(0, 0)\n            error_list_layout.setStretch(1, 1)\n\n            # Layout for source list\n            source_list_layout = QVBoxLayout()\n            source_list_layout.addWidget(self.select_sources_label)\n            source_list_layout.addWidget(self.source_list)\n            source_list_layout.setStretch(0, 0)\n            source_list_layout.setStretch(1, 1)\n\n            # Combine error and source list layouts\n            filter_lists_layout = QHBoxLayout()\n            filter_lists_layout.addLayout(error_list_layout)\n            filter_lists_layout.addLayout(source_list_layout)\n\n            # Text widget to display logs\n            self.text_edit = QTextEdit(self)\n            self.text_edit.setReadOnly(True)\n\n            # Main layout\n            layout = QVBoxLayout()\n            layout.addLayout(filter_layout)\n            layout.addLayout(filter_lists_layout)\n            layout.addWidget(self.text_edit)\n            self.setLayout(layout)\n            layout.setStretch(0, 0)  # filter_layout takes only the space it needs\n            layout.setStretch(1, 0)  # filter_lists_layout takes only the space it needs\n            layout.setStretch(2, 1)  # text_edit (logs) expands to fill the remaining space\n\n            # Load logs at startup\n            self.load_logs()\n        except Exception as e:\n            raise BaseError(3501, str(e), parent=self)\n\n    def toggle_filter_visibility(self):\n        \"\"\"\n        Toggles the visibility of filter-related UI elements in the logs dialog.\n\n        This method switches the visibility state of the following elements:\n            - `select_errors_label`\n            - `error_list`\n            - `select_sources_label`\n            - `source_list`\n\n        If an exception occurs during the process, it raises a `BaseError` with\n        an error code of 3500 and the exception message.\n\n        Raises:\n            BaseError: If an exception occurs while toggling visibility.\n        \"\"\"\n        try:\n            self.select_errors_label.setVisible(not self.select_errors_label.isVisible())\n            self.error_list.setVisible(not self.error_list.isVisible())\n            self.select_sources_label.setVisible(not self.select_sources_label.isVisible())\n            self.source_list.setVisible(not self.source_list.isVisible())\n        except Exception as e:\n            raise BaseError(3500, str(e))\n\n    def load_logs(self):\n        \"\"\"\n        Loads and displays error logs based on the specified filters.\n\n        This method retrieves error logs within a specified date range, \n        filtered by selected error types, sources, and a search text. \n\n        The logs are then displayed in a text editor.\n\n        Raises:\n            BaseError: If an exception occurs during the log retrieval process.\n\n        Filters:\n            - Date range: Defined by `start_date_edit` and `end_date_edit`.\n            - Error types: Selected items in `error_list`.\n            - Sources: Selected items in `source_list`.\n            - Search text: Text entered in `text_search_edit`.\n\n        Steps:\n            1. Retrieve the start and end dates from the date edit widgets.\n            2. Get the search text and convert it to lowercase.\n            3. Collect selected error types and sources from their respective lists.\n            4. Fetch the filtered error logs using `get_error_logs`.\n            5. Display the logs in the `text_edit` widget.\n\n        Note:\n            Ensure that the `get_error_logs` method is implemented to handle \n            the filtering logic and return the appropriate logs.\n        \"\"\"\n        try:\n            start_date = self.start_date_edit.date().toString(\"yyyy-MM-dd\")\n            end_date = self.end_date_edit.date().toString(\"yyyy-MM-dd\")\n            search_text = self.text_search_edit.text().lower()\n\n            selected_errors = {item.data(1) for item in self.error_list.selectedItems()}\n            selected_sources = {item.data(1) for item in self.source_list.selectedItems()}\n\n            error_logs = self.get_error_logs(start_date, end_date, selected_errors, selected_sources, search_text)\n            self.text_edit.setPlainText(\"\\n\".join(error_logs))\n        except Exception as e:\n            raise BaseError(3500, str(e))\n\n    def get_error_logs(self, start_date, end_date, selected_errors, selected_sources, search_text):\n        \"\"\"\n        Retrieves error log entries from log files within a specified date range, filtered by error codes, sources, \n        and optional search text.\n\n        Args:\n            start_date (str): The start date in the format 'YYYY-MM-DD' to filter log entries.\n            end_date (str): The end date in the format 'YYYY-MM-DD' to filter log entries.\n            selected_errors (list): A list of error codes to filter log entries. If empty, all error codes are included.\n            selected_sources (list): A list of sources to filter log entries. If empty, all sources are included.\n            search_text (str): Optional text to search within log entries. If empty, no search filtering is applied.\n\n        Returns:\n            (list): A list of formatted error log entries that match the specified filters, sorted by date and time.\n\n        Raises:\n            BaseError: If an exception occurs during log processing, it raises a BaseError with code 3500 and the error message.\n        \"\"\"\n        try:\n            error_entries = []\n\n            pattern = re.compile(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3}) - \\w+ - \\[(\\d{4})\\]\")  # Capture date, time, and error code\n\n            log_files = {\n                \"programa\": \"programa_reloj_de_asistencias_\" + PROGRAM_VERSION + \"_error.log\",\n                \"icono\": \"icono_reloj_de_asistencias_\" + SERVICE_VERSION + \"_error.log\",\n                \"servicio\": \"servicio_reloj_de_asistencias_\" + SERVICE_VERSION + \"_error.log\"\n            }\n\n            for folder in os.listdir(LOGS_DIR):\n                folder_path = os.path.join(LOGS_DIR, folder)\n                if os.path.isdir(folder_path):\n                    for source, log_file in log_files.items():\n                        if selected_sources and source not in selected_sources:\n                            continue\n                        log_path = os.path.join(folder_path, log_file)\n                        if os.path.exists(log_path):\n                            with open(log_path, \"r\", encoding=\"utf-8\", errors=\"replace\") as log_file:\n                                for line in log_file:\n                                    match = pattern.search(line)\n                                    if match:\n                                        log_datetime, error_code = match.groups()\n                                        log_date = log_datetime.split()[0]\n                                        if start_date &lt;= log_date &lt;= end_date:\n                                            # Show all errors if none are selected, otherwise filter\n                                            if (not selected_errors or error_code in selected_errors) and (not search_text or search_text in line.lower()):\n                                                error_entries.append(f\"{source}: {line.strip()}\")\n\n            # Sort the entries by date and time\n            error_entries.sort(key=lambda x: re.search(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3})\", x).group(1))\n\n            return error_entries\n        except Exception as e:\n            raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.logs_dialog.LogsDialog.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the LogsDialog class.</p> <p>This constructor sets up the LogsDialog instance by calling the parent class initializer with a specific window title, initializing the user interface, and handling any exceptions that may occur during the process.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it is wrapped        in a BaseError with code 3501 and the exception message.</p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the LogsDialog class.\n\n    This constructor sets up the LogsDialog instance by calling the parent\n    class initializer with a specific window title, initializing the user\n    interface, and handling any exceptions that may occur during the process.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it is wrapped\n                   in a BaseError with code 3501 and the exception message.\n    \"\"\"\n    try:\n        super().__init__(window_title=\"VISOR DE LOGS\")\n        self.init_ui()\n        super().init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.logs_dialog.LogsDialog.get_error_logs","title":"<code>get_error_logs(start_date, end_date, selected_errors, selected_sources, search_text)</code>","text":"<p>Retrieves error log entries from log files within a specified date range, filtered by error codes, sources,  and optional search text.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date in the format 'YYYY-MM-DD' to filter log entries.</p> required <code>end_date</code> <code>str</code> <p>The end date in the format 'YYYY-MM-DD' to filter log entries.</p> required <code>selected_errors</code> <code>list</code> <p>A list of error codes to filter log entries. If empty, all error codes are included.</p> required <code>selected_sources</code> <code>list</code> <p>A list of sources to filter log entries. If empty, all sources are included.</p> required <code>search_text</code> <code>str</code> <p>Optional text to search within log entries. If empty, no search filtering is applied.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of formatted error log entries that match the specified filters, sorted by date and time.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during log processing, it raises a BaseError with code 3500 and the error message.</p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>def get_error_logs(self, start_date, end_date, selected_errors, selected_sources, search_text):\n    \"\"\"\n    Retrieves error log entries from log files within a specified date range, filtered by error codes, sources, \n    and optional search text.\n\n    Args:\n        start_date (str): The start date in the format 'YYYY-MM-DD' to filter log entries.\n        end_date (str): The end date in the format 'YYYY-MM-DD' to filter log entries.\n        selected_errors (list): A list of error codes to filter log entries. If empty, all error codes are included.\n        selected_sources (list): A list of sources to filter log entries. If empty, all sources are included.\n        search_text (str): Optional text to search within log entries. If empty, no search filtering is applied.\n\n    Returns:\n        (list): A list of formatted error log entries that match the specified filters, sorted by date and time.\n\n    Raises:\n        BaseError: If an exception occurs during log processing, it raises a BaseError with code 3500 and the error message.\n    \"\"\"\n    try:\n        error_entries = []\n\n        pattern = re.compile(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3}) - \\w+ - \\[(\\d{4})\\]\")  # Capture date, time, and error code\n\n        log_files = {\n            \"programa\": \"programa_reloj_de_asistencias_\" + PROGRAM_VERSION + \"_error.log\",\n            \"icono\": \"icono_reloj_de_asistencias_\" + SERVICE_VERSION + \"_error.log\",\n            \"servicio\": \"servicio_reloj_de_asistencias_\" + SERVICE_VERSION + \"_error.log\"\n        }\n\n        for folder in os.listdir(LOGS_DIR):\n            folder_path = os.path.join(LOGS_DIR, folder)\n            if os.path.isdir(folder_path):\n                for source, log_file in log_files.items():\n                    if selected_sources and source not in selected_sources:\n                        continue\n                    log_path = os.path.join(folder_path, log_file)\n                    if os.path.exists(log_path):\n                        with open(log_path, \"r\", encoding=\"utf-8\", errors=\"replace\") as log_file:\n                            for line in log_file:\n                                match = pattern.search(line)\n                                if match:\n                                    log_datetime, error_code = match.groups()\n                                    log_date = log_datetime.split()[0]\n                                    if start_date &lt;= log_date &lt;= end_date:\n                                        # Show all errors if none are selected, otherwise filter\n                                        if (not selected_errors or error_code in selected_errors) and (not search_text or search_text in line.lower()):\n                                            error_entries.append(f\"{source}: {line.strip()}\")\n\n        # Sort the entries by date and time\n        error_entries.sort(key=lambda x: re.search(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3})\", x).group(1))\n\n        return error_entries\n    except Exception as e:\n        raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.logs_dialog.LogsDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the logs dialog. This method sets up the UI components, including date selection widgets,  text search filter, error and source selection lists, and a text display  area for logs. It also configures the layout and connects signals to  dynamically filter logs based on user input.</p> UI Components <ul> <li>Date Selection Widgets:<ul> <li><code>start_date_edit</code>: QDateEdit for selecting the start date.</li> <li><code>end_date_edit</code>: QDateEdit for selecting the end date.</li> </ul> </li> <li>Text Search Filter:<ul> <li><code>text_search_edit</code>: QLineEdit for searching text in logs.</li> </ul> </li> <li>Error Selection List:<ul> <li><code>error_list</code>: QListWidget for selecting error codes to filter logs.</li> </ul> </li> <li>Source Selection List:<ul> <li><code>source_list</code>: QListWidget for selecting log sources to filter logs.</li> </ul> </li> <li>Toggle Filter Button:<ul> <li><code>toggle_filter_button</code>: QPushButton to toggle the visibility of    error and source filter lists.</li> </ul> </li> <li>Labels:<ul> <li><code>select_errors_label</code>: QLabel for error filter instructions.</li> <li><code>select_sources_label</code>: QLabel for source filter instructions.</li> </ul> </li> <li>Logs Display:<ul> <li><code>text_edit</code>: QTextEdit for displaying filtered logs.</li> </ul> </li> </ul> Layout <ul> <li><code>filter_layout</code>: Horizontal layout for date selection, text search,    and toggle filter button.</li> <li><code>error_list_layout</code>: Vertical layout for error filter label and list.</li> <li><code>source_list_layout</code>: Vertical layout for source filter label and list.</li> <li><code>filter_lists_layout</code>: Horizontal layout combining error and source    filter layouts.</li> <li><code>layout</code>: Main vertical layout combining all components.</li> </ul> Behavior <ul> <li>Connects signals to dynamically filter logs when:<ul> <li>Dates are changed.</li> <li>Text is entered in the search field.</li> <li>Error or source selections are modified.</li> </ul> </li> <li>Loads logs at startup.</li> </ul> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during UI initialization.</p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the logs dialog.\n    This method sets up the UI components, including date selection widgets, \n    text search filter, error and source selection lists, and a text display \n    area for logs. It also configures the layout and connects signals to \n    dynamically filter logs based on user input.\n\n    UI Components:\n        - Date Selection Widgets:\n            * `start_date_edit`: QDateEdit for selecting the start date.\n            * `end_date_edit`: QDateEdit for selecting the end date.\n        - Text Search Filter:\n            * `text_search_edit`: QLineEdit for searching text in logs.\n        - Error Selection List:\n            * `error_list`: QListWidget for selecting error codes to filter logs.\n        - Source Selection List:\n            * `source_list`: QListWidget for selecting log sources to filter logs.\n        - Toggle Filter Button:\n            * `toggle_filter_button`: QPushButton to toggle the visibility of \n              error and source filter lists.\n        - Labels:\n            * `select_errors_label`: QLabel for error filter instructions.\n            * `select_sources_label`: QLabel for source filter instructions.\n        - Logs Display:\n            * `text_edit`: QTextEdit for displaying filtered logs.\n\n    Layout:\n        - `filter_layout`: Horizontal layout for date selection, text search, \n          and toggle filter button.\n        - `error_list_layout`: Vertical layout for error filter label and list.\n        - `source_list_layout`: Vertical layout for source filter label and list.\n        - `filter_lists_layout`: Horizontal layout combining error and source \n          filter layouts.\n        - `layout`: Main vertical layout combining all components.\n\n    Behavior:\n        - Connects signals to dynamically filter logs when:\n            * Dates are changed.\n            * Text is entered in the search field.\n            * Error or source selections are modified.\n        - Loads logs at startup.\n\n    Raises:\n        BaseError: If an exception occurs during UI initialization.\n    \"\"\"\n    try:\n        # Date selection widgets\n        self.start_date_edit = QDateEdit(self)\n        self.start_date_edit.setCalendarPopup(True)\n        self.start_date_edit.setDate(QDate.currentDate().addMonths(-1))\n        self.start_date_edit.editingFinished.connect(self.load_logs)  # Dynamic filtering on date change\n\n        self.end_date_edit = QDateEdit(self)\n        self.end_date_edit.setCalendarPopup(True)\n        self.end_date_edit.setDate(QDate.currentDate())\n        self.end_date_edit.editingFinished.connect(self.load_logs)  # Dynamic filtering on date change\n\n        # Text search filter\n        self.text_search_edit = QLineEdit(self)\n        self.text_search_edit.setPlaceholderText(\"Buscar texto en los logs...\")\n        self.text_search_edit.textChanged.connect(self.load_logs)  # Dynamic filtering on text change\n\n        # Error selection list (initially hidden)\n        self.error_list = QListWidget(self)\n        self.error_list.setSelectionMode(QListWidget.MultiSelection)\n        self.error_list.setVisible(False)  # Initially hide the error list\n        self.error_list.itemSelectionChanged.connect(self.load_logs)  # Dynamic filtering on selection change\n\n        for code, description in ERROR_CODES_DICT.items():\n            item = QListWidgetItem(f\"[{code}] {description}\")\n            item.setData(1, code)  # Store only the error code as data\n            self.error_list.addItem(item)\n\n        # Source selection list\n        self.source_list = QListWidget(self)\n        self.source_list.setSelectionMode(QListWidget.MultiSelection)\n        self.source_list.setVisible(False)  # Initially hide the source list\n        self.source_list.itemSelectionChanged.connect(self.load_logs)  # Dynamic filtering on selection change\n\n        sources = [\"programa\", \"icono\", \"servicio\"]\n        for source in sources:\n            item = QListWidgetItem(source)\n            item.setData(1, source)  # Store the source as data\n            self.source_list.addItem(item)\n\n        # Button to toggle the filter lists visibility with an SVG icon\n        self.toggle_filter_button = QPushButton(self)\n        self.file_path_filter = os.path.join(self.file_path_resources, \"window\", \"filter-right.svg\")\n        self.toggle_filter_button.setIcon(QIcon(self.file_path_filter))  # Set SVG icon\n        self.toggle_filter_button.clicked.connect(self.toggle_filter_visibility)\n\n        self.select_errors_label = QLabel(\"Selecciona los errores a filtrar (vac\u00edo = todos):\")\n        self.select_errors_label.setVisible(False)\n\n        self.select_sources_label = QLabel(\"Selecciona las fuentes a filtrar (vac\u00edo = todas):\")\n        self.select_sources_label.setVisible(False)\n\n        # Layout for filters\n        filter_layout = QHBoxLayout()\n        filter_layout.addWidget(QLabel(\"Desde:\"))\n        filter_layout.addWidget(self.start_date_edit)\n        filter_layout.addWidget(QLabel(\"Hasta:\"))\n        filter_layout.addWidget(self.end_date_edit)\n        filter_layout.addWidget(QLabel(\"Buscar:\"))\n        filter_layout.addWidget(self.text_search_edit)\n        filter_layout.addWidget(self.toggle_filter_button)  # Button to toggle the filter lists\n\n        # Layout for error list\n        error_list_layout = QVBoxLayout()\n        error_list_layout.addWidget(self.select_errors_label)\n        error_list_layout.addWidget(self.error_list)\n        error_list_layout.setStretch(0, 0)\n        error_list_layout.setStretch(1, 1)\n\n        # Layout for source list\n        source_list_layout = QVBoxLayout()\n        source_list_layout.addWidget(self.select_sources_label)\n        source_list_layout.addWidget(self.source_list)\n        source_list_layout.setStretch(0, 0)\n        source_list_layout.setStretch(1, 1)\n\n        # Combine error and source list layouts\n        filter_lists_layout = QHBoxLayout()\n        filter_lists_layout.addLayout(error_list_layout)\n        filter_lists_layout.addLayout(source_list_layout)\n\n        # Text widget to display logs\n        self.text_edit = QTextEdit(self)\n        self.text_edit.setReadOnly(True)\n\n        # Main layout\n        layout = QVBoxLayout()\n        layout.addLayout(filter_layout)\n        layout.addLayout(filter_lists_layout)\n        layout.addWidget(self.text_edit)\n        self.setLayout(layout)\n        layout.setStretch(0, 0)  # filter_layout takes only the space it needs\n        layout.setStretch(1, 0)  # filter_lists_layout takes only the space it needs\n        layout.setStretch(2, 1)  # text_edit (logs) expands to fill the remaining space\n\n        # Load logs at startup\n        self.load_logs()\n    except Exception as e:\n        raise BaseError(3501, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.logs_dialog.LogsDialog.load_logs","title":"<code>load_logs()</code>","text":"<p>Loads and displays error logs based on the specified filters.</p> <p>This method retrieves error logs within a specified date range,  filtered by selected error types, sources, and a search text. </p> <p>The logs are then displayed in a text editor.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the log retrieval process.</p> Filters <ul> <li>Date range: Defined by <code>start_date_edit</code> and <code>end_date_edit</code>.</li> <li>Error types: Selected items in <code>error_list</code>.</li> <li>Sources: Selected items in <code>source_list</code>.</li> <li>Search text: Text entered in <code>text_search_edit</code>.</li> </ul> Steps <ol> <li>Retrieve the start and end dates from the date edit widgets.</li> <li>Get the search text and convert it to lowercase.</li> <li>Collect selected error types and sources from their respective lists.</li> <li>Fetch the filtered error logs using <code>get_error_logs</code>.</li> <li>Display the logs in the <code>text_edit</code> widget.</li> </ol> Note <p>Ensure that the <code>get_error_logs</code> method is implemented to handle  the filtering logic and return the appropriate logs.</p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>def load_logs(self):\n    \"\"\"\n    Loads and displays error logs based on the specified filters.\n\n    This method retrieves error logs within a specified date range, \n    filtered by selected error types, sources, and a search text. \n\n    The logs are then displayed in a text editor.\n\n    Raises:\n        BaseError: If an exception occurs during the log retrieval process.\n\n    Filters:\n        - Date range: Defined by `start_date_edit` and `end_date_edit`.\n        - Error types: Selected items in `error_list`.\n        - Sources: Selected items in `source_list`.\n        - Search text: Text entered in `text_search_edit`.\n\n    Steps:\n        1. Retrieve the start and end dates from the date edit widgets.\n        2. Get the search text and convert it to lowercase.\n        3. Collect selected error types and sources from their respective lists.\n        4. Fetch the filtered error logs using `get_error_logs`.\n        5. Display the logs in the `text_edit` widget.\n\n    Note:\n        Ensure that the `get_error_logs` method is implemented to handle \n        the filtering logic and return the appropriate logs.\n    \"\"\"\n    try:\n        start_date = self.start_date_edit.date().toString(\"yyyy-MM-dd\")\n        end_date = self.end_date_edit.date().toString(\"yyyy-MM-dd\")\n        search_text = self.text_search_edit.text().lower()\n\n        selected_errors = {item.data(1) for item in self.error_list.selectedItems()}\n        selected_sources = {item.data(1) for item in self.source_list.selectedItems()}\n\n        error_logs = self.get_error_logs(start_date, end_date, selected_errors, selected_sources, search_text)\n        self.text_edit.setPlainText(\"\\n\".join(error_logs))\n    except Exception as e:\n        raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.logs_dialog.LogsDialog.toggle_filter_visibility","title":"<code>toggle_filter_visibility()</code>","text":"<p>Toggles the visibility of filter-related UI elements in the logs dialog.</p> This method switches the visibility state of the following elements <ul> <li><code>select_errors_label</code></li> <li><code>error_list</code></li> <li><code>select_sources_label</code></li> <li><code>source_list</code></li> </ul> <p>If an exception occurs during the process, it raises a <code>BaseError</code> with an error code of 3500 and the exception message.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs while toggling visibility.</p> Source code in <code>src\\ui\\logs_dialog.py</code> <pre><code>def toggle_filter_visibility(self):\n    \"\"\"\n    Toggles the visibility of filter-related UI elements in the logs dialog.\n\n    This method switches the visibility state of the following elements:\n        - `select_errors_label`\n        - `error_list`\n        - `select_sources_label`\n        - `source_list`\n\n    If an exception occurs during the process, it raises a `BaseError` with\n    an error code of 3500 and the exception message.\n\n    Raises:\n        BaseError: If an exception occurs while toggling visibility.\n    \"\"\"\n    try:\n        self.select_errors_label.setVisible(not self.select_errors_label.isVisible())\n        self.error_list.setVisible(not self.error_list.isVisible())\n        self.select_sources_label.setVisible(not self.select_sources_label.isVisible())\n        self.source_list.setVisible(not self.source_list.isVisible())\n    except Exception as e:\n        raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.message_box","title":"<code>message_box</code>","text":""},{"location":"api/#src.ui.message_box.MessageBox","title":"<code>MessageBox</code>","text":"<p>               Bases: <code>QMessageBox</code></p> Source code in <code>src\\ui\\message_box.py</code> <pre><code>class MessageBox(QMessageBox):\n    def __init__(self, icon, text, parent=None):\n        \"\"\"\n        Initializes the custom message box with the specified icon, text, and optional parent widget.\n\n        Args:\n            icon (QMessageBox.Icon): The icon to display in the message box.\n            text (str): The text message to display in the message box.\n            parent (QWidget, optional): The parent widget of the message box. Defaults to None.\n\n        Raises:\n            BaseError: If an error occurs during initialization, a BaseError with code 3501 is raised.\n        \"\"\"\n        try:\n            super().__init__(icon, 'Programa Reloj de Asistencias', text, parent)\n\n            file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"fingerprint.ico\")\n            self.setWindowIcon(QIcon(file_path))\n        except Exception as e:\n            raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.message_box.MessageBox.__init__","title":"<code>__init__(icon, text, parent=None)</code>","text":"<p>Initializes the custom message box with the specified icon, text, and optional parent widget.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>The icon to display in the message box.</p> required <code>text</code> <code>str</code> <p>The text message to display in the message box.</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget of the message box. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an error occurs during initialization, a BaseError with code 3501 is raised.</p> Source code in <code>src\\ui\\message_box.py</code> <pre><code>def __init__(self, icon, text, parent=None):\n    \"\"\"\n    Initializes the custom message box with the specified icon, text, and optional parent widget.\n\n    Args:\n        icon (QMessageBox.Icon): The icon to display in the message box.\n        text (str): The text message to display in the message box.\n        parent (QWidget, optional): The parent widget of the message box. Defaults to None.\n\n    Raises:\n        BaseError: If an error occurs during initialization, a BaseError with code 3501 is raised.\n    \"\"\"\n    try:\n        super().__init__(icon, 'Programa Reloj de Asistencias', text, parent)\n\n        file_path = os.path.join(find_marker_directory(\"resources\"), \"resources\", \"fingerprint.ico\")\n        self.setWindowIcon(QIcon(file_path))\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog","title":"<code>modify_device_dialog</code>","text":""},{"location":"api/#src.ui.modify_device_dialog.AddDevicesDialog","title":"<code>AddDevicesDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>class AddDevicesDialog(QDialog):\n    def __init__(self, parent=None, id=0):\n        \"\"\"\n        Initializes the ModifyDeviceDialog class.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n            id (int, optional): The identifier for the device. Defaults to 0.\n\n        Raises:\n            BaseError: Custom error raised with code 3501 if an exception occurs during initialization.\n        \"\"\"\n        try:\n            super().__init__(parent)\n            self.setWindowTitle(\"Agregar nuevo dispositivo\")\n            self.setMinimumSize(400, 300)\n            self.id = id\n            self.init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the Modify Device Dialog.\n        This method sets up the layout and widgets for the dialog, including input fields\n        for district, model, point of marking, IP address, and communication type. It also\n        includes a button to confirm the action.\n\n        Widgets:\n            - QLineEdit for district input.\n            - QLineEdit for model input.\n            - QLineEdit for point of marking input.\n            - QLineEdit for IP address input.\n            - QComboBox for selecting the communication type (TCP/UDP).\n            - QPushButton for confirming the action.\n\n        Layout:\n            - Uses QVBoxLayout as the main layout.\n            - Uses QFormLayout for organizing input fields and labels.\n\n        Signals:\n            - Connects the QComboBox `currentIndexChanged` signal to the `on_combobox_changed` slot.\n\n        Attributes:\n            self.district_edit (QLineEdit): Input field for the district.\n            self.model_edit (QLineEdit): Input field for the model.\n            self.point_edit (QLineEdit): Input field for the point of marking.\n            self.ip_edit (QLineEdit): Input field for the IP address.\n            self.combo_box (QComboBox): Dropdown for selecting the communication type.\n            self.communication (str): Stores the current communication type selected in the combo box.\n            self.active (bool): Indicates if the device is active (default is True).\n            self.battery (bool): Indicates if the device has a battery (default is True).\n            self.btn_add (QPushButton): Button to confirm and accept the dialog.\n        \"\"\"\n        layout = QVBoxLayout(self)\n\n        form_layout = QFormLayout()\n\n        self.district_edit = QLineEdit(self)\n        self.model_edit = QLineEdit(self)\n        self.point_edit = QLineEdit(self)\n        self.ip_edit = QLineEdit(self)\n        # Create a QComboBox\n        self.combo_box = QComboBox()\n        # Add items to the QComboBox\n        self.combo_box.addItem(\"TCP\")\n        self.combo_box.addItem(\"UDP\")\n        # Connect the QComboBox signal to a slot\n        self.combo_box.currentIndexChanged.connect(self.on_combobox_changed)\n        self.communication = self.combo_box.currentText()\n\n        self.active = True\n        self.battery = True\n\n        form_layout.addRow(\"Distrito:\", self.district_edit)\n        form_layout.addRow(\"Modelo:\", self.model_edit)\n        form_layout.addRow(\"Punto de Marcaci\u00f3n:\", self.point_edit)\n        form_layout.addRow(\"IP:\", self.ip_edit)\n        form_layout.addRow(\"Comunicaci\u00f3n:\", self.combo_box)\n\n        layout.addLayout(form_layout)\n\n        self.btn_add = QPushButton(\"Agregar\", self)\n        self.btn_add.clicked.connect(self.accept)\n        layout.addWidget(self.btn_add)\n\n        self.setLayout(layout)\n\n    def on_combobox_changed(self, index):\n        \"\"\"\n        Handles the event triggered when the selected index of the combo box changes.\n\n        Args:\n            index (int): The index of the newly selected item in the combo box.\n\n        Side Effects:\n            Updates the `self.communication` attribute with the text of the currently selected option\n            in the combo box.\n        \"\"\"\n        # Get the text of the selected option\n        self.communication = self.combo_box.currentText()\n        #logging.debug(self.communication)\n\n    def get_data(self):\n        \"\"\"\n        Retrieves and returns the data from the dialog fields.\n\n        Returns:\n            (tuple): A tuple containing the following elements:\n\n                - str: The district name in uppercase (from `district_edit`).\n                - str: The model name (from `model_edit`).\n                - str: The point name in uppercase (from `point_edit`).\n                - str: The IP address (from `ip_edit`).\n                - Any: The device ID (`self.id`).\n                - Any: The communication type or status (`self.communication`).\n                - Any: The battery status (`self.battery`).\n                - Any: The active status (`self.active`).\n        \"\"\"\n        return (\n            self.district_edit.text().upper(),\n            self.model_edit.text(),\n            self.point_edit.text().upper(),\n            self.ip_edit.text(),\n            self.id,\n            self.communication,\n            self.battery,\n            self.active\n        )\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.AddDevicesDialog.__init__","title":"<code>__init__(parent=None, id=0)</code>","text":"<p>Initializes the ModifyDeviceDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <code>id</code> <code>int</code> <p>The identifier for the device. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>BaseError</code> <p>Custom error raised with code 3501 if an exception occurs during initialization.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def __init__(self, parent=None, id=0):\n    \"\"\"\n    Initializes the ModifyDeviceDialog class.\n\n    Args:\n        parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n        id (int, optional): The identifier for the device. Defaults to 0.\n\n    Raises:\n        BaseError: Custom error raised with code 3501 if an exception occurs during initialization.\n    \"\"\"\n    try:\n        super().__init__(parent)\n        self.setWindowTitle(\"Agregar nuevo dispositivo\")\n        self.setMinimumSize(400, 300)\n        self.id = id\n        self.init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.AddDevicesDialog.get_data","title":"<code>get_data()</code>","text":"<p>Retrieves and returns the data from the dialog fields.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the following elements:</p> <ul> <li>str: The district name in uppercase (from <code>district_edit</code>).</li> <li>str: The model name (from <code>model_edit</code>).</li> <li>str: The point name in uppercase (from <code>point_edit</code>).</li> <li>str: The IP address (from <code>ip_edit</code>).</li> <li>Any: The device ID (<code>self.id</code>).</li> <li>Any: The communication type or status (<code>self.communication</code>).</li> <li>Any: The battery status (<code>self.battery</code>).</li> <li>Any: The active status (<code>self.active</code>).</li> </ul> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def get_data(self):\n    \"\"\"\n    Retrieves and returns the data from the dialog fields.\n\n    Returns:\n        (tuple): A tuple containing the following elements:\n\n            - str: The district name in uppercase (from `district_edit`).\n            - str: The model name (from `model_edit`).\n            - str: The point name in uppercase (from `point_edit`).\n            - str: The IP address (from `ip_edit`).\n            - Any: The device ID (`self.id`).\n            - Any: The communication type or status (`self.communication`).\n            - Any: The battery status (`self.battery`).\n            - Any: The active status (`self.active`).\n    \"\"\"\n    return (\n        self.district_edit.text().upper(),\n        self.model_edit.text(),\n        self.point_edit.text().upper(),\n        self.ip_edit.text(),\n        self.id,\n        self.communication,\n        self.battery,\n        self.active\n    )\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.AddDevicesDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the Modify Device Dialog. This method sets up the layout and widgets for the dialog, including input fields for district, model, point of marking, IP address, and communication type. It also includes a button to confirm the action.</p> Widgets <ul> <li>QLineEdit for district input.</li> <li>QLineEdit for model input.</li> <li>QLineEdit for point of marking input.</li> <li>QLineEdit for IP address input.</li> <li>QComboBox for selecting the communication type (TCP/UDP).</li> <li>QPushButton for confirming the action.</li> </ul> Layout <ul> <li>Uses QVBoxLayout as the main layout.</li> <li>Uses QFormLayout for organizing input fields and labels.</li> </ul> Signals <ul> <li>Connects the QComboBox <code>currentIndexChanged</code> signal to the <code>on_combobox_changed</code> slot.</li> </ul> <p>Attributes:</p> Name Type Description <code>self.district_edit</code> <code>QLineEdit</code> <p>Input field for the district.</p> <code>self.model_edit</code> <code>QLineEdit</code> <p>Input field for the model.</p> <code>self.point_edit</code> <code>QLineEdit</code> <p>Input field for the point of marking.</p> <code>self.ip_edit</code> <code>QLineEdit</code> <p>Input field for the IP address.</p> <code>self.combo_box</code> <code>QComboBox</code> <p>Dropdown for selecting the communication type.</p> <code>self.communication</code> <code>str</code> <p>Stores the current communication type selected in the combo box.</p> <code>self.active</code> <code>bool</code> <p>Indicates if the device is active (default is True).</p> <code>self.battery</code> <code>bool</code> <p>Indicates if the device has a battery (default is True).</p> <code>self.btn_add</code> <code>QPushButton</code> <p>Button to confirm and accept the dialog.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the Modify Device Dialog.\n    This method sets up the layout and widgets for the dialog, including input fields\n    for district, model, point of marking, IP address, and communication type. It also\n    includes a button to confirm the action.\n\n    Widgets:\n        - QLineEdit for district input.\n        - QLineEdit for model input.\n        - QLineEdit for point of marking input.\n        - QLineEdit for IP address input.\n        - QComboBox for selecting the communication type (TCP/UDP).\n        - QPushButton for confirming the action.\n\n    Layout:\n        - Uses QVBoxLayout as the main layout.\n        - Uses QFormLayout for organizing input fields and labels.\n\n    Signals:\n        - Connects the QComboBox `currentIndexChanged` signal to the `on_combobox_changed` slot.\n\n    Attributes:\n        self.district_edit (QLineEdit): Input field for the district.\n        self.model_edit (QLineEdit): Input field for the model.\n        self.point_edit (QLineEdit): Input field for the point of marking.\n        self.ip_edit (QLineEdit): Input field for the IP address.\n        self.combo_box (QComboBox): Dropdown for selecting the communication type.\n        self.communication (str): Stores the current communication type selected in the combo box.\n        self.active (bool): Indicates if the device is active (default is True).\n        self.battery (bool): Indicates if the device has a battery (default is True).\n        self.btn_add (QPushButton): Button to confirm and accept the dialog.\n    \"\"\"\n    layout = QVBoxLayout(self)\n\n    form_layout = QFormLayout()\n\n    self.district_edit = QLineEdit(self)\n    self.model_edit = QLineEdit(self)\n    self.point_edit = QLineEdit(self)\n    self.ip_edit = QLineEdit(self)\n    # Create a QComboBox\n    self.combo_box = QComboBox()\n    # Add items to the QComboBox\n    self.combo_box.addItem(\"TCP\")\n    self.combo_box.addItem(\"UDP\")\n    # Connect the QComboBox signal to a slot\n    self.combo_box.currentIndexChanged.connect(self.on_combobox_changed)\n    self.communication = self.combo_box.currentText()\n\n    self.active = True\n    self.battery = True\n\n    form_layout.addRow(\"Distrito:\", self.district_edit)\n    form_layout.addRow(\"Modelo:\", self.model_edit)\n    form_layout.addRow(\"Punto de Marcaci\u00f3n:\", self.point_edit)\n    form_layout.addRow(\"IP:\", self.ip_edit)\n    form_layout.addRow(\"Comunicaci\u00f3n:\", self.combo_box)\n\n    layout.addLayout(form_layout)\n\n    self.btn_add = QPushButton(\"Agregar\", self)\n    self.btn_add.clicked.connect(self.accept)\n    layout.addWidget(self.btn_add)\n\n    self.setLayout(layout)\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.AddDevicesDialog.on_combobox_changed","title":"<code>on_combobox_changed(index)</code>","text":"<p>Handles the event triggered when the selected index of the combo box changes.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the newly selected item in the combo box.</p> required Side Effects <p>Updates the <code>self.communication</code> attribute with the text of the currently selected option in the combo box.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def on_combobox_changed(self, index):\n    \"\"\"\n    Handles the event triggered when the selected index of the combo box changes.\n\n    Args:\n        index (int): The index of the newly selected item in the combo box.\n\n    Side Effects:\n        Updates the `self.communication` attribute with the text of the currently selected option\n        in the combo box.\n    \"\"\"\n    # Get the text of the selected option\n    self.communication = self.combo_box.currentText()\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog","title":"<code>ModifyDevicesDialog</code>","text":"<p>               Bases: <code>BaseDialog</code></p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>class ModifyDevicesDialog(BaseDialog):\n    def __init__(self, parent=None):\n        \"\"\"\n        Initializes the ModifyDeviceDialog class.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n        Attributes:\n            file_path (str): The path to the \"info_devices.txt\" file, determined dynamically.\n            data (list): A list to store device data.\n            max_id (int): The maximum ID value among the devices.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501.\n        \"\"\"\n        try:\n            super().__init__(parent, window_title=\"MODIFICAR DISPOSITIVOS\")\n\n            self.file_path = os.path.join(find_root_directory(), \"info_devices.txt\")\n            self.data = []\n            self.max_id = 0\n            self.init_ui()\n            super().init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the Modify Device Dialog.\n        This method sets up the layout and widgets for the dialog, including a table\n        for displaying device information and buttons for performing various actions\n        such as loading, modifying, adding, activating, and deactivating devices.\n\n        Widgets:\n            - QTableWidget: Displays device information with 8 columns:\n                [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\", \n                \"Pila funcionando\", \"Activado\"]. Columns are resizable, sortable, and editable on double-click.\n            - QPushButton: Buttons for the following actions:\n                - \"Cargar\": Loads and displays data in the table.\n                - \"Modificar\": Saves modifications made to the data.\n                - \"Agregar\": Adds a new device entry.\n                - \"Activar todo\": Activates all devices.\n                - \"Desactivar todo\": Deactivates all devices.\n\n        Layout:\n            - QVBoxLayout: Main layout containing the table widget and button layout.\n            - QHBoxLayout: Layout for arranging the action buttons horizontally.\n\n        Notes:\n            - Buttons are configured to not retain focus after being clicked.\n            - The `load_data_and_show` method is called at the end to populate the table with initial data.\n        \"\"\"\n        layout = QVBoxLayout(self)\n\n        self.table_widget = QTableWidget()\n        self.table_widget.setColumnCount(8)\n        self.table_widget.setHorizontalHeaderLabels([\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\", \"Pila funcionando\", \"Activado\"])\n        self.table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n        self.table_widget.horizontalHeader().setStretchLastSection(True)\n        self.table_widget.setEditTriggers(QTableWidget.DoubleClicked)\n        self.table_widget.setSortingEnabled(True)\n\n        layout.addWidget(self.table_widget)\n\n        button_layout = QHBoxLayout()\n\n        self.btn_load_data = QPushButton(\"Cargar\", self)\n        self.btn_load_data.clicked.connect(self.load_data_and_show)\n        button_layout.addWidget(self.btn_load_data)\n\n        self.btn_save_data = QPushButton(\"Modificar\", self)\n        self.btn_save_data.clicked.connect(self.save_data)\n        button_layout.addWidget(self.btn_save_data)\n\n        self.btn_add_data = QPushButton(\"Agregar\", self)\n        self.btn_add_data.clicked.connect(self.add_device)\n        button_layout.addWidget(self.btn_add_data)\n\n        self.btn_activate_all = QPushButton(\"Activar todo\", self)\n        self.btn_activate_all.clicked.connect(self.activate_all)\n        button_layout.addWidget(self.btn_activate_all)\n\n        self.btn_deactivate_all = QPushButton(\"Desactivar todo\", self)\n        self.btn_deactivate_all.clicked.connect(self.deactivate_all)\n        button_layout.addWidget(self.btn_deactivate_all)\n\n        layout.addLayout(button_layout)\n\n        self.setLayout(layout)\n\n        # Clear focus from buttons\n        self.btn_load_data.setAutoDefault(False)\n        self.btn_load_data.setDefault(False)\n        self.btn_save_data.setAutoDefault(False)\n        self.btn_save_data.setDefault(False)\n        self.btn_add_data.setAutoDefault(False)\n        self.btn_add_data.setDefault(False)\n        self.btn_activate_all.setAutoDefault(False)\n        self.btn_activate_all.setDefault(False)\n        self.btn_deactivate_all.setAutoDefault(False)\n        self.btn_deactivate_all.setDefault(False)\n\n        self.load_data_and_show()\n\n    # Methods for selecting and deselecting \"Active\" checkboxes\n    def activate_all(self):\n        \"\"\"\n        Activates all checkboxes in the specified column of the table widget.\n\n        This method iterates through all rows of the table widget and sets the \n        checkbox in the 7th column (index 7) to a checked state.\n\n        Note:\n            - Assumes that the 7th column of the table widget contains checkboxes \n              as cell widgets.\n            - The table widget must be properly initialized and populated before \n              calling this method.\n\n        \"\"\"\n        for row in range(self.table_widget.rowCount()):\n            checkbox_delegate = self.table_widget.cellWidget(row, 7)\n            checkbox_delegate.setChecked(True)\n\n    def deactivate_all(self):\n        \"\"\"\n        Deactivates all checkboxes in the specified column of the table widget.\n\n        This method iterates through all rows of the table widget and sets the \n        checkbox in the specified column (column index 7) to an unchecked state.\n\n        Returns:\n            None\n        \"\"\"\n        for row in range(self.table_widget.rowCount()):\n            checkbox_delegate = self.table_widget.cellWidget(row, 7)\n            checkbox_delegate.setChecked(False)\n\n    def add_device(self):\n        \"\"\"\n        Adds a new device to the list of devices.\n\n        This method calculates a new unique ID for the device, opens a dialog\n        to collect the device's details, and appends the new device data to\n        the internal data list if the dialog is accepted. It also updates the\n        maximum ID and refreshes the data displayed in the table.\n\n        Steps:\n\n        1. Calculate a new unique ID for the device.\n        2. Open the AddDevicesDialog to collect device details.\n        3. If the dialog is accepted:\n            - Retrieve the new device data from the dialog.\n            - Append the new device data to the internal list.\n            - Update the maximum ID.\n            - Reload the data into the table.\n\n        Note:\n        - The dialog must return QDialog.Accepted for the new device data to be added.\n\n        \"\"\"\n        new_id = self.max_id + 1  # Calculate new ID\n        dialog = AddDevicesDialog(self, new_id)\n        if dialog.exec() == QDialog.Accepted:\n            new_device_data = dialog.get_data()\n            #logging.debug(new_device_data)\n            self.data.append(new_device_data)\n            self.max_id = new_id  # Update max_id\n            self.load_data_into_table()\n\n    def load_data_and_show(self):\n        \"\"\"\n        Loads data, processes it, and displays it in the UI.\n\n        This method performs the following steps:\n        1. Loads data by calling the `load_data` method.\n        2. Populates the UI table with the loaded data by calling the `load_data_into_table` method.\n\n        Ensure that the `load_data` and `load_data_into_table` methods are properly implemented\n        for this method to function as expected.\n        \"\"\"\n        self.data = self.load_data()\n        self.load_data_into_table()\n\n    def load_data(self):\n        \"\"\"\n        Loads data from a file specified by `self.file_path`.\n\n        The method reads each line of the file, splits it into parts, and processes\n        the data if it matches the expected format. Each line is expected to have\n        8 components separated by ' - '. The components are:\n        district, model, point, ip, id, communication, battery, and active.\n\n        The method updates `self.max_id` with the maximum value of the `id` field\n        encountered in the file. The `battery` and `active` fields are evaluated\n        as Python literals using `literal_eval`.\n\n        Returns:\n            (list): A list of tuples containing the processed data. Each tuple has\n                  the following structure:\n                  (district, model, point, ip, id, communication, battery, active)\n\n        Raises:\n            BaseErrorWithMessageBox: If an exception occurs during file reading or\n                                     processing, it raises this custom error with\n                                     an error code (3001) and the exception message.\n        \"\"\"\n        data = []\n        try:\n            with open(self.file_path, 'r') as file:\n                for line in file:\n                    parts = line.strip().split(' - ')\n                    if len(parts) == 8:\n                        district, model, point, ip, id, communication, battery, active = parts\n                        self.max_id = max(self.max_id, int(id))  # Update max_id\n                        data.append((district, model, point, ip, id, communication, literal_eval(battery), literal_eval(active)))\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n        return data\n\n    def load_data_into_table(self):\n        \"\"\"\n        Populates the table widget with data from the `self.data` attribute.\n        This method iterates over the rows of data and populates each row in the table widget.\n\n        It sets up the following columns:\n\n        - Column 0: District (string)\n        - Column 1: Model (string)\n        - Column 2: Point (string)\n        - Column 3: IP Address (string)\n        - Column 4: ID (integer, converted to string)\n        - Column 5: Communication (string, with a ComboBoxDelegate)\n        - Column 6: Battery (boolean, with a CheckBoxDelegate)\n        - Column 7: Active (boolean, with a CheckBoxDelegate)\n\n        Delegates are used for specific columns:\n\n        - A ComboBoxDelegate is set for column 5 to allow selection of communication options.\n        - CheckBoxDelegates are used for columns 6 and 7 to represent boolean values.\n\n        After populating the table, the method adjusts the table size to fit the content.\n\n        Raises:\n            BaseErrorWithMessageBox: If an exception occurs during the execution, it raises\n            a custom error with a message box displaying the error details.\n        \"\"\"\n        try:\n            self.table_widget.setRowCount(0)\n            for row, (district, model, point, ip, id, communication, battery, active) in enumerate(self.data):\n                self.table_widget.insertRow(row)\n                self.table_widget.setItem(row, 0, QTableWidgetItem(district))\n                self.table_widget.setItem(row, 1, QTableWidgetItem(model))\n                self.table_widget.setItem(row, 2, QTableWidgetItem(point))\n                self.table_widget.setItem(row, 3, QTableWidgetItem(ip))\n                self.table_widget.setItem(row, 4, QTableWidgetItem(str(id)))\n                # Set ComboBoxDelegate for column 5\n                combo_box_delegate = ComboBoxDelegate(self.table_widget)\n                self.table_widget.setItemDelegateForColumn(5, combo_box_delegate)\n                # Set the value in the model for column 5\n                self.table_widget.setItem(row, 5, QTableWidgetItem(communication))\n                # Set CheckBoxDelegate for column 6\n                checkbox_battery = CheckBoxDelegate()\n                checkbox_battery.setChecked(battery)\n                self.table_widget.setCellWidget(row, 6, checkbox_battery)\n                # Set CheckBoxDelegate for column 7\n                checkbox_active = CheckBoxDelegate()\n                checkbox_active.setChecked(active)\n                self.table_widget.setCellWidget(row, 7, checkbox_active)\n\n            self.adjust_size_to_table()\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n\n    def save_data(self):\n        \"\"\"\n        Saves the data from the table widget to a file.\n\n        This method iterates through all rows of the table widget, retrieves the data\n        from each cell, and writes it to a file specified by `self.file_path`. The data\n        is saved in a formatted string with each row's values separated by \" - \".\n        Boolean values from checkboxes in the table are also included.\n\n        Raises:\n            BaseErrorWithMessageBox: If an exception occurs during the file writing process,\n            it raises a custom error with a message box displaying the error details.\n\n        Side Effects:\n            - Writes data to the file specified by `self.file_path`.\n            - Displays a success message box upon successful save.\n            - Displays an error message box if an exception occurs.\n\n        Notes:\n            - The `district` and `point` values are converted to uppercase before saving.\n            - The `battery` and `active` values are retrieved from checkbox widgets in the table.\n\n        \"\"\"\n        try:\n            with open(self.file_path, 'w') as file:\n                for row in range(self.table_widget.rowCount()):\n                    district = self.table_widget.item(row, 0).text().upper()\n                    model = self.table_widget.item(row, 1).text()\n                    point = self.table_widget.item(row, 2).text().upper()\n                    ip = self.table_widget.item(row, 3).text()\n                    id = self.table_widget.item(row, 4).text()\n                    communication = self.table_widget.item(row, 5).text()\n                    battery = self.table_widget.cellWidget(row, 6).isChecked()\n                    active = self.table_widget.cellWidget(row, 7).isChecked()\n                    #logging.debug(f\"{district} - {model} - {point} - {ip} - {id} - {communication} - {battery} - {active}\")\n                    file.write(f\"{district} - {model} - {point} - {ip} - {id} - {communication} - {battery} - {active}\\n\")\n            QMessageBox.information(self, \"\u00c9xito\", \"Datos guardados correctamente.\")\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the ModifyDeviceDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The path to the \"info_devices.txt\" file, determined dynamically.</p> <code>data</code> <code>list</code> <p>A list to store device data.</p> <code>max_id</code> <code>int</code> <p>The maximum ID value among the devices.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with code 3501.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Initializes the ModifyDeviceDialog class.\n\n    Args:\n        parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n    Attributes:\n        file_path (str): The path to the \"info_devices.txt\" file, determined dynamically.\n        data (list): A list to store device data.\n        max_id (int): The maximum ID value among the devices.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501.\n    \"\"\"\n    try:\n        super().__init__(parent, window_title=\"MODIFICAR DISPOSITIVOS\")\n\n        self.file_path = os.path.join(find_root_directory(), \"info_devices.txt\")\n        self.data = []\n        self.max_id = 0\n        self.init_ui()\n        super().init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.activate_all","title":"<code>activate_all()</code>","text":"<p>Activates all checkboxes in the specified column of the table widget.</p> <p>This method iterates through all rows of the table widget and sets the  checkbox in the 7th column (index 7) to a checked state.</p> Note <ul> <li>Assumes that the 7th column of the table widget contains checkboxes    as cell widgets.</li> <li>The table widget must be properly initialized and populated before    calling this method.</li> </ul> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def activate_all(self):\n    \"\"\"\n    Activates all checkboxes in the specified column of the table widget.\n\n    This method iterates through all rows of the table widget and sets the \n    checkbox in the 7th column (index 7) to a checked state.\n\n    Note:\n        - Assumes that the 7th column of the table widget contains checkboxes \n          as cell widgets.\n        - The table widget must be properly initialized and populated before \n          calling this method.\n\n    \"\"\"\n    for row in range(self.table_widget.rowCount()):\n        checkbox_delegate = self.table_widget.cellWidget(row, 7)\n        checkbox_delegate.setChecked(True)\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.add_device","title":"<code>add_device()</code>","text":"<p>Adds a new device to the list of devices.</p> <p>This method calculates a new unique ID for the device, opens a dialog to collect the device's details, and appends the new device data to the internal data list if the dialog is accepted. It also updates the maximum ID and refreshes the data displayed in the table.</p> <p>Steps:</p> <ol> <li>Calculate a new unique ID for the device.</li> <li>Open the AddDevicesDialog to collect device details.</li> <li>If the dialog is accepted:<ul> <li>Retrieve the new device data from the dialog.</li> <li>Append the new device data to the internal list.</li> <li>Update the maximum ID.</li> <li>Reload the data into the table.</li> </ul> </li> </ol> <p>Note: - The dialog must return QDialog.Accepted for the new device data to be added.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def add_device(self):\n    \"\"\"\n    Adds a new device to the list of devices.\n\n    This method calculates a new unique ID for the device, opens a dialog\n    to collect the device's details, and appends the new device data to\n    the internal data list if the dialog is accepted. It also updates the\n    maximum ID and refreshes the data displayed in the table.\n\n    Steps:\n\n    1. Calculate a new unique ID for the device.\n    2. Open the AddDevicesDialog to collect device details.\n    3. If the dialog is accepted:\n        - Retrieve the new device data from the dialog.\n        - Append the new device data to the internal list.\n        - Update the maximum ID.\n        - Reload the data into the table.\n\n    Note:\n    - The dialog must return QDialog.Accepted for the new device data to be added.\n\n    \"\"\"\n    new_id = self.max_id + 1  # Calculate new ID\n    dialog = AddDevicesDialog(self, new_id)\n    if dialog.exec() == QDialog.Accepted:\n        new_device_data = dialog.get_data()\n        #logging.debug(new_device_data)\n        self.data.append(new_device_data)\n        self.max_id = new_id  # Update max_id\n        self.load_data_into_table()\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.deactivate_all","title":"<code>deactivate_all()</code>","text":"<p>Deactivates all checkboxes in the specified column of the table widget.</p> <p>This method iterates through all rows of the table widget and sets the  checkbox in the specified column (column index 7) to an unchecked state.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def deactivate_all(self):\n    \"\"\"\n    Deactivates all checkboxes in the specified column of the table widget.\n\n    This method iterates through all rows of the table widget and sets the \n    checkbox in the specified column (column index 7) to an unchecked state.\n\n    Returns:\n        None\n    \"\"\"\n    for row in range(self.table_widget.rowCount()):\n        checkbox_delegate = self.table_widget.cellWidget(row, 7)\n        checkbox_delegate.setChecked(False)\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the Modify Device Dialog. This method sets up the layout and widgets for the dialog, including a table for displaying device information and buttons for performing various actions such as loading, modifying, adding, activating, and deactivating devices.</p> Widgets <ul> <li>QTableWidget: Displays device information with 8 columns:     [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\",      \"Pila funcionando\", \"Activado\"]. Columns are resizable, sortable, and editable on double-click.</li> <li>QPushButton: Buttons for the following actions:<ul> <li>\"Cargar\": Loads and displays data in the table.</li> <li>\"Modificar\": Saves modifications made to the data.</li> <li>\"Agregar\": Adds a new device entry.</li> <li>\"Activar todo\": Activates all devices.</li> <li>\"Desactivar todo\": Deactivates all devices.</li> </ul> </li> </ul> Layout <ul> <li>QVBoxLayout: Main layout containing the table widget and button layout.</li> <li>QHBoxLayout: Layout for arranging the action buttons horizontally.</li> </ul> Notes <ul> <li>Buttons are configured to not retain focus after being clicked.</li> <li>The <code>load_data_and_show</code> method is called at the end to populate the table with initial data.</li> </ul> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the Modify Device Dialog.\n    This method sets up the layout and widgets for the dialog, including a table\n    for displaying device information and buttons for performing various actions\n    such as loading, modifying, adding, activating, and deactivating devices.\n\n    Widgets:\n        - QTableWidget: Displays device information with 8 columns:\n            [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\", \n            \"Pila funcionando\", \"Activado\"]. Columns are resizable, sortable, and editable on double-click.\n        - QPushButton: Buttons for the following actions:\n            - \"Cargar\": Loads and displays data in the table.\n            - \"Modificar\": Saves modifications made to the data.\n            - \"Agregar\": Adds a new device entry.\n            - \"Activar todo\": Activates all devices.\n            - \"Desactivar todo\": Deactivates all devices.\n\n    Layout:\n        - QVBoxLayout: Main layout containing the table widget and button layout.\n        - QHBoxLayout: Layout for arranging the action buttons horizontally.\n\n    Notes:\n        - Buttons are configured to not retain focus after being clicked.\n        - The `load_data_and_show` method is called at the end to populate the table with initial data.\n    \"\"\"\n    layout = QVBoxLayout(self)\n\n    self.table_widget = QTableWidget()\n    self.table_widget.setColumnCount(8)\n    self.table_widget.setHorizontalHeaderLabels([\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\", \"Pila funcionando\", \"Activado\"])\n    self.table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n    self.table_widget.horizontalHeader().setStretchLastSection(True)\n    self.table_widget.setEditTriggers(QTableWidget.DoubleClicked)\n    self.table_widget.setSortingEnabled(True)\n\n    layout.addWidget(self.table_widget)\n\n    button_layout = QHBoxLayout()\n\n    self.btn_load_data = QPushButton(\"Cargar\", self)\n    self.btn_load_data.clicked.connect(self.load_data_and_show)\n    button_layout.addWidget(self.btn_load_data)\n\n    self.btn_save_data = QPushButton(\"Modificar\", self)\n    self.btn_save_data.clicked.connect(self.save_data)\n    button_layout.addWidget(self.btn_save_data)\n\n    self.btn_add_data = QPushButton(\"Agregar\", self)\n    self.btn_add_data.clicked.connect(self.add_device)\n    button_layout.addWidget(self.btn_add_data)\n\n    self.btn_activate_all = QPushButton(\"Activar todo\", self)\n    self.btn_activate_all.clicked.connect(self.activate_all)\n    button_layout.addWidget(self.btn_activate_all)\n\n    self.btn_deactivate_all = QPushButton(\"Desactivar todo\", self)\n    self.btn_deactivate_all.clicked.connect(self.deactivate_all)\n    button_layout.addWidget(self.btn_deactivate_all)\n\n    layout.addLayout(button_layout)\n\n    self.setLayout(layout)\n\n    # Clear focus from buttons\n    self.btn_load_data.setAutoDefault(False)\n    self.btn_load_data.setDefault(False)\n    self.btn_save_data.setAutoDefault(False)\n    self.btn_save_data.setDefault(False)\n    self.btn_add_data.setAutoDefault(False)\n    self.btn_add_data.setDefault(False)\n    self.btn_activate_all.setAutoDefault(False)\n    self.btn_activate_all.setDefault(False)\n    self.btn_deactivate_all.setAutoDefault(False)\n    self.btn_deactivate_all.setDefault(False)\n\n    self.load_data_and_show()\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.load_data","title":"<code>load_data()</code>","text":"<p>Loads data from a file specified by <code>self.file_path</code>.</p> <p>The method reads each line of the file, splits it into parts, and processes the data if it matches the expected format. Each line is expected to have 8 components separated by ' - '. The components are: district, model, point, ip, id, communication, battery, and active.</p> <p>The method updates <code>self.max_id</code> with the maximum value of the <code>id</code> field encountered in the file. The <code>battery</code> and <code>active</code> fields are evaluated as Python literals using <code>literal_eval</code>.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tuples containing the processed data. Each tuple has   the following structure:   (district, model, point, ip, id, communication, battery, active)</p> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an exception occurs during file reading or                      processing, it raises this custom error with                      an error code (3001) and the exception message.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def load_data(self):\n    \"\"\"\n    Loads data from a file specified by `self.file_path`.\n\n    The method reads each line of the file, splits it into parts, and processes\n    the data if it matches the expected format. Each line is expected to have\n    8 components separated by ' - '. The components are:\n    district, model, point, ip, id, communication, battery, and active.\n\n    The method updates `self.max_id` with the maximum value of the `id` field\n    encountered in the file. The `battery` and `active` fields are evaluated\n    as Python literals using `literal_eval`.\n\n    Returns:\n        (list): A list of tuples containing the processed data. Each tuple has\n              the following structure:\n              (district, model, point, ip, id, communication, battery, active)\n\n    Raises:\n        BaseErrorWithMessageBox: If an exception occurs during file reading or\n                                 processing, it raises this custom error with\n                                 an error code (3001) and the exception message.\n    \"\"\"\n    data = []\n    try:\n        with open(self.file_path, 'r') as file:\n            for line in file:\n                parts = line.strip().split(' - ')\n                if len(parts) == 8:\n                    district, model, point, ip, id, communication, battery, active = parts\n                    self.max_id = max(self.max_id, int(id))  # Update max_id\n                    data.append((district, model, point, ip, id, communication, literal_eval(battery), literal_eval(active)))\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n    return data\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.load_data_and_show","title":"<code>load_data_and_show()</code>","text":"<p>Loads data, processes it, and displays it in the UI.</p> <p>This method performs the following steps: 1. Loads data by calling the <code>load_data</code> method. 2. Populates the UI table with the loaded data by calling the <code>load_data_into_table</code> method.</p> <p>Ensure that the <code>load_data</code> and <code>load_data_into_table</code> methods are properly implemented for this method to function as expected.</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def load_data_and_show(self):\n    \"\"\"\n    Loads data, processes it, and displays it in the UI.\n\n    This method performs the following steps:\n    1. Loads data by calling the `load_data` method.\n    2. Populates the UI table with the loaded data by calling the `load_data_into_table` method.\n\n    Ensure that the `load_data` and `load_data_into_table` methods are properly implemented\n    for this method to function as expected.\n    \"\"\"\n    self.data = self.load_data()\n    self.load_data_into_table()\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.load_data_into_table","title":"<code>load_data_into_table()</code>","text":"<p>Populates the table widget with data from the <code>self.data</code> attribute. This method iterates over the rows of data and populates each row in the table widget.</p> <p>It sets up the following columns:</p> <ul> <li>Column 0: District (string)</li> <li>Column 1: Model (string)</li> <li>Column 2: Point (string)</li> <li>Column 3: IP Address (string)</li> <li>Column 4: ID (integer, converted to string)</li> <li>Column 5: Communication (string, with a ComboBoxDelegate)</li> <li>Column 6: Battery (boolean, with a CheckBoxDelegate)</li> <li>Column 7: Active (boolean, with a CheckBoxDelegate)</li> </ul> <p>Delegates are used for specific columns:</p> <ul> <li>A ComboBoxDelegate is set for column 5 to allow selection of communication options.</li> <li>CheckBoxDelegates are used for columns 6 and 7 to represent boolean values.</li> </ul> <p>After populating the table, the method adjusts the table size to fit the content.</p> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an exception occurs during the execution, it raises</p> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def load_data_into_table(self):\n    \"\"\"\n    Populates the table widget with data from the `self.data` attribute.\n    This method iterates over the rows of data and populates each row in the table widget.\n\n    It sets up the following columns:\n\n    - Column 0: District (string)\n    - Column 1: Model (string)\n    - Column 2: Point (string)\n    - Column 3: IP Address (string)\n    - Column 4: ID (integer, converted to string)\n    - Column 5: Communication (string, with a ComboBoxDelegate)\n    - Column 6: Battery (boolean, with a CheckBoxDelegate)\n    - Column 7: Active (boolean, with a CheckBoxDelegate)\n\n    Delegates are used for specific columns:\n\n    - A ComboBoxDelegate is set for column 5 to allow selection of communication options.\n    - CheckBoxDelegates are used for columns 6 and 7 to represent boolean values.\n\n    After populating the table, the method adjusts the table size to fit the content.\n\n    Raises:\n        BaseErrorWithMessageBox: If an exception occurs during the execution, it raises\n        a custom error with a message box displaying the error details.\n    \"\"\"\n    try:\n        self.table_widget.setRowCount(0)\n        for row, (district, model, point, ip, id, communication, battery, active) in enumerate(self.data):\n            self.table_widget.insertRow(row)\n            self.table_widget.setItem(row, 0, QTableWidgetItem(district))\n            self.table_widget.setItem(row, 1, QTableWidgetItem(model))\n            self.table_widget.setItem(row, 2, QTableWidgetItem(point))\n            self.table_widget.setItem(row, 3, QTableWidgetItem(ip))\n            self.table_widget.setItem(row, 4, QTableWidgetItem(str(id)))\n            # Set ComboBoxDelegate for column 5\n            combo_box_delegate = ComboBoxDelegate(self.table_widget)\n            self.table_widget.setItemDelegateForColumn(5, combo_box_delegate)\n            # Set the value in the model for column 5\n            self.table_widget.setItem(row, 5, QTableWidgetItem(communication))\n            # Set CheckBoxDelegate for column 6\n            checkbox_battery = CheckBoxDelegate()\n            checkbox_battery.setChecked(battery)\n            self.table_widget.setCellWidget(row, 6, checkbox_battery)\n            # Set CheckBoxDelegate for column 7\n            checkbox_active = CheckBoxDelegate()\n            checkbox_active.setChecked(active)\n            self.table_widget.setCellWidget(row, 7, checkbox_active)\n\n        self.adjust_size_to_table()\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.modify_device_dialog.ModifyDevicesDialog.save_data","title":"<code>save_data()</code>","text":"<p>Saves the data from the table widget to a file.</p> <p>This method iterates through all rows of the table widget, retrieves the data from each cell, and writes it to a file specified by <code>self.file_path</code>. The data is saved in a formatted string with each row's values separated by \" - \". Boolean values from checkboxes in the table are also included.</p> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an exception occurs during the file writing process,</p> Side Effects <ul> <li>Writes data to the file specified by <code>self.file_path</code>.</li> <li>Displays a success message box upon successful save.</li> <li>Displays an error message box if an exception occurs.</li> </ul> Notes <ul> <li>The <code>district</code> and <code>point</code> values are converted to uppercase before saving.</li> <li>The <code>battery</code> and <code>active</code> values are retrieved from checkbox widgets in the table.</li> </ul> Source code in <code>src\\ui\\modify_device_dialog.py</code> <pre><code>def save_data(self):\n    \"\"\"\n    Saves the data from the table widget to a file.\n\n    This method iterates through all rows of the table widget, retrieves the data\n    from each cell, and writes it to a file specified by `self.file_path`. The data\n    is saved in a formatted string with each row's values separated by \" - \".\n    Boolean values from checkboxes in the table are also included.\n\n    Raises:\n        BaseErrorWithMessageBox: If an exception occurs during the file writing process,\n        it raises a custom error with a message box displaying the error details.\n\n    Side Effects:\n        - Writes data to the file specified by `self.file_path`.\n        - Displays a success message box upon successful save.\n        - Displays an error message box if an exception occurs.\n\n    Notes:\n        - The `district` and `point` values are converted to uppercase before saving.\n        - The `battery` and `active` values are retrieved from checkbox widgets in the table.\n\n    \"\"\"\n    try:\n        with open(self.file_path, 'w') as file:\n            for row in range(self.table_widget.rowCount()):\n                district = self.table_widget.item(row, 0).text().upper()\n                model = self.table_widget.item(row, 1).text()\n                point = self.table_widget.item(row, 2).text().upper()\n                ip = self.table_widget.item(row, 3).text()\n                id = self.table_widget.item(row, 4).text()\n                communication = self.table_widget.item(row, 5).text()\n                battery = self.table_widget.cellWidget(row, 6).isChecked()\n                active = self.table_widget.cellWidget(row, 7).isChecked()\n                #logging.debug(f\"{district} - {model} - {point} - {ip} - {id} - {communication} - {battery} - {active}\")\n                file.write(f\"{district} - {model} - {point} - {ip} - {id} - {communication} - {battery} - {active}\\n\")\n        QMessageBox.information(self, \"\u00c9xito\", \"Datos guardados correctamente.\")\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog","title":"<code>obtain_attendances_devices_dialog</code>","text":""},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog","title":"<code>ObtainAttendancesDevicesDialog</code>","text":"<p>               Bases: <code>SelectDevicesDialog</code></p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>class ObtainAttendancesDevicesDialog(SelectDevicesDialog):\n    def __init__(self, parent=None):\n        \"\"\"\n        Initializes the ObtainAttendancesDevicesDialog class.\n\n        Args:\n            parent (Optional[QWidget]): The parent widget for this dialog. Defaults to None.\n\n        Attributes:\n            failed_devices (list[str]): A list to store devices that failed during the operation.\n            attendances_manager (AttendancesManager): An instance of AttendancesManager to handle attendance management.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.\n        \"\"\"\n        try:\n            self.failed_devices: list[str] = []\n            self.attendances_manager = AttendancesManager()\n            super().__init__(parent, op_function=self.attendances_manager.manage_devices_attendances, window_title=\"OBTENER MARCACIONES\")\n            self.init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the attendance devices dialog.\n\n        This method sets up the UI components, including labels, buttons, and layouts,\n        to display and manage attendance device information. It also configures event\n        handlers for user interactions.\n\n        Raises:\n            BaseError: If an exception occurs during the initialization process, it\n                       raises a BaseError with code 3501 and the exception message.\n\n        UI Components:\n            - Header Labels: [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n            - QPushButton: A button to retry failed connections, initially hidden.\n            - QPushButton: A button to update and obtain attendance records, with updated text.\n            - QLabel: A label to display the total number of attendances, initially hidden.\n        \"\"\"\n        try:\n            header_labels = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n            super().init_ui(header_labels=header_labels)\n            self.btn_retry_failed_connection = QPushButton(\"Reintentar fallidos\", self)\n            self.btn_retry_failed_connection.clicked.connect(self.on_retry_failed_connection_clicked)\n            self.button_layout.addWidget(self.btn_retry_failed_connection)\n            self.btn_retry_failed_connection.setVisible(False)\n            self.btn_update.setText(\"Obtener marcaciones\")\n            self.label_total_attendances = QLabel(\"Total de Marcaciones: 0\", self)\n            self.label_total_attendances.setAlignment(Qt.AlignCenter)\n            self.layout().addWidget(self.label_total_attendances)\n            self.label_total_attendances.setVisible(False)\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def operation_with_selected_ips(self):\n        \"\"\"\n        Executes an operation with the selected IP addresses.\n\n        This method hides the retry button and the total attendances label before\n        attempting to perform the operation. It calls the parent class's \n        `operation_with_selected_ips` method to execute the operation. If an \n        exception occurs during the execution, it displays the retry button \n        for failed connections.\n\n        Exceptions:\n            Exception: Catches any exception that occurs during the operation \n            and triggers the display of the retry button.\n        \"\"\"\n        self.btn_retry_failed_connection.setVisible(False)\n        self.label_total_attendances.setVisible(False)\n        try:\n            super().operation_with_selected_ips()\n        except Exception as e:\n            self.show_btn_retry_failed_connection()\n        return\n\n    def op_terminate(self, devices: dict[str, dict[str, str]] = None):\n        \"\"\"\n        Finalizes the operation of obtaining attendance data from devices and updates the UI accordingly.\n\n        Args:\n            devices (dict[str, dict[str, str]]): A dictionary where the keys are device IPs and the values are dictionaries \n                containing device-specific information, such as \"connection failed\" status and \"attendance count\".\n\n        Functionality:\n            - Iterates through the rows of the table widget to update attendance data for each device.\n            - Checks if the device IP is in the list of selected IPs and updates the corresponding table cell:\n                - Marks devices with failed connections in red and adds them to the failed devices list.\n                - Updates the attendance count for devices with successful connections and marks them in green.\n            - Ensures the \"Cant. de Marcaciones\" column exists in the table and updates it with attendance data.\n            - Calculates the total number of attendances across all devices.\n            - Adjusts the table size, enables sorting, and sorts the table by a specific column in descending order.\n            - Deselects all rows in the table and centers the window.\n            - Attempts to check attendance files and handles any exceptions with a warning-level error.\n            - Displays a retry button for failed connections and updates the total attendance label.\n\n        Raises:\n            BaseErrorWithMessageBox: If an unexpected exception occurs during the operation, it is raised with an error message box.\n        \"\"\"\n        try:\n            self.failed_devices = []\n            #logging.debug(f'selected devices: {self.selected_ips} - devices from operation: {devices} - failed devices: {self.failed_devices}')\n\n            actual_column = self.ensure_column_exists(\"Cant. de Marcaciones\")\n\n            total_marcaciones = 0\n            for row in range (self.table_widget.rowCount()):\n                ip_selected = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n                attendances_count_item = QTableWidgetItem(\"\")\n                if ip_selected not in self.selected_ips:\n                    attendances_count_item.setBackground(QColor(Qt.white))\n                else:\n                    device = devices.get(ip_selected)\n                    if device:\n                        if device.get(\"connection failed\", False):\n                            attendances_count_item.setText(\"Conexi\u00f3n fallida\")\n                            attendances_count_item.setBackground(QColor(Qt.red))\n                            self.failed_devices.append(ip_selected)\n                        else:\n                            attendance_count = device.get(\"attendance count\")\n                            try:\n                                total_marcaciones += int(attendance_count)\n                            except ValueError:\n                                attendance_count = 0\n                                BaseError(3500, f\"Error al obtener la cantidad de marcaciones del dispositivo {ip_selected}\")\n                            attendances_count_item.setText(str(attendance_count))\n                            attendances_count_item.setBackground(QColor(Qt.green))\n                attendances_count_item.setFlags(attendances_count_item.flags() &amp; ~Qt.ItemIsEditable)\n                self.table_widget.setItem(row, actual_column, attendances_count_item)\n            self.adjust_size_to_table()\n            self.table_widget.setSortingEnabled(True)\n            self.table_widget.sortByColumn(6, Qt.DescendingOrder)  \n            self.deselect_all_rows()\n\n            self.center_window()\n            try:\n                self.check_attendance_files()\n            except Exception as e:\n                BaseError(3000, str(e), level=\"warning\")\n            self.show_btn_retry_failed_connection()\n            self.label_total_attendances.setText(f\"Total de Marcaciones: {total_marcaciones}\")\n            self.label_total_attendances.setVisible(True)\n            super().op_terminate()\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n\n    def parse_attendance(self, line: str):\n        \"\"\"\n        Parses a line of attendance data and extracts the timestamp.\n\n        Args:\n            line (str): A string containing attendance data, expected to have at least\n                        three parts separated by spaces, where the second and third parts\n                        represent the date and time respectively.\n\n        Returns:\n            (datetime or None): A datetime object representing the parsed timestamp if the\n                              line is well-formed and the date and time are valid.\n                              Returns None if the line is malformed or the date/time\n                              cannot be parsed.\n        \"\"\"\n        parts = line.split()\n        if len(parts) &lt; 3:\n            return None\n        try:\n            date_str, time_str = parts[1], parts[2]\n            timestamp: datetime = datetime.strptime(f\"{date_str} {time_str}\", \"%d/%m/%Y %H:%M\")\n            return timestamp\n        except ValueError:\n            return None\n\n    def check_attendance_files(self):\n        \"\"\"\n        Checks attendance files in the \"devices\" directory for errors.\n        A daily record (in a temporary file) is kept of each already reported incorrect check\u2011in,\n        so that new ones are only reported once. For reporting, information is grouped by file,\n        displaying each error only once (by file_path) as in the original version.\n\n        Raises:\n            BaseError: if the 'devices' folder is not found or if attendance errors are detected.\n        \"\"\"\n        import tempfile\n        from datetime import timedelta\n\n        # Get today's and yesterday's dates\n        today_str = datetime.now().strftime(\"%Y-%m-%d\")\n        yesterday_str = (datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%d\")\n\n        devices_path = os.path.join(find_root_directory(), \"devices\")\n        temp_dir = tempfile.gettempdir()\n        # logging.debug(f\"Directorio temporal: {temp_dir}\")\n\n        # Temporary file for today and yesterday\n        temp_file_path = os.path.join(\n            temp_dir,\n            f\"reported_incorrect_attendances_{today_str}.tmp\"\n        )\n        temp_file_yesterday = os.path.join(\n            temp_dir,\n            f\"reported_incorrect_attendances_{yesterday_str}.tmp\"\n        )\n\n        # Remove yesterday's file if it exists\n        if os.path.exists(temp_file_yesterday):\n            try:\n                os.remove(temp_file_yesterday)\n            except Exception as e:\n                logging.warning(f\"No se pudo eliminar el archivo de ayer: {e}\")\n\n        # Load errors already reported today: each line is a unique error identifier (file_path + line)\n        reported_errors = set()\n        if os.path.exists(temp_file_path):\n            with open(temp_file_path, \"r\", encoding=\"utf-8\") as tf:\n                for line in tf:\n                    reported_errors.add(line.strip())\n\n        new_reported = set()            # Newly found errors (by line)\n        files_with_new_errors = {}      # Grouped by file: key = file.path, value = info for report\n\n        if not os.path.isdir(devices_path):\n            raise BaseError(3000, \"No se encontr\u00f3 la carpeta 'devices'\", level=\"warning\")\n\n        # Traverse the devices directory\n        with os.scandir(devices_path) as entries:\n            for subfolder in entries:\n                if not subfolder.is_dir():\n                    continue\n\n                subfolder_path = os.path.join(devices_path, subfolder.name)\n                with os.scandir(subfolder_path) as sub_entries:\n                    for sub_entry in sub_entries:\n                        if not sub_entry.is_dir():\n                            continue\n\n                        with os.scandir(sub_entry.path) as files:\n                            for file in files:\n                                if today_str in file.name and file.name.endswith(\".cro\"):\n                                    file_has_new_error = False  # Flag for new errors in this file\n\n                                    with open(file.path, \"r\", encoding=\"utf-8\") as f:\n                                        # Check each line for attendance errors\n                                        for line_number, line in enumerate(f, start=1):\n                                            attendance = Attendance(timestamp=self.parse_attendance(line))\n                                            if attendance is not None and (\n                                                attendance.is_three_months_old() or attendance.is_in_the_future()\n                                            ):\n                                                # Create a unique identifier for this error line\n                                                error_id = str(line)\n                                                if error_id in reported_errors:\n                                                    continue  # This error was already reported\n\n                                                # New error found\n                                                new_reported.add(error_id)\n                                                file_has_new_error = True\n                                                # To continue scanning the file for all new errors (even though only one link per file is shown),\n                                                # do not break here. Uncomment the next line to only report the first occurrence per file.\n                                                # break\n\n                                    if file_has_new_error:\n                                        # Add one entry per file, as in the original version\n                                        if file.path not in files_with_new_errors:\n                                            files_with_new_errors[file.path] = {\n                                                \"ip\": self.extract_ip(file.name),\n                                                \"date\": self.extract_date(file.name),\n                                                \"file_path\": self.format_file_uri(file.path)\n                                            }\n\n        # Append newly found errors to the temporary file\n        if new_reported:\n            with open(temp_file_path, \"a\", encoding=\"utf-8\") as tf:\n                for err in new_reported:\n                    tf.write(err + \"\\n\")\n\n        # Build report from files that have new errors\n        devices_with_error = list(files_with_new_errors.values())\n        if devices_with_error:\n            error_info = (\n                \"&lt;html&gt;&lt;br&gt;\" +\n                \"&lt;br&gt;\".join(\n                    [f\"- &lt;a href='{device['file_path']}'&gt;{device['date']}: {device['ip']}&lt;/a&gt;\"\n                    for device in devices_with_error]\n                ) +\n                \"&lt;/html&gt;\"\n            )\n            error_code = 2003\n            error = BaseError(error_code, error_info)\n\n            config.read(os.path.join(find_root_directory(), 'config.ini'))\n            clear_attendance: bool = config.getboolean('Device_config', 'clear_attendance')\n            if clear_attendance:\n                self.ask_force_clear_attendances(error_code, error_info, parent=self)\n            else:\n                error.show_message_box_html(parent=self)\n\n    def ask_force_clear_attendances(self, error_code, error_info, parent):\n        msg_box = QMessageBox(parent)\n        msg_box.setIcon(QMessageBox.Warning)\n        msg_box.setWindowTitle(f\"Error {error_code}\")\n        msg_box.setTextFormat(Qt.RichText)\n        msg_box.setText(error_info)\n        msg_box.setInformativeText(\"\u00bfDesea habilitar el forzado de eliminado de marcaciones en su proxima obtencion de marcaciones?\")\n        msg_box.setStandardButtons(QMessageBox.Ok | QMessageBox.No)\n        msg_box.setDefaultButton(QMessageBox.No)\n        result = msg_box.exec_()\n        if result == QMessageBox.Ok:\n            config['Device_config']['force_clear_attendance'] = 'True'\n\n            # Write the changes back to the configuration file\n            try:\n                with open('config.ini', 'w') as config_file:\n                    config.write(config_file)\n            except Exception as e:\n                BaseError(3001, str(e))\n\n            logging.info(\"Se ha habilitado el forzado de eliminacion de marcaciones\")\n\n    def format_file_uri(self, file_path: str):\n        \"\"\"\n        Converts a local file path to a file URI.\n\n        This method takes a file path as input, replaces backslashes with forward slashes\n        (to ensure compatibility across different operating systems), and encodes special\n        characters to make the path safe for use in a URI. It then constructs a file URI\n        by prefixing the encoded path with 'file:'.\n\n        Args:\n            file_path (str): The local file path to be converted into a file URI.\n\n        Returns:\n            (str): The formatted file URI.\n        \"\"\"\n        file_url = urllib.parse.urljoin('file:', urllib.parse.quote(file_path.replace(\"\\\\\", \"/\")))\n        # logging.debug(file_url)\n        return file_url\n\n    def extract_ip(self, filename: str):\n        \"\"\"\n        Extracts an IP address from a given filename.\n\n        The method uses a regular expression to match filenames that follow the\n        pattern: `&lt;IP_ADDRESS&gt;_&lt;DATE&gt;_file.cro`, where:\n\n        - `&lt;IP_ADDRESS&gt;` is a valid IPv4 address (e.g., 192.168.1.1).\n        - `&lt;DATE&gt;` is in the format YYYY-MM-DD.\n\n        Args:\n            filename (str): The filename to extract the IP address from.\n\n        Returns:\n            (str): The extracted IP address if the filename matches the pattern, \n                 otherwise None.\n        \"\"\"\n        match = re.match(r\"^(\\d+\\.\\d+\\.\\d+\\.\\d+)_\\d{4}-\\d{2}-\\d{2}_file\\.cro$\", filename)\n        return match.group(1) if match else None\n\n    def extract_date(self, filename: str):\n        \"\"\"\n        Extracts a date string from a given filename if it matches a specific pattern.\n\n        The method uses a regular expression to identify filenames that follow the\n        pattern: `&lt;IP_ADDRESS&gt;_&lt;YYYY-MM-DD&gt;_file.cro`, where:\n\n        - `&lt;IP_ADDRESS&gt;` is a sequence of four groups of digits separated by dots.\n        - `&lt;YYYY-MM-DD&gt;` is a date in the format year-month-day.\n\n        Args:\n            filename (str): The filename to extract the date from.\n\n        Returns:\n            (str or None): The extracted date string in the format 'YYYY-MM-DD' if the\n                        filename matches the pattern; otherwise, None.\n        \"\"\"\n        match = re.match(r\"^\\d+\\.\\d+\\.\\d+\\.\\d+_(\\d{4}-\\d{2}-\\d{2})_file\\.cro$\", filename)\n        return match.group(1) if match else None\n\n    def show_btn_retry_failed_connection(self):\n        \"\"\"\n        Displays the \"Retry Failed Connection\" button if there are failed devices.\n\n        This method checks if the `failed_devices` attribute exists and contains \n        one or more entries. If so, it makes the `btn_retry_failed_connection` \n        button visible. If an exception occurs during execution, it raises a \n        `BaseError` with an appropriate error code and message.\n\n        Raises:\n            BaseError: If an exception occurs, it is wrapped in a `BaseError` \n                       with code 3500 and the exception message.\n        \"\"\"\n        try:            \n            if self.failed_devices and len(self.failed_devices) &gt; 0:\n                self.btn_retry_failed_connection.setVisible(True)\n        except Exception as e:\n            raise BaseError(3500, str(e))\n\n    def on_retry_failed_connection_clicked(self):\n        \"\"\"\n        Handles the retry action for failed device connections.\n\n        This method is triggered when the \"Retry Failed Connection\" button is clicked.\n        It attempts to reconnect to the devices that previously failed to connect and\n        updates the UI to reflect the retry process. A separate thread is used to manage\n        the reconnection attempts and progress updates.\n\n        Steps performed:\n\n        - Hides certain UI elements (e.g., table widget, buttons) and updates labels.\n        - Initializes and starts an `OperationThread` to handle the reconnection logic.\n        - Connects thread signals to appropriate methods for progress updates and cleanup.\n        - Hides the retry button after it is clicked.\n\n        Raises:\n            BaseError: If an exception occurs during the execution of the method.\n\n        Attributes:\n            self.failed_devices (list): List of devices that failed to connect.\n            self.attendances_manager (object): Manager responsible for handling device attendances.\n        \"\"\"\n        try:\n            self.table_widget.setVisible(False)\n            self.table_widget.sortByColumn(3, Qt.DescendingOrder)\n            self.label_total_attendances.setVisible(False)\n            self.label_updating.setText(\"Reintentando conexiones...\")\n            self.btn_update.setVisible(False)\n            self.btn_activate_all.setVisible(False)\n            self.btn_deactivate_all.setVisible(False)\n            self.label_updating.setVisible(True)\n            self.progress_bar.setVisible(True)\n            self.progress_bar.setValue(0)\n            # logging.debug(f\"Dispositivos seleccionados: {self.failed_devices}\")\n            self.op_thread = OperationThread(self.attendances_manager.manage_devices_attendances, self.failed_devices)\n            self.op_thread.progress_updated.connect(self.update_progress)\n            self.op_thread.op_terminate.connect(self.op_terminate)\n            self.op_thread.finished.connect(self.cleanup_thread)\n            self.op_thread.start()\n            self.btn_retry_failed_connection.setVisible(False)  # Hide the button after clicking\n        except Exception as e:\n            raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the ObtainAttendancesDevicesDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>failed_devices</code> <code>list[str]</code> <p>A list to store devices that failed during the operation.</p> <code>attendances_manager</code> <code>AttendancesManager</code> <p>An instance of AttendancesManager to handle attendance management.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Initializes the ObtainAttendancesDevicesDialog class.\n\n    Args:\n        parent (Optional[QWidget]): The parent widget for this dialog. Defaults to None.\n\n    Attributes:\n        failed_devices (list[str]): A list to store devices that failed during the operation.\n        attendances_manager (AttendancesManager): An instance of AttendancesManager to handle attendance management.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.\n    \"\"\"\n    try:\n        self.failed_devices: list[str] = []\n        self.attendances_manager = AttendancesManager()\n        super().__init__(parent, op_function=self.attendances_manager.manage_devices_attendances, window_title=\"OBTENER MARCACIONES\")\n        self.init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.check_attendance_files","title":"<code>check_attendance_files()</code>","text":"<p>Checks attendance files in the \"devices\" directory for errors. A daily record (in a temporary file) is kept of each already reported incorrect check\u2011in, so that new ones are only reported once. For reporting, information is grouped by file, displaying each error only once (by file_path) as in the original version.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>if the 'devices' folder is not found or if attendance errors are detected.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def check_attendance_files(self):\n    \"\"\"\n    Checks attendance files in the \"devices\" directory for errors.\n    A daily record (in a temporary file) is kept of each already reported incorrect check\u2011in,\n    so that new ones are only reported once. For reporting, information is grouped by file,\n    displaying each error only once (by file_path) as in the original version.\n\n    Raises:\n        BaseError: if the 'devices' folder is not found or if attendance errors are detected.\n    \"\"\"\n    import tempfile\n    from datetime import timedelta\n\n    # Get today's and yesterday's dates\n    today_str = datetime.now().strftime(\"%Y-%m-%d\")\n    yesterday_str = (datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%d\")\n\n    devices_path = os.path.join(find_root_directory(), \"devices\")\n    temp_dir = tempfile.gettempdir()\n    # logging.debug(f\"Directorio temporal: {temp_dir}\")\n\n    # Temporary file for today and yesterday\n    temp_file_path = os.path.join(\n        temp_dir,\n        f\"reported_incorrect_attendances_{today_str}.tmp\"\n    )\n    temp_file_yesterday = os.path.join(\n        temp_dir,\n        f\"reported_incorrect_attendances_{yesterday_str}.tmp\"\n    )\n\n    # Remove yesterday's file if it exists\n    if os.path.exists(temp_file_yesterday):\n        try:\n            os.remove(temp_file_yesterday)\n        except Exception as e:\n            logging.warning(f\"No se pudo eliminar el archivo de ayer: {e}\")\n\n    # Load errors already reported today: each line is a unique error identifier (file_path + line)\n    reported_errors = set()\n    if os.path.exists(temp_file_path):\n        with open(temp_file_path, \"r\", encoding=\"utf-8\") as tf:\n            for line in tf:\n                reported_errors.add(line.strip())\n\n    new_reported = set()            # Newly found errors (by line)\n    files_with_new_errors = {}      # Grouped by file: key = file.path, value = info for report\n\n    if not os.path.isdir(devices_path):\n        raise BaseError(3000, \"No se encontr\u00f3 la carpeta 'devices'\", level=\"warning\")\n\n    # Traverse the devices directory\n    with os.scandir(devices_path) as entries:\n        for subfolder in entries:\n            if not subfolder.is_dir():\n                continue\n\n            subfolder_path = os.path.join(devices_path, subfolder.name)\n            with os.scandir(subfolder_path) as sub_entries:\n                for sub_entry in sub_entries:\n                    if not sub_entry.is_dir():\n                        continue\n\n                    with os.scandir(sub_entry.path) as files:\n                        for file in files:\n                            if today_str in file.name and file.name.endswith(\".cro\"):\n                                file_has_new_error = False  # Flag for new errors in this file\n\n                                with open(file.path, \"r\", encoding=\"utf-8\") as f:\n                                    # Check each line for attendance errors\n                                    for line_number, line in enumerate(f, start=1):\n                                        attendance = Attendance(timestamp=self.parse_attendance(line))\n                                        if attendance is not None and (\n                                            attendance.is_three_months_old() or attendance.is_in_the_future()\n                                        ):\n                                            # Create a unique identifier for this error line\n                                            error_id = str(line)\n                                            if error_id in reported_errors:\n                                                continue  # This error was already reported\n\n                                            # New error found\n                                            new_reported.add(error_id)\n                                            file_has_new_error = True\n                                            # To continue scanning the file for all new errors (even though only one link per file is shown),\n                                            # do not break here. Uncomment the next line to only report the first occurrence per file.\n                                            # break\n\n                                if file_has_new_error:\n                                    # Add one entry per file, as in the original version\n                                    if file.path not in files_with_new_errors:\n                                        files_with_new_errors[file.path] = {\n                                            \"ip\": self.extract_ip(file.name),\n                                            \"date\": self.extract_date(file.name),\n                                            \"file_path\": self.format_file_uri(file.path)\n                                        }\n\n    # Append newly found errors to the temporary file\n    if new_reported:\n        with open(temp_file_path, \"a\", encoding=\"utf-8\") as tf:\n            for err in new_reported:\n                tf.write(err + \"\\n\")\n\n    # Build report from files that have new errors\n    devices_with_error = list(files_with_new_errors.values())\n    if devices_with_error:\n        error_info = (\n            \"&lt;html&gt;&lt;br&gt;\" +\n            \"&lt;br&gt;\".join(\n                [f\"- &lt;a href='{device['file_path']}'&gt;{device['date']}: {device['ip']}&lt;/a&gt;\"\n                for device in devices_with_error]\n            ) +\n            \"&lt;/html&gt;\"\n        )\n        error_code = 2003\n        error = BaseError(error_code, error_info)\n\n        config.read(os.path.join(find_root_directory(), 'config.ini'))\n        clear_attendance: bool = config.getboolean('Device_config', 'clear_attendance')\n        if clear_attendance:\n            self.ask_force_clear_attendances(error_code, error_info, parent=self)\n        else:\n            error.show_message_box_html(parent=self)\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.extract_date","title":"<code>extract_date(filename)</code>","text":"<p>Extracts a date string from a given filename if it matches a specific pattern.</p> <p>The method uses a regular expression to identify filenames that follow the pattern: <code>&lt;IP_ADDRESS&gt;_&lt;YYYY-MM-DD&gt;_file.cro</code>, where:</p> <ul> <li><code>&lt;IP_ADDRESS&gt;</code> is a sequence of four groups of digits separated by dots.</li> <li><code>&lt;YYYY-MM-DD&gt;</code> is a date in the format year-month-day.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to extract the date from.</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>The extracted date string in the format 'YYYY-MM-DD' if the         filename matches the pattern; otherwise, None.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def extract_date(self, filename: str):\n    \"\"\"\n    Extracts a date string from a given filename if it matches a specific pattern.\n\n    The method uses a regular expression to identify filenames that follow the\n    pattern: `&lt;IP_ADDRESS&gt;_&lt;YYYY-MM-DD&gt;_file.cro`, where:\n\n    - `&lt;IP_ADDRESS&gt;` is a sequence of four groups of digits separated by dots.\n    - `&lt;YYYY-MM-DD&gt;` is a date in the format year-month-day.\n\n    Args:\n        filename (str): The filename to extract the date from.\n\n    Returns:\n        (str or None): The extracted date string in the format 'YYYY-MM-DD' if the\n                    filename matches the pattern; otherwise, None.\n    \"\"\"\n    match = re.match(r\"^\\d+\\.\\d+\\.\\d+\\.\\d+_(\\d{4}-\\d{2}-\\d{2})_file\\.cro$\", filename)\n    return match.group(1) if match else None\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.extract_ip","title":"<code>extract_ip(filename)</code>","text":"<p>Extracts an IP address from a given filename.</p> <p>The method uses a regular expression to match filenames that follow the pattern: <code>&lt;IP_ADDRESS&gt;_&lt;DATE&gt;_file.cro</code>, where:</p> <ul> <li><code>&lt;IP_ADDRESS&gt;</code> is a valid IPv4 address (e.g., 192.168.1.1).</li> <li><code>&lt;DATE&gt;</code> is in the format YYYY-MM-DD.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to extract the IP address from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The extracted IP address if the filename matches the pattern,   otherwise None.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def extract_ip(self, filename: str):\n    \"\"\"\n    Extracts an IP address from a given filename.\n\n    The method uses a regular expression to match filenames that follow the\n    pattern: `&lt;IP_ADDRESS&gt;_&lt;DATE&gt;_file.cro`, where:\n\n    - `&lt;IP_ADDRESS&gt;` is a valid IPv4 address (e.g., 192.168.1.1).\n    - `&lt;DATE&gt;` is in the format YYYY-MM-DD.\n\n    Args:\n        filename (str): The filename to extract the IP address from.\n\n    Returns:\n        (str): The extracted IP address if the filename matches the pattern, \n             otherwise None.\n    \"\"\"\n    match = re.match(r\"^(\\d+\\.\\d+\\.\\d+\\.\\d+)_\\d{4}-\\d{2}-\\d{2}_file\\.cro$\", filename)\n    return match.group(1) if match else None\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.format_file_uri","title":"<code>format_file_uri(file_path)</code>","text":"<p>Converts a local file path to a file URI.</p> <p>This method takes a file path as input, replaces backslashes with forward slashes (to ensure compatibility across different operating systems), and encodes special characters to make the path safe for use in a URI. It then constructs a file URI by prefixing the encoded path with 'file:'.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The local file path to be converted into a file URI.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted file URI.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def format_file_uri(self, file_path: str):\n    \"\"\"\n    Converts a local file path to a file URI.\n\n    This method takes a file path as input, replaces backslashes with forward slashes\n    (to ensure compatibility across different operating systems), and encodes special\n    characters to make the path safe for use in a URI. It then constructs a file URI\n    by prefixing the encoded path with 'file:'.\n\n    Args:\n        file_path (str): The local file path to be converted into a file URI.\n\n    Returns:\n        (str): The formatted file URI.\n    \"\"\"\n    file_url = urllib.parse.urljoin('file:', urllib.parse.quote(file_path.replace(\"\\\\\", \"/\")))\n    # logging.debug(file_url)\n    return file_url\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the attendance devices dialog.</p> <p>This method sets up the UI components, including labels, buttons, and layouts, to display and manage attendance device information. It also configures event handlers for user interactions.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the initialization process, it        raises a BaseError with code 3501 and the exception message.</p> UI Components <ul> <li>Header Labels: [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]</li> <li>QPushButton: A button to retry failed connections, initially hidden.</li> <li>QPushButton: A button to update and obtain attendance records, with updated text.</li> <li>QLabel: A label to display the total number of attendances, initially hidden.</li> </ul> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the attendance devices dialog.\n\n    This method sets up the UI components, including labels, buttons, and layouts,\n    to display and manage attendance device information. It also configures event\n    handlers for user interactions.\n\n    Raises:\n        BaseError: If an exception occurs during the initialization process, it\n                   raises a BaseError with code 3501 and the exception message.\n\n    UI Components:\n        - Header Labels: [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n        - QPushButton: A button to retry failed connections, initially hidden.\n        - QPushButton: A button to update and obtain attendance records, with updated text.\n        - QLabel: A label to display the total number of attendances, initially hidden.\n    \"\"\"\n    try:\n        header_labels = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n        super().init_ui(header_labels=header_labels)\n        self.btn_retry_failed_connection = QPushButton(\"Reintentar fallidos\", self)\n        self.btn_retry_failed_connection.clicked.connect(self.on_retry_failed_connection_clicked)\n        self.button_layout.addWidget(self.btn_retry_failed_connection)\n        self.btn_retry_failed_connection.setVisible(False)\n        self.btn_update.setText(\"Obtener marcaciones\")\n        self.label_total_attendances = QLabel(\"Total de Marcaciones: 0\", self)\n        self.label_total_attendances.setAlignment(Qt.AlignCenter)\n        self.layout().addWidget(self.label_total_attendances)\n        self.label_total_attendances.setVisible(False)\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.on_retry_failed_connection_clicked","title":"<code>on_retry_failed_connection_clicked()</code>","text":"<p>Handles the retry action for failed device connections.</p> <p>This method is triggered when the \"Retry Failed Connection\" button is clicked. It attempts to reconnect to the devices that previously failed to connect and updates the UI to reflect the retry process. A separate thread is used to manage the reconnection attempts and progress updates.</p> <p>Steps performed:</p> <ul> <li>Hides certain UI elements (e.g., table widget, buttons) and updates labels.</li> <li>Initializes and starts an <code>OperationThread</code> to handle the reconnection logic.</li> <li>Connects thread signals to appropriate methods for progress updates and cleanup.</li> <li>Hides the retry button after it is clicked.</li> </ul> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the execution of the method.</p> <p>Attributes:</p> Name Type Description <code>self.failed_devices</code> <code>list</code> <p>List of devices that failed to connect.</p> <code>self.attendances_manager</code> <code>object</code> <p>Manager responsible for handling device attendances.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def on_retry_failed_connection_clicked(self):\n    \"\"\"\n    Handles the retry action for failed device connections.\n\n    This method is triggered when the \"Retry Failed Connection\" button is clicked.\n    It attempts to reconnect to the devices that previously failed to connect and\n    updates the UI to reflect the retry process. A separate thread is used to manage\n    the reconnection attempts and progress updates.\n\n    Steps performed:\n\n    - Hides certain UI elements (e.g., table widget, buttons) and updates labels.\n    - Initializes and starts an `OperationThread` to handle the reconnection logic.\n    - Connects thread signals to appropriate methods for progress updates and cleanup.\n    - Hides the retry button after it is clicked.\n\n    Raises:\n        BaseError: If an exception occurs during the execution of the method.\n\n    Attributes:\n        self.failed_devices (list): List of devices that failed to connect.\n        self.attendances_manager (object): Manager responsible for handling device attendances.\n    \"\"\"\n    try:\n        self.table_widget.setVisible(False)\n        self.table_widget.sortByColumn(3, Qt.DescendingOrder)\n        self.label_total_attendances.setVisible(False)\n        self.label_updating.setText(\"Reintentando conexiones...\")\n        self.btn_update.setVisible(False)\n        self.btn_activate_all.setVisible(False)\n        self.btn_deactivate_all.setVisible(False)\n        self.label_updating.setVisible(True)\n        self.progress_bar.setVisible(True)\n        self.progress_bar.setValue(0)\n        # logging.debug(f\"Dispositivos seleccionados: {self.failed_devices}\")\n        self.op_thread = OperationThread(self.attendances_manager.manage_devices_attendances, self.failed_devices)\n        self.op_thread.progress_updated.connect(self.update_progress)\n        self.op_thread.op_terminate.connect(self.op_terminate)\n        self.op_thread.finished.connect(self.cleanup_thread)\n        self.op_thread.start()\n        self.btn_retry_failed_connection.setVisible(False)  # Hide the button after clicking\n    except Exception as e:\n        raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.op_terminate","title":"<code>op_terminate(devices=None)</code>","text":"<p>Finalizes the operation of obtaining attendance data from devices and updates the UI accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>dict[str, dict[str, str]]</code> <p>A dictionary where the keys are device IPs and the values are dictionaries  containing device-specific information, such as \"connection failed\" status and \"attendance count\".</p> <code>None</code> Functionality <ul> <li>Iterates through the rows of the table widget to update attendance data for each device.</li> <li>Checks if the device IP is in the list of selected IPs and updates the corresponding table cell:<ul> <li>Marks devices with failed connections in red and adds them to the failed devices list.</li> <li>Updates the attendance count for devices with successful connections and marks them in green.</li> </ul> </li> <li>Ensures the \"Cant. de Marcaciones\" column exists in the table and updates it with attendance data.</li> <li>Calculates the total number of attendances across all devices.</li> <li>Adjusts the table size, enables sorting, and sorts the table by a specific column in descending order.</li> <li>Deselects all rows in the table and centers the window.</li> <li>Attempts to check attendance files and handles any exceptions with a warning-level error.</li> <li>Displays a retry button for failed connections and updates the total attendance label.</li> </ul> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an unexpected exception occurs during the operation, it is raised with an error message box.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def op_terminate(self, devices: dict[str, dict[str, str]] = None):\n    \"\"\"\n    Finalizes the operation of obtaining attendance data from devices and updates the UI accordingly.\n\n    Args:\n        devices (dict[str, dict[str, str]]): A dictionary where the keys are device IPs and the values are dictionaries \n            containing device-specific information, such as \"connection failed\" status and \"attendance count\".\n\n    Functionality:\n        - Iterates through the rows of the table widget to update attendance data for each device.\n        - Checks if the device IP is in the list of selected IPs and updates the corresponding table cell:\n            - Marks devices with failed connections in red and adds them to the failed devices list.\n            - Updates the attendance count for devices with successful connections and marks them in green.\n        - Ensures the \"Cant. de Marcaciones\" column exists in the table and updates it with attendance data.\n        - Calculates the total number of attendances across all devices.\n        - Adjusts the table size, enables sorting, and sorts the table by a specific column in descending order.\n        - Deselects all rows in the table and centers the window.\n        - Attempts to check attendance files and handles any exceptions with a warning-level error.\n        - Displays a retry button for failed connections and updates the total attendance label.\n\n    Raises:\n        BaseErrorWithMessageBox: If an unexpected exception occurs during the operation, it is raised with an error message box.\n    \"\"\"\n    try:\n        self.failed_devices = []\n        #logging.debug(f'selected devices: {self.selected_ips} - devices from operation: {devices} - failed devices: {self.failed_devices}')\n\n        actual_column = self.ensure_column_exists(\"Cant. de Marcaciones\")\n\n        total_marcaciones = 0\n        for row in range (self.table_widget.rowCount()):\n            ip_selected = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n            attendances_count_item = QTableWidgetItem(\"\")\n            if ip_selected not in self.selected_ips:\n                attendances_count_item.setBackground(QColor(Qt.white))\n            else:\n                device = devices.get(ip_selected)\n                if device:\n                    if device.get(\"connection failed\", False):\n                        attendances_count_item.setText(\"Conexi\u00f3n fallida\")\n                        attendances_count_item.setBackground(QColor(Qt.red))\n                        self.failed_devices.append(ip_selected)\n                    else:\n                        attendance_count = device.get(\"attendance count\")\n                        try:\n                            total_marcaciones += int(attendance_count)\n                        except ValueError:\n                            attendance_count = 0\n                            BaseError(3500, f\"Error al obtener la cantidad de marcaciones del dispositivo {ip_selected}\")\n                        attendances_count_item.setText(str(attendance_count))\n                        attendances_count_item.setBackground(QColor(Qt.green))\n            attendances_count_item.setFlags(attendances_count_item.flags() &amp; ~Qt.ItemIsEditable)\n            self.table_widget.setItem(row, actual_column, attendances_count_item)\n        self.adjust_size_to_table()\n        self.table_widget.setSortingEnabled(True)\n        self.table_widget.sortByColumn(6, Qt.DescendingOrder)  \n        self.deselect_all_rows()\n\n        self.center_window()\n        try:\n            self.check_attendance_files()\n        except Exception as e:\n            BaseError(3000, str(e), level=\"warning\")\n        self.show_btn_retry_failed_connection()\n        self.label_total_attendances.setText(f\"Total de Marcaciones: {total_marcaciones}\")\n        self.label_total_attendances.setVisible(True)\n        super().op_terminate()\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.operation_with_selected_ips","title":"<code>operation_with_selected_ips()</code>","text":"<p>Executes an operation with the selected IP addresses.</p> <p>This method hides the retry button and the total attendances label before attempting to perform the operation. It calls the parent class's  <code>operation_with_selected_ips</code> method to execute the operation. If an  exception occurs during the execution, it displays the retry button  for failed connections.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Catches any exception that occurs during the operation </p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def operation_with_selected_ips(self):\n    \"\"\"\n    Executes an operation with the selected IP addresses.\n\n    This method hides the retry button and the total attendances label before\n    attempting to perform the operation. It calls the parent class's \n    `operation_with_selected_ips` method to execute the operation. If an \n    exception occurs during the execution, it displays the retry button \n    for failed connections.\n\n    Exceptions:\n        Exception: Catches any exception that occurs during the operation \n        and triggers the display of the retry button.\n    \"\"\"\n    self.btn_retry_failed_connection.setVisible(False)\n    self.label_total_attendances.setVisible(False)\n    try:\n        super().operation_with_selected_ips()\n    except Exception as e:\n        self.show_btn_retry_failed_connection()\n    return\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.parse_attendance","title":"<code>parse_attendance(line)</code>","text":"<p>Parses a line of attendance data and extracts the timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A string containing attendance data, expected to have at least         three parts separated by spaces, where the second and third parts         represent the date and time respectively.</p> required <p>Returns:</p> Type Description <code>datetime or None</code> <p>A datetime object representing the parsed timestamp if the               line is well-formed and the date and time are valid.               Returns None if the line is malformed or the date/time               cannot be parsed.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def parse_attendance(self, line: str):\n    \"\"\"\n    Parses a line of attendance data and extracts the timestamp.\n\n    Args:\n        line (str): A string containing attendance data, expected to have at least\n                    three parts separated by spaces, where the second and third parts\n                    represent the date and time respectively.\n\n    Returns:\n        (datetime or None): A datetime object representing the parsed timestamp if the\n                          line is well-formed and the date and time are valid.\n                          Returns None if the line is malformed or the date/time\n                          cannot be parsed.\n    \"\"\"\n    parts = line.split()\n    if len(parts) &lt; 3:\n        return None\n    try:\n        date_str, time_str = parts[1], parts[2]\n        timestamp: datetime = datetime.strptime(f\"{date_str} {time_str}\", \"%d/%m/%Y %H:%M\")\n        return timestamp\n    except ValueError:\n        return None\n</code></pre>"},{"location":"api/#src.ui.obtain_attendances_devices_dialog.ObtainAttendancesDevicesDialog.show_btn_retry_failed_connection","title":"<code>show_btn_retry_failed_connection()</code>","text":"<p>Displays the \"Retry Failed Connection\" button if there are failed devices.</p> <p>This method checks if the <code>failed_devices</code> attribute exists and contains  one or more entries. If so, it makes the <code>btn_retry_failed_connection</code>  button visible. If an exception occurs during execution, it raises a  <code>BaseError</code> with an appropriate error code and message.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs, it is wrapped in a <code>BaseError</code>         with code 3500 and the exception message.</p> Source code in <code>src\\ui\\obtain_attendances_devices_dialog.py</code> <pre><code>def show_btn_retry_failed_connection(self):\n    \"\"\"\n    Displays the \"Retry Failed Connection\" button if there are failed devices.\n\n    This method checks if the `failed_devices` attribute exists and contains \n    one or more entries. If so, it makes the `btn_retry_failed_connection` \n    button visible. If an exception occurs during execution, it raises a \n    `BaseError` with an appropriate error code and message.\n\n    Raises:\n        BaseError: If an exception occurs, it is wrapped in a `BaseError` \n                   with code 3500 and the exception message.\n    \"\"\"\n    try:            \n        if self.failed_devices and len(self.failed_devices) &gt; 0:\n            self.btn_retry_failed_connection.setVisible(True)\n    except Exception as e:\n        raise BaseError(3500, str(e))\n</code></pre>"},{"location":"api/#src.ui.operation_thread","title":"<code>operation_thread</code>","text":""},{"location":"api/#src.ui.operation_thread.OperationThread","title":"<code>OperationThread</code>","text":"<p>               Bases: <code>QThread</code></p> Source code in <code>src\\ui\\operation_thread.py</code> <pre><code>class OperationThread(QThread):\n    op_terminate = pyqtSignal(dict)\n    op_start_time = pyqtSignal(float)\n    progress_updated = pyqtSignal(int, str, int, int)  # Signal for progress\n\n    def __init__(self, op_func: Callable, selected_ips: list[str] = None, parent = None):\n        \"\"\"\n        Initializes the OperationThread instance.\n\n        Args:\n            op_func (Callable): The operation function to be executed in the thread.\n            selected_ips (list[str], optional): A list of selected IP addresses. Defaults to None.\n            parent (QObject, optional): The parent object for the thread. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self.op_func: Callable = op_func\n        self.selected_ips: list[str] = selected_ips\n        self.result: dict = {}\n\n    def run(self):\n        \"\"\"\n        Executes the operation function (`op_func`) with the selected IPs or without them,\n        handles the result, and emits appropriate signals.\n\n        This method is designed to run in a separate thread to perform operations\n        asynchronously. It captures any exceptions raised during execution and\n        raises a `BaseError` with a specific error code and message.\n\n        Attributes:\n            selected_ips (list): A list of selected IP addresses to pass to the operation\n                function. If not provided, the operation function is called without IPs.\n            result (dict): The result of the operation function execution.\n\n        Emits:\n            op_terminate (dict): Signal emitted with the result of the operation function\n                or an empty dictionary if the result is `None`.\n\n        Raises:\n            BaseError: If an exception occurs during the execution of the operation\n                function, a `BaseError` is raised with error code 3000 and the exception\n                message.\n        \"\"\"\n        try:\n            #import time\n            #start_time: float = time.time()\n            if self.selected_ips:\n                self.result: dict = self.op_func(self.selected_ips, emit_progress=self.emit_progress)\n            else:\n                self.result: dict = self.op_func(emit_progress=self.emit_progress)\n            if self.result is None:\n                self.op_terminate.emit({})\n            else:\n                self.op_terminate.emit(self.result)\n            #self.op_start_time.emit(start_time)\n        except Exception as e:\n            raise BaseError(3000, str(e), \"critical\")\n\n    def emit_progress(self, percent_progress: int = None, device_progress: str = None, processed_devices: int = None, total_devices: int = None):\n        \"\"\"\n        Emits a progress update signal with the provided progress details.\n\n        Args:\n            percent_progress (int, optional): The overall percentage of progress completed. Defaults to None.\n            device_progress (str, optional): A string describing the progress of the current device. Defaults to None.\n            processed_devices (int, optional): The number of devices that have been processed so far. Defaults to None.\n            total_devices (int, optional): The total number of devices to be processed. Defaults to None.\n        \"\"\"\n        self.progress_updated.emit(percent_progress, device_progress, processed_devices, total_devices)  # Emit the progress signal\n</code></pre>"},{"location":"api/#src.ui.operation_thread.OperationThread.__init__","title":"<code>__init__(op_func, selected_ips=None, parent=None)</code>","text":"<p>Initializes the OperationThread instance.</p> <p>Parameters:</p> Name Type Description Default <code>op_func</code> <code>Callable</code> <p>The operation function to be executed in the thread.</p> required <code>selected_ips</code> <code>list[str]</code> <p>A list of selected IP addresses. Defaults to None.</p> <code>None</code> <code>parent</code> <code>QObject</code> <p>The parent object for the thread. Defaults to None.</p> <code>None</code> Source code in <code>src\\ui\\operation_thread.py</code> <pre><code>def __init__(self, op_func: Callable, selected_ips: list[str] = None, parent = None):\n    \"\"\"\n    Initializes the OperationThread instance.\n\n    Args:\n        op_func (Callable): The operation function to be executed in the thread.\n        selected_ips (list[str], optional): A list of selected IP addresses. Defaults to None.\n        parent (QObject, optional): The parent object for the thread. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self.op_func: Callable = op_func\n    self.selected_ips: list[str] = selected_ips\n    self.result: dict = {}\n</code></pre>"},{"location":"api/#src.ui.operation_thread.OperationThread.emit_progress","title":"<code>emit_progress(percent_progress=None, device_progress=None, processed_devices=None, total_devices=None)</code>","text":"<p>Emits a progress update signal with the provided progress details.</p> <p>Parameters:</p> Name Type Description Default <code>percent_progress</code> <code>int</code> <p>The overall percentage of progress completed. Defaults to None.</p> <code>None</code> <code>device_progress</code> <code>str</code> <p>A string describing the progress of the current device. Defaults to None.</p> <code>None</code> <code>processed_devices</code> <code>int</code> <p>The number of devices that have been processed so far. Defaults to None.</p> <code>None</code> <code>total_devices</code> <code>int</code> <p>The total number of devices to be processed. Defaults to None.</p> <code>None</code> Source code in <code>src\\ui\\operation_thread.py</code> <pre><code>def emit_progress(self, percent_progress: int = None, device_progress: str = None, processed_devices: int = None, total_devices: int = None):\n    \"\"\"\n    Emits a progress update signal with the provided progress details.\n\n    Args:\n        percent_progress (int, optional): The overall percentage of progress completed. Defaults to None.\n        device_progress (str, optional): A string describing the progress of the current device. Defaults to None.\n        processed_devices (int, optional): The number of devices that have been processed so far. Defaults to None.\n        total_devices (int, optional): The total number of devices to be processed. Defaults to None.\n    \"\"\"\n    self.progress_updated.emit(percent_progress, device_progress, processed_devices, total_devices)  # Emit the progress signal\n</code></pre>"},{"location":"api/#src.ui.operation_thread.OperationThread.run","title":"<code>run()</code>","text":"<p>Executes the operation function (<code>op_func</code>) with the selected IPs or without them, handles the result, and emits appropriate signals.</p> <p>This method is designed to run in a separate thread to perform operations asynchronously. It captures any exceptions raised during execution and raises a <code>BaseError</code> with a specific error code and message.</p> <p>Attributes:</p> Name Type Description <code>selected_ips</code> <code>list</code> <p>A list of selected IP addresses to pass to the operation function. If not provided, the operation function is called without IPs.</p> <code>result</code> <code>dict</code> <p>The result of the operation function execution.</p> Emits <p>op_terminate (dict): Signal emitted with the result of the operation function     or an empty dictionary if the result is <code>None</code>.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during the execution of the operation function, a <code>BaseError</code> is raised with error code 3000 and the exception message.</p> Source code in <code>src\\ui\\operation_thread.py</code> <pre><code>def run(self):\n    \"\"\"\n    Executes the operation function (`op_func`) with the selected IPs or without them,\n    handles the result, and emits appropriate signals.\n\n    This method is designed to run in a separate thread to perform operations\n    asynchronously. It captures any exceptions raised during execution and\n    raises a `BaseError` with a specific error code and message.\n\n    Attributes:\n        selected_ips (list): A list of selected IP addresses to pass to the operation\n            function. If not provided, the operation function is called without IPs.\n        result (dict): The result of the operation function execution.\n\n    Emits:\n        op_terminate (dict): Signal emitted with the result of the operation function\n            or an empty dictionary if the result is `None`.\n\n    Raises:\n        BaseError: If an exception occurs during the execution of the operation\n            function, a `BaseError` is raised with error code 3000 and the exception\n            message.\n    \"\"\"\n    try:\n        #import time\n        #start_time: float = time.time()\n        if self.selected_ips:\n            self.result: dict = self.op_func(self.selected_ips, emit_progress=self.emit_progress)\n        else:\n            self.result: dict = self.op_func(emit_progress=self.emit_progress)\n        if self.result is None:\n            self.op_terminate.emit({})\n        else:\n            self.op_terminate.emit(self.result)\n        #self.op_start_time.emit(start_time)\n    except Exception as e:\n        raise BaseError(3000, str(e), \"critical\")\n</code></pre>"},{"location":"api/#src.ui.ping_devices_dialog","title":"<code>ping_devices_dialog</code>","text":""},{"location":"api/#src.ui.ping_devices_dialog.PingDevicesDialog","title":"<code>PingDevicesDialog</code>","text":"<p>               Bases: <code>SelectDevicesDialog</code></p> Source code in <code>src\\ui\\ping_devices_dialog.py</code> <pre><code>class PingDevicesDialog(SelectDevicesDialog):\n    def __init__(self, parent=None):\n        \"\"\"\n        Initializes the PingDevicesDialog class.\n\n        This constructor sets up the dialog window for testing device connections.\n        It initializes the user interface and sets the operation function to obtain\n        connection information.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError\n                       with code 3501 and the exception message.\n        \"\"\"\n        try:\n            connection_info = ConnectionsInfo()\n            super().__init__(parent, op_function=connection_info.obtain_connections_info, window_title=\"PROBAR CONEXIONES\")\n            self.init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the ping devices dialog.\n\n        This method sets up the table headers and updates the text of the \n        update button to \"Probar conexiones\" (Test connections).\n\n        Header Labels:\n            - Distrito: Represents the district or region.\n            - Modelo: Represents the device model.\n            - Punto de Marcaci\u00f3n: Represents the marking point.\n            - IP: Represents the IP address of the device.\n            - ID: Represents the device identifier.\n            - Comunicaci\u00f3n: Represents the communication status.\n\n        Overrides:\n            This method overrides the `init_ui` method from the parent class\n            and passes the custom header labels to it.\n        \"\"\"\n        header_labels = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n        super().init_ui(header_labels=header_labels)\n        self.btn_update.setText(\"Probar conexiones\")\n\n    def op_terminate(self, devices=None):\n        \"\"\"\n        Updates the table widget with the connection status and device information for a list of devices.\n        This method iterates through the rows of the table widget and updates the columns with information\n        such as connection status, attendance count, serial number, platform, and firmware version for each device.\n        The information is retrieved from the `devices` dictionary, which maps IP addresses to device data.\n\n        Args:\n            devices (dict, optional): A dictionary where keys are IP addresses (str) and values are dictionaries\n                                      containing device information. Each device dictionary may include:\n\n                - \"connection_failed\" (bool): Indicates if the connection failed.\n                - \"device_info\" (dict): Contains device-specific information such as:\n                    - \"attendance_count\" (int or str): The number of attendance records.\n                    - \"serial_number\" (str): The serial number of the device.\n                    - \"platform\" (str): The platform of the device.\n                    - \"firmware_version\" (str): The firmware version of the device.\n\n        Raises:\n            BaseErrorWithMessageBox: If an exception occurs during the operation, it raises a custom error\n                                     with a message box displaying the error details.\n\n        Notes:\n            - The method ensures that specific columns (\"Estado de Conexi\u00f3n\", \"Cant. de Marcaciones\",\n              \"N\u00famero de Serie\", \"Plataforma\", \"Firmware\") exist in the table widget before updating.\n            - The background color of each cell is updated based on the device's connection status and\n              availability of information.\n            - The table widget is resized and sorted by the 6th column in descending order after updates.\n            - All rows are deselected at the end of the operation.\n        \"\"\"\n        try:\n            #logging.debug(devices)\n\n            # Ensure the \"Estado de Conexi\u00f3n\" column exists\n            connection_column = self.ensure_column_exists(\"Estado de Conexi\u00f3n\")\n            attendance_count_column = self.ensure_column_exists(\"Cant. de Marcaciones\")            \n            serial_number_column = self.ensure_column_exists(\"N\u00famero de Serie\")            \n            platform_column = self.ensure_column_exists(\"Plataforma\")\n            firmware_version_column = self.ensure_column_exists(\"Firmware\")\n\n            for row in range(self.table_widget.rowCount()):\n                ip_selected = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n                connection_item = QTableWidgetItem(\"\")\n                attendance_count_item = QTableWidgetItem(\"\")\n                serial_number_item = QTableWidgetItem(\"\")\n                platform_item = QTableWidgetItem(\"\")\n                firmware_version_item = QTableWidgetItem(\"\")\n\n                if ip_selected not in self.selected_ips:\n                    connection_item.setBackground(QColor(Qt.white))\n                    attendance_count_item.setBackground(QColor(Qt.white))\n                    serial_number_item.setBackground(QColor(Qt.white))\n                    platform_item.setBackground(QColor(Qt.white))\n                    firmware_version_item.setBackground(QColor(Qt.white))\n                else:\n                    device = devices[ip_selected]\n\n                    if device:\n                        if device.get(\"connection_failed\"):\n                            connection_item.setText(\"Conexi\u00f3n fallida\")\n                            connection_item.setBackground(QColor(Qt.red))\n                        else:\n                            connection_item.setText(\"Conexi\u00f3n exitosa\")\n                            connection_item.setBackground(QColor(Qt.green))\n\n                        #logging.debug(str(device))\n                        #logging.debug(str(device.get(\"device_info\", \"\")))\n                        if not device.get(\"device_info\") or not device[\"device_info\"].get(\"attendance_count\"):\n                            attendance_count_item.setText(\"No aplica\")\n                            attendance_count_item.setBackground(QColor(Qt.gray))\n                        else:\n                            attendance_count_item.setText(str(device.get(\"device_info\", \"\").get(\"attendance_count\", \"\")))\n                            attendance_count_item.setBackground(QColor(Qt.green))\n\n                        if not device.get(\"device_info\") or not device[\"device_info\"].get(\"serial_number\"):\n                            serial_number_item.setText(\"No aplica\")\n                            serial_number_item.setBackground(QColor(Qt.gray))\n                        else:\n                            serial_number_item.setText(str(device.get(\"device_info\", \"\").get(\"serial_number\", \"\")))\n                            serial_number_item.setBackground(QColor(Qt.green))\n\n                        if not device.get(\"device_info\") or not device[\"device_info\"].get(\"platform\"):\n                            platform_item.setText(\"No aplica\")\n                            platform_item.setBackground(QColor(Qt.gray))\n                        else:\n                            platform_item.setText(str(device.get(\"device_info\", \"\").get(\"platform\", \"\")))\n                            platform_item.setBackground(QColor(Qt.green))\n\n                        if not device.get(\"device_info\") or not device[\"device_info\"].get(\"firmware_version\"):\n                            firmware_version_item.setText(\"No aplica\")\n                            firmware_version_item.setBackground(QColor(Qt.gray))\n                        else:\n                            firmware_version_item.setText(str(device.get(\"device_info\", \"\").get(\"firmware_version\", \"\")))\n                            firmware_version_item.setBackground(QColor(Qt.green))\n\n                connection_item.setFlags(connection_item.flags() &amp; ~Qt.ItemIsEditable)\n                attendance_count_item.setFlags(attendance_count_item.flags() &amp; ~Qt.ItemIsEditable)\n                serial_number_item.setFlags(serial_number_item.flags() &amp; ~Qt.ItemIsEditable)\n                platform_item.setFlags(platform_item.flags() &amp; ~Qt.ItemIsEditable)\n                firmware_version_item.setFlags(firmware_version_item.flags() &amp; ~Qt.ItemIsEditable)\n\n                self.table_widget.setItem(row, connection_column, connection_item)\n                self.table_widget.setItem(row, attendance_count_column, attendance_count_item)\n                self.table_widget.setItem(row, serial_number_column, serial_number_item)\n                self.table_widget.setItem(row, platform_column, platform_item)\n                self.table_widget.setItem(row, firmware_version_column, firmware_version_item)\n\n            self.adjust_size_to_table()\n\n            self.table_widget.setSortingEnabled(True)\n            self.table_widget.sortByColumn(6, Qt.DescendingOrder)  \n\n            self.deselect_all_rows()\n            super().op_terminate()\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.ping_devices_dialog.PingDevicesDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the PingDevicesDialog class.</p> <p>This constructor sets up the dialog window for testing device connections. It initializes the user interface and sets the operation function to obtain connection information.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError        with code 3501 and the exception message.</p> Source code in <code>src\\ui\\ping_devices_dialog.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Initializes the PingDevicesDialog class.\n\n    This constructor sets up the dialog window for testing device connections.\n    It initializes the user interface and sets the operation function to obtain\n    connection information.\n\n    Args:\n        parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError\n                   with code 3501 and the exception message.\n    \"\"\"\n    try:\n        connection_info = ConnectionsInfo()\n        super().__init__(parent, op_function=connection_info.obtain_connections_info, window_title=\"PROBAR CONEXIONES\")\n        self.init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.ping_devices_dialog.PingDevicesDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the ping devices dialog.</p> <p>This method sets up the table headers and updates the text of the  update button to \"Probar conexiones\" (Test connections).</p> Header Labels <ul> <li>Distrito: Represents the district or region.</li> <li>Modelo: Represents the device model.</li> <li>Punto de Marcaci\u00f3n: Represents the marking point.</li> <li>IP: Represents the IP address of the device.</li> <li>ID: Represents the device identifier.</li> <li>Comunicaci\u00f3n: Represents the communication status.</li> </ul> Overrides <p>This method overrides the <code>init_ui</code> method from the parent class and passes the custom header labels to it.</p> Source code in <code>src\\ui\\ping_devices_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the ping devices dialog.\n\n    This method sets up the table headers and updates the text of the \n    update button to \"Probar conexiones\" (Test connections).\n\n    Header Labels:\n        - Distrito: Represents the district or region.\n        - Modelo: Represents the device model.\n        - Punto de Marcaci\u00f3n: Represents the marking point.\n        - IP: Represents the IP address of the device.\n        - ID: Represents the device identifier.\n        - Comunicaci\u00f3n: Represents the communication status.\n\n    Overrides:\n        This method overrides the `init_ui` method from the parent class\n        and passes the custom header labels to it.\n    \"\"\"\n    header_labels = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n    super().init_ui(header_labels=header_labels)\n    self.btn_update.setText(\"Probar conexiones\")\n</code></pre>"},{"location":"api/#src.ui.ping_devices_dialog.PingDevicesDialog.op_terminate","title":"<code>op_terminate(devices=None)</code>","text":"<p>Updates the table widget with the connection status and device information for a list of devices. This method iterates through the rows of the table widget and updates the columns with information such as connection status, attendance count, serial number, platform, and firmware version for each device. The information is retrieved from the <code>devices</code> dictionary, which maps IP addresses to device data.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>dict</code> <p>A dictionary where keys are IP addresses (str) and values are dictionaries                       containing device information. Each device dictionary may include:</p> <ul> <li>\"connection_failed\" (bool): Indicates if the connection failed.</li> <li>\"device_info\" (dict): Contains device-specific information such as:<ul> <li>\"attendance_count\" (int or str): The number of attendance records.</li> <li>\"serial_number\" (str): The serial number of the device.</li> <li>\"platform\" (str): The platform of the device.</li> <li>\"firmware_version\" (str): The firmware version of the device.</li> </ul> </li> </ul> <code>None</code> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an exception occurs during the operation, it raises a custom error                      with a message box displaying the error details.</p> Notes <ul> <li>The method ensures that specific columns (\"Estado de Conexi\u00f3n\", \"Cant. de Marcaciones\",   \"N\u00famero de Serie\", \"Plataforma\", \"Firmware\") exist in the table widget before updating.</li> <li>The background color of each cell is updated based on the device's connection status and   availability of information.</li> <li>The table widget is resized and sorted by the 6th column in descending order after updates.</li> <li>All rows are deselected at the end of the operation.</li> </ul> Source code in <code>src\\ui\\ping_devices_dialog.py</code> <pre><code>def op_terminate(self, devices=None):\n    \"\"\"\n    Updates the table widget with the connection status and device information for a list of devices.\n    This method iterates through the rows of the table widget and updates the columns with information\n    such as connection status, attendance count, serial number, platform, and firmware version for each device.\n    The information is retrieved from the `devices` dictionary, which maps IP addresses to device data.\n\n    Args:\n        devices (dict, optional): A dictionary where keys are IP addresses (str) and values are dictionaries\n                                  containing device information. Each device dictionary may include:\n\n            - \"connection_failed\" (bool): Indicates if the connection failed.\n            - \"device_info\" (dict): Contains device-specific information such as:\n                - \"attendance_count\" (int or str): The number of attendance records.\n                - \"serial_number\" (str): The serial number of the device.\n                - \"platform\" (str): The platform of the device.\n                - \"firmware_version\" (str): The firmware version of the device.\n\n    Raises:\n        BaseErrorWithMessageBox: If an exception occurs during the operation, it raises a custom error\n                                 with a message box displaying the error details.\n\n    Notes:\n        - The method ensures that specific columns (\"Estado de Conexi\u00f3n\", \"Cant. de Marcaciones\",\n          \"N\u00famero de Serie\", \"Plataforma\", \"Firmware\") exist in the table widget before updating.\n        - The background color of each cell is updated based on the device's connection status and\n          availability of information.\n        - The table widget is resized and sorted by the 6th column in descending order after updates.\n        - All rows are deselected at the end of the operation.\n    \"\"\"\n    try:\n        #logging.debug(devices)\n\n        # Ensure the \"Estado de Conexi\u00f3n\" column exists\n        connection_column = self.ensure_column_exists(\"Estado de Conexi\u00f3n\")\n        attendance_count_column = self.ensure_column_exists(\"Cant. de Marcaciones\")            \n        serial_number_column = self.ensure_column_exists(\"N\u00famero de Serie\")            \n        platform_column = self.ensure_column_exists(\"Plataforma\")\n        firmware_version_column = self.ensure_column_exists(\"Firmware\")\n\n        for row in range(self.table_widget.rowCount()):\n            ip_selected = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n            connection_item = QTableWidgetItem(\"\")\n            attendance_count_item = QTableWidgetItem(\"\")\n            serial_number_item = QTableWidgetItem(\"\")\n            platform_item = QTableWidgetItem(\"\")\n            firmware_version_item = QTableWidgetItem(\"\")\n\n            if ip_selected not in self.selected_ips:\n                connection_item.setBackground(QColor(Qt.white))\n                attendance_count_item.setBackground(QColor(Qt.white))\n                serial_number_item.setBackground(QColor(Qt.white))\n                platform_item.setBackground(QColor(Qt.white))\n                firmware_version_item.setBackground(QColor(Qt.white))\n            else:\n                device = devices[ip_selected]\n\n                if device:\n                    if device.get(\"connection_failed\"):\n                        connection_item.setText(\"Conexi\u00f3n fallida\")\n                        connection_item.setBackground(QColor(Qt.red))\n                    else:\n                        connection_item.setText(\"Conexi\u00f3n exitosa\")\n                        connection_item.setBackground(QColor(Qt.green))\n\n                    #logging.debug(str(device))\n                    #logging.debug(str(device.get(\"device_info\", \"\")))\n                    if not device.get(\"device_info\") or not device[\"device_info\"].get(\"attendance_count\"):\n                        attendance_count_item.setText(\"No aplica\")\n                        attendance_count_item.setBackground(QColor(Qt.gray))\n                    else:\n                        attendance_count_item.setText(str(device.get(\"device_info\", \"\").get(\"attendance_count\", \"\")))\n                        attendance_count_item.setBackground(QColor(Qt.green))\n\n                    if not device.get(\"device_info\") or not device[\"device_info\"].get(\"serial_number\"):\n                        serial_number_item.setText(\"No aplica\")\n                        serial_number_item.setBackground(QColor(Qt.gray))\n                    else:\n                        serial_number_item.setText(str(device.get(\"device_info\", \"\").get(\"serial_number\", \"\")))\n                        serial_number_item.setBackground(QColor(Qt.green))\n\n                    if not device.get(\"device_info\") or not device[\"device_info\"].get(\"platform\"):\n                        platform_item.setText(\"No aplica\")\n                        platform_item.setBackground(QColor(Qt.gray))\n                    else:\n                        platform_item.setText(str(device.get(\"device_info\", \"\").get(\"platform\", \"\")))\n                        platform_item.setBackground(QColor(Qt.green))\n\n                    if not device.get(\"device_info\") or not device[\"device_info\"].get(\"firmware_version\"):\n                        firmware_version_item.setText(\"No aplica\")\n                        firmware_version_item.setBackground(QColor(Qt.gray))\n                    else:\n                        firmware_version_item.setText(str(device.get(\"device_info\", \"\").get(\"firmware_version\", \"\")))\n                        firmware_version_item.setBackground(QColor(Qt.green))\n\n            connection_item.setFlags(connection_item.flags() &amp; ~Qt.ItemIsEditable)\n            attendance_count_item.setFlags(attendance_count_item.flags() &amp; ~Qt.ItemIsEditable)\n            serial_number_item.setFlags(serial_number_item.flags() &amp; ~Qt.ItemIsEditable)\n            platform_item.setFlags(platform_item.flags() &amp; ~Qt.ItemIsEditable)\n            firmware_version_item.setFlags(firmware_version_item.flags() &amp; ~Qt.ItemIsEditable)\n\n            self.table_widget.setItem(row, connection_column, connection_item)\n            self.table_widget.setItem(row, attendance_count_column, attendance_count_item)\n            self.table_widget.setItem(row, serial_number_column, serial_number_item)\n            self.table_widget.setItem(row, platform_column, platform_item)\n            self.table_widget.setItem(row, firmware_version_column, firmware_version_item)\n\n        self.adjust_size_to_table()\n\n        self.table_widget.setSortingEnabled(True)\n        self.table_widget.sortByColumn(6, Qt.DescendingOrder)  \n\n        self.deselect_all_rows()\n        super().op_terminate()\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.restart_devices_dialog","title":"<code>restart_devices_dialog</code>","text":""},{"location":"api/#src.ui.restart_devices_dialog.RestartDevicesDialog","title":"<code>RestartDevicesDialog</code>","text":"<p>               Bases: <code>SelectDevicesDialog</code></p> Source code in <code>src\\ui\\restart_devices_dialog.py</code> <pre><code>class RestartDevicesDialog(SelectDevicesDialog):\n    def __init__(self, parent=None):\n        \"\"\"\n        Initializes the RestartDevicesDialog class.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError\n                       with code 3501 and the exception message.\n        \"\"\"\n        try:\n            restart_manager: RestartManager = RestartManager()\n            super().__init__(parent, op_function=restart_manager.restart_devices, window_title=\"REINICIAR DISPOSITIVOS\")\n            self.init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the restart devices dialog.\n\n        This method sets up the table headers with predefined labels and updates\n        the text of the update button to indicate its purpose as restarting devices.\n\n        Header Labels:\n            - \"Distrito\": Represents the district information.\n            - \"Modelo\": Represents the device model.\n            - \"Punto de Marcaci\u00f3n\": Represents the marking point.\n            - \"IP\": Represents the IP address of the device.\n            - \"ID\": Represents the device ID.\n            - \"Comunicaci\u00f3n\": Represents the communication status of the device.\n        \"\"\"\n        header_labels: list[str] = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n        super().init_ui(header_labels=header_labels)\n        self.btn_update.setText(\"Reiniciar dispositivos\")\n\n    def op_terminate(self, devices_errors: dict[str, dict[str, bool]] = None):\n        \"\"\"\n        Handles the termination operation for devices, displaying appropriate messages\n        based on the presence of errors.\n\n        Args:\n            devices_errors (dict[str, dict[str, bool]]): A dictionary containing device error\n                information. The keys are device identifiers, and the values are dictionaries\n                with error details. Defaults to None.\n\n        Behavior:\n            - If `devices_errors` contains entries, an error message box is displayed with\n              the list of problematic devices.\n            - If `devices_errors` is empty or None, an information message box is displayed\n              indicating successful device restarts.\n            - Logs the `devices_errors` dictionary for debugging purposes.\n            - Calls the parent class's `op_terminate` method after handling the operation.\n\n        Exceptions:\n            - Logs any exceptions that occur during the execution of the method.\n        \"\"\"\n        try:\n            #logging.debug(devices_errors)\n            if len(devices_errors) &gt; 0:\n                error: BaseError = BaseError(2002, f\"{', '.join(devices_errors.keys())}\")\n                error.show_message_box(parent=self)\n            else:\n                QMessageBox.information(self, \"\u00c9xito\", \"Dispositivos reiniciados correctamente\")\n            super().op_terminate()\n        except Exception as e:\n            logging.error(e)\n</code></pre>"},{"location":"api/#src.ui.restart_devices_dialog.RestartDevicesDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the RestartDevicesDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError        with code 3501 and the exception message.</p> Source code in <code>src\\ui\\restart_devices_dialog.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Initializes the RestartDevicesDialog class.\n\n    Args:\n        parent (QWidget, optional): The parent widget for this dialog. Defaults to None.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError\n                   with code 3501 and the exception message.\n    \"\"\"\n    try:\n        restart_manager: RestartManager = RestartManager()\n        super().__init__(parent, op_function=restart_manager.restart_devices, window_title=\"REINICIAR DISPOSITIVOS\")\n        self.init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.restart_devices_dialog.RestartDevicesDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the restart devices dialog.</p> <p>This method sets up the table headers with predefined labels and updates the text of the update button to indicate its purpose as restarting devices.</p> Header Labels <ul> <li>\"Distrito\": Represents the district information.</li> <li>\"Modelo\": Represents the device model.</li> <li>\"Punto de Marcaci\u00f3n\": Represents the marking point.</li> <li>\"IP\": Represents the IP address of the device.</li> <li>\"ID\": Represents the device ID.</li> <li>\"Comunicaci\u00f3n\": Represents the communication status of the device.</li> </ul> Source code in <code>src\\ui\\restart_devices_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the restart devices dialog.\n\n    This method sets up the table headers with predefined labels and updates\n    the text of the update button to indicate its purpose as restarting devices.\n\n    Header Labels:\n        - \"Distrito\": Represents the district information.\n        - \"Modelo\": Represents the device model.\n        - \"Punto de Marcaci\u00f3n\": Represents the marking point.\n        - \"IP\": Represents the IP address of the device.\n        - \"ID\": Represents the device ID.\n        - \"Comunicaci\u00f3n\": Represents the communication status of the device.\n    \"\"\"\n    header_labels: list[str] = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n    super().init_ui(header_labels=header_labels)\n    self.btn_update.setText(\"Reiniciar dispositivos\")\n</code></pre>"},{"location":"api/#src.ui.restart_devices_dialog.RestartDevicesDialog.op_terminate","title":"<code>op_terminate(devices_errors=None)</code>","text":"<p>Handles the termination operation for devices, displaying appropriate messages based on the presence of errors.</p> <p>Parameters:</p> Name Type Description Default <code>devices_errors</code> <code>dict[str, dict[str, bool]]</code> <p>A dictionary containing device error information. The keys are device identifiers, and the values are dictionaries with error details. Defaults to None.</p> <code>None</code> Behavior <ul> <li>If <code>devices_errors</code> contains entries, an error message box is displayed with   the list of problematic devices.</li> <li>If <code>devices_errors</code> is empty or None, an information message box is displayed   indicating successful device restarts.</li> <li>Logs the <code>devices_errors</code> dictionary for debugging purposes.</li> <li>Calls the parent class's <code>op_terminate</code> method after handling the operation.</li> </ul> Source code in <code>src\\ui\\restart_devices_dialog.py</code> <pre><code>def op_terminate(self, devices_errors: dict[str, dict[str, bool]] = None):\n    \"\"\"\n    Handles the termination operation for devices, displaying appropriate messages\n    based on the presence of errors.\n\n    Args:\n        devices_errors (dict[str, dict[str, bool]]): A dictionary containing device error\n            information. The keys are device identifiers, and the values are dictionaries\n            with error details. Defaults to None.\n\n    Behavior:\n        - If `devices_errors` contains entries, an error message box is displayed with\n          the list of problematic devices.\n        - If `devices_errors` is empty or None, an information message box is displayed\n          indicating successful device restarts.\n        - Logs the `devices_errors` dictionary for debugging purposes.\n        - Calls the parent class's `op_terminate` method after handling the operation.\n\n    Exceptions:\n        - Logs any exceptions that occur during the execution of the method.\n    \"\"\"\n    try:\n        #logging.debug(devices_errors)\n        if len(devices_errors) &gt; 0:\n            error: BaseError = BaseError(2002, f\"{', '.join(devices_errors.keys())}\")\n            error.show_message_box(parent=self)\n        else:\n            QMessageBox.information(self, \"\u00c9xito\", \"Dispositivos reiniciados correctamente\")\n        super().op_terminate()\n    except Exception as e:\n        logging.error(e)\n</code></pre>"},{"location":"api/#src.ui.update_time_device_dialog","title":"<code>update_time_device_dialog</code>","text":""},{"location":"api/#src.ui.update_time_device_dialog.UpdateTimeDeviceDialog","title":"<code>UpdateTimeDeviceDialog</code>","text":"<p>               Bases: <code>SelectDevicesDialog</code></p> Source code in <code>src\\ui\\update_time_device_dialog.py</code> <pre><code>class UpdateTimeDeviceDialog(SelectDevicesDialog):\n    def __init__(self, parent = None):\n        \"\"\"\n        Initializes the UpdateTimeDeviceDialog class.\n\n        Args:\n            parent (Optional[QWidget]): The parent widget for this dialog. Defaults to None.\n\n        Attributes:\n            device_info (dict[str, bool]): A dictionary containing device information loaded from `load_device_info()`.\n\n        Raises:\n            BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.\n        \"\"\"\n        try:\n            hour_manager = HourManager()\n            super().__init__(parent, op_function=hour_manager.manage_hour_devices, window_title=\"ACTUALIZAR HORA\")\n            self.device_info: dict[str, bool] = self.load_device_info()\n            self.init_ui()\n        except Exception as e:\n            raise BaseError(3501, str(e))\n\n    def init_ui(self):\n        \"\"\"\n        Initializes the user interface for the update time device dialog.\n\n        This method sets up the table headers with predefined labels and updates\n        the text of the update button to \"Actualizar hora\".\n\n        Header Labels:\n            - Distrito\n            - Modelo\n            - Punto de Marcaci\u00f3n\n            - IP\n            - ID\n            - Comunicaci\u00f3n\n        \"\"\"\n        header_labels: list[str] = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n        super().init_ui(header_labels=header_labels)\n        self.btn_update.setText(\"Actualizar hora\")\n\n    def load_device_info(self):\n        \"\"\"\n        Loads device information from a file and returns it as a dictionary.\n\n        The method reads the file \"info_devices.txt\" line by line, extracts the IP address\n        and battery status from each line, and stores them in a dictionary. The IP address\n        is used as the key, and the battery status (a boolean) is used as the value.\n\n        Returns:\n            (dict[str, bool]): A dictionary where the keys are IP addresses (str) and the\n                            values are battery statuses (bool).\n\n        Raises:\n            BaseErrorWithMessageBox: If an error occurs while reading the file, an exception\n            is raised with an error code and the exception message.\n        \"\"\"\n        device_info: dict[str, bool] = {}\n        try:\n            with open(\"info_devices.txt\", \"r\") as file:\n                for line in file:\n                    parts: list[str] = line.strip().split(\" - \")\n                    if len(parts) == 8:\n                        ip: str = parts[3]\n                        battery_status: bool = parts[6] == \"True\"\n                        device_info[ip] = battery_status\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n        return device_info\n\n    def op_terminate(self, devices_errors: dict[str, dict[str, bool]] = None):\n        \"\"\"\n        Updates the table widget with the connection and battery status of devices.\n        This method processes the `devices_errors` dictionary to update the table widget\n        with the connection and battery status for each device. It ensures that the required\n        columns exist in the table, updates the rows with the appropriate status and colors,\n        and adjusts the table's size and sorting.\n\n        Args:\n            devices_errors (dict[str, dict[str, bool]], optional): A dictionary where the keys\n                are device IP addresses, and the values are dictionaries containing error\n                statuses for the device. The inner dictionary can have the following keys:\n\n                - \"connection failed\" (bool): Indicates if the connection to the device failed.\n                - \"battery failing\" (bool): Indicates if the device's battery is failing.\n\n                Defaults to None.\n\n        Raises:\n            BaseErrorWithMessageBox: If an exception occurs during the operation, it raises\n                a custom error with a message box displaying the error details.\n        \"\"\"\n        #logging.debug(devices_errors)\n        try:\n            connection_column = self.ensure_column_exists(\"Estado de Conexi\u00f3n\")\n            battery_column = self.ensure_column_exists(\"Estado de Pila\")\n\n            for row in range (self.table_widget.rowCount()):\n                ip_selected: str = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n                connection_item: QTableWidgetItem = QTableWidgetItem(\"\")\n                battery_item: QTableWidgetItem = QTableWidgetItem(\"\")\n                if ip_selected not in self.selected_ips:\n                    connection_item.setBackground(QColor(Qt.white))\n                    battery_item.setBackground(QColor(Qt.white))\n                else:\n                    device: dict[str, bool] = devices_errors.get(ip_selected)\n                    if device:\n                        if device.get(\"connection failed\"):\n                            connection_item.setText(\"Conexi\u00f3n fallida\")\n                            connection_item.setBackground(QColor(Qt.red))\n                        else:\n                            connection_item.setText(\"Conexi\u00f3n exitosa\")\n                            connection_item.setBackground(QColor(Qt.green))\n                        if device.get(\"connection failed\"):\n                            battery_item.setText(\"No aplica\")\n                            battery_item.setBackground(QColor(Qt.gray))\n                        else:\n                            battery_failing: bool = device.get(\"battery failing\") or not self.device_info.get(ip_selected, True)\n                            if battery_failing:\n                                battery_item.setText(\"Pila fallando\")\n                                battery_item.setBackground(QColor(Qt.red))\n                            else:\n                                battery_item.setText(\"Pila funcionando\")\n                                battery_item.setBackground(QColor(Qt.green))\n                connection_item.setFlags(connection_item.flags() &amp; ~Qt.ItemIsEditable)\n                self.table_widget.setItem(row, connection_column, connection_item)\n                battery_item.setFlags(battery_item.flags() &amp; ~Qt.ItemIsEditable)\n                self.table_widget.setItem(row, battery_column, battery_item)\n\n            self.adjust_size_to_table()\n\n            self.table_widget.setSortingEnabled(True)\n            self.table_widget.sortByColumn(6, Qt.DescendingOrder)    \n\n            self.deselect_all_rows()\n            super().op_terminate()\n            self.table_widget.setVisible(True)\n        except Exception as e:\n            raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"},{"location":"api/#src.ui.update_time_device_dialog.UpdateTimeDeviceDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the UpdateTimeDeviceDialog class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>The parent widget for this dialog. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>device_info</code> <code>dict[str, bool]</code> <p>A dictionary containing device information loaded from <code>load_device_info()</code>.</p> <p>Raises:</p> Type Description <code>BaseError</code> <p>If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.</p> Source code in <code>src\\ui\\update_time_device_dialog.py</code> <pre><code>def __init__(self, parent = None):\n    \"\"\"\n    Initializes the UpdateTimeDeviceDialog class.\n\n    Args:\n        parent (Optional[QWidget]): The parent widget for this dialog. Defaults to None.\n\n    Attributes:\n        device_info (dict[str, bool]): A dictionary containing device information loaded from `load_device_info()`.\n\n    Raises:\n        BaseError: If an exception occurs during initialization, it raises a BaseError with code 3501 and the exception message.\n    \"\"\"\n    try:\n        hour_manager = HourManager()\n        super().__init__(parent, op_function=hour_manager.manage_hour_devices, window_title=\"ACTUALIZAR HORA\")\n        self.device_info: dict[str, bool] = self.load_device_info()\n        self.init_ui()\n    except Exception as e:\n        raise BaseError(3501, str(e))\n</code></pre>"},{"location":"api/#src.ui.update_time_device_dialog.UpdateTimeDeviceDialog.init_ui","title":"<code>init_ui()</code>","text":"<p>Initializes the user interface for the update time device dialog.</p> <p>This method sets up the table headers with predefined labels and updates the text of the update button to \"Actualizar hora\".</p> Header Labels <ul> <li>Distrito</li> <li>Modelo</li> <li>Punto de Marcaci\u00f3n</li> <li>IP</li> <li>ID</li> <li>Comunicaci\u00f3n</li> </ul> Source code in <code>src\\ui\\update_time_device_dialog.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initializes the user interface for the update time device dialog.\n\n    This method sets up the table headers with predefined labels and updates\n    the text of the update button to \"Actualizar hora\".\n\n    Header Labels:\n        - Distrito\n        - Modelo\n        - Punto de Marcaci\u00f3n\n        - IP\n        - ID\n        - Comunicaci\u00f3n\n    \"\"\"\n    header_labels: list[str] = [\"Distrito\", \"Modelo\", \"Punto de Marcaci\u00f3n\", \"IP\", \"ID\", \"Comunicaci\u00f3n\"]\n    super().init_ui(header_labels=header_labels)\n    self.btn_update.setText(\"Actualizar hora\")\n</code></pre>"},{"location":"api/#src.ui.update_time_device_dialog.UpdateTimeDeviceDialog.load_device_info","title":"<code>load_device_info()</code>","text":"<p>Loads device information from a file and returns it as a dictionary.</p> <p>The method reads the file \"info_devices.txt\" line by line, extracts the IP address and battery status from each line, and stores them in a dictionary. The IP address is used as the key, and the battery status (a boolean) is used as the value.</p> <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>A dictionary where the keys are IP addresses (str) and the             values are battery statuses (bool).</p> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an error occurs while reading the file, an exception</p> Source code in <code>src\\ui\\update_time_device_dialog.py</code> <pre><code>def load_device_info(self):\n    \"\"\"\n    Loads device information from a file and returns it as a dictionary.\n\n    The method reads the file \"info_devices.txt\" line by line, extracts the IP address\n    and battery status from each line, and stores them in a dictionary. The IP address\n    is used as the key, and the battery status (a boolean) is used as the value.\n\n    Returns:\n        (dict[str, bool]): A dictionary where the keys are IP addresses (str) and the\n                        values are battery statuses (bool).\n\n    Raises:\n        BaseErrorWithMessageBox: If an error occurs while reading the file, an exception\n        is raised with an error code and the exception message.\n    \"\"\"\n    device_info: dict[str, bool] = {}\n    try:\n        with open(\"info_devices.txt\", \"r\") as file:\n            for line in file:\n                parts: list[str] = line.strip().split(\" - \")\n                if len(parts) == 8:\n                    ip: str = parts[3]\n                    battery_status: bool = parts[6] == \"True\"\n                    device_info[ip] = battery_status\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3001, str(e), parent=self)\n    return device_info\n</code></pre>"},{"location":"api/#src.ui.update_time_device_dialog.UpdateTimeDeviceDialog.op_terminate","title":"<code>op_terminate(devices_errors=None)</code>","text":"<p>Updates the table widget with the connection and battery status of devices. This method processes the <code>devices_errors</code> dictionary to update the table widget with the connection and battery status for each device. It ensures that the required columns exist in the table, updates the rows with the appropriate status and colors, and adjusts the table's size and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>devices_errors</code> <code>dict[str, dict[str, bool]]</code> <p>A dictionary where the keys are device IP addresses, and the values are dictionaries containing error statuses for the device. The inner dictionary can have the following keys:</p> <ul> <li>\"connection failed\" (bool): Indicates if the connection to the device failed.</li> <li>\"battery failing\" (bool): Indicates if the device's battery is failing.</li> </ul> <p>Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BaseErrorWithMessageBox</code> <p>If an exception occurs during the operation, it raises a custom error with a message box displaying the error details.</p> Source code in <code>src\\ui\\update_time_device_dialog.py</code> <pre><code>def op_terminate(self, devices_errors: dict[str, dict[str, bool]] = None):\n    \"\"\"\n    Updates the table widget with the connection and battery status of devices.\n    This method processes the `devices_errors` dictionary to update the table widget\n    with the connection and battery status for each device. It ensures that the required\n    columns exist in the table, updates the rows with the appropriate status and colors,\n    and adjusts the table's size and sorting.\n\n    Args:\n        devices_errors (dict[str, dict[str, bool]], optional): A dictionary where the keys\n            are device IP addresses, and the values are dictionaries containing error\n            statuses for the device. The inner dictionary can have the following keys:\n\n            - \"connection failed\" (bool): Indicates if the connection to the device failed.\n            - \"battery failing\" (bool): Indicates if the device's battery is failing.\n\n            Defaults to None.\n\n    Raises:\n        BaseErrorWithMessageBox: If an exception occurs during the operation, it raises\n            a custom error with a message box displaying the error details.\n    \"\"\"\n    #logging.debug(devices_errors)\n    try:\n        connection_column = self.ensure_column_exists(\"Estado de Conexi\u00f3n\")\n        battery_column = self.ensure_column_exists(\"Estado de Pila\")\n\n        for row in range (self.table_widget.rowCount()):\n            ip_selected: str = self.table_widget.item(row, 3).text()  # Column 3 holds the IP\n            connection_item: QTableWidgetItem = QTableWidgetItem(\"\")\n            battery_item: QTableWidgetItem = QTableWidgetItem(\"\")\n            if ip_selected not in self.selected_ips:\n                connection_item.setBackground(QColor(Qt.white))\n                battery_item.setBackground(QColor(Qt.white))\n            else:\n                device: dict[str, bool] = devices_errors.get(ip_selected)\n                if device:\n                    if device.get(\"connection failed\"):\n                        connection_item.setText(\"Conexi\u00f3n fallida\")\n                        connection_item.setBackground(QColor(Qt.red))\n                    else:\n                        connection_item.setText(\"Conexi\u00f3n exitosa\")\n                        connection_item.setBackground(QColor(Qt.green))\n                    if device.get(\"connection failed\"):\n                        battery_item.setText(\"No aplica\")\n                        battery_item.setBackground(QColor(Qt.gray))\n                    else:\n                        battery_failing: bool = device.get(\"battery failing\") or not self.device_info.get(ip_selected, True)\n                        if battery_failing:\n                            battery_item.setText(\"Pila fallando\")\n                            battery_item.setBackground(QColor(Qt.red))\n                        else:\n                            battery_item.setText(\"Pila funcionando\")\n                            battery_item.setBackground(QColor(Qt.green))\n            connection_item.setFlags(connection_item.flags() &amp; ~Qt.ItemIsEditable)\n            self.table_widget.setItem(row, connection_column, connection_item)\n            battery_item.setFlags(battery_item.flags() &amp; ~Qt.ItemIsEditable)\n            self.table_widget.setItem(row, battery_column, battery_item)\n\n        self.adjust_size_to_table()\n\n        self.table_widget.setSortingEnabled(True)\n        self.table_widget.sortByColumn(6, Qt.DescendingOrder)    \n\n        self.deselect_all_rows()\n        super().op_terminate()\n        self.table_widget.setVisible(True)\n    except Exception as e:\n        raise BaseErrorWithMessageBox(3500, str(e), parent=self)\n</code></pre>"}]}